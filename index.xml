<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>self-salvation</title>
    <link>https://jinkes-li.github.io/</link>
    <description>Recent content on self-salvation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Nov 2022 21:24:31 +0800</lastBuildDate><atom:link href="https://jinkes-li.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数据约束条件</title>
      <link>https://jinkes-li.github.io/databases/%E6%95%B0%E6%8D%AE%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6/</link>
      <pubDate>Thu, 24 Nov 2022 21:24:31 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/databases/%E6%95%B0%E6%8D%AE%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6/</guid>
      <description>MySQL字段约束条件 无符号， 零填充
非空
默认值
唯一值
主键
自增
外键
无符号，零填充
无符号，忽略数据中的正负符号关键字unsigned 零填充，数据未到数据位的情况下使用零填充
1. 验证零填充，查看数据345是否会被零填充 mysql&amp;gt; create table t1(id int unsigned, uid int(5) zerofill); Query OK, 0 rows affected (0.05 sec) mysql&amp;gt; insert into t1 values(123, 345); Query OK, 1 row affected (0.02 sec) mysql&amp;gt; select * from t1; +-----+-------+ | id | uid | +-----+-------+ | 123 | 00345 | +-----+-------+ 1 row in set (0.02 sec) mysql&amp;gt; 非空 not null MySQL数据库在不加约束条件的情况下字段的值是可以为空的</description>
    </item>
    
    <item>
      <title>SQL数据类型</title>
      <link>https://jinkes-li.github.io/databases/sql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 23 Nov 2022 19:39:41 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/databases/sql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>MySQL配置文件及常用语句 字符编码与配置文件
show status 可以使用show status查看系统运行的实时状态，便于做出相应优化，不可认为更改
show variables 查看系统参数，系统默认设置或者dba调整后的参数，静态的，可以通过set或者配置文件更改
MySQL字符相关
Mysql5.6之前版本的编码需要人为统一，之后的版本默认统一
5.6版本可以通过修改配置文件来永久修改编码配置
vim /etc/my.conf [mysqld] # 服务端 # add charcter-set-server=utf8mb4 collation-server=utf8mb4_general_ci [client] # 第三方客户端 default-character-set=utf8mb4 [mysql] # mysql自己的客户端 default-character-set=utf8mb4 上述更改为utf8mb4 可以支持表情，比utf8支持更多
数据库存储引擎 数据库正对数据采用的存储方式
# 查看常用的存储引擎 mysql&amp;gt; show engines; +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | Engine | Support | Comment | Transactions | XA | Savepoints | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ | InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES | | MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO | | MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO | | BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO | | MyISAM | YES | MyISAM storage engine | NO | NO | NO | | CSV | YES | CSV storage engine | NO | NO | NO | | ARCHIVE | YES | Archive storage engine | NO | NO | NO | | PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO | | FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL | +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+ 9 rows in set (0.</description>
    </item>
    
    <item>
      <title>数据库简单介绍及使用</title>
      <link>https://jinkes-li.github.io/databases/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 22 Nov 2022 16:58:20 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/databases/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</guid>
      <description>数据库的本质 数据库的分类 MySQL简介 MySQL基本使用 SQL与NoSQL 数据库相关概念 常见基本SQL语句 ####什么是数据 数据（data）是事实或观察的结果，是客观事物的逻辑归纳，是用于表示客观事物的未经过加工的的原始素材 数据可以是连续的值，比如声音，图像，称为模拟数据。也可以是离散的，如符号、文字，称为数字数据 在计算机系统中，数据以二进制信息单元0,1的形式表示
为什么不吧数据放入到word这些工具里？ 1.安全性 2.集群
####什么是数据库管理系统 DBMS（database management system） 1.管理数据 2.存储数据
####数据库的种类 1.关系型数据库（RDBMS）
典型产品：MySQL，Oracle，MSSQL（SQLserver）t-sql
表与表之间是由关联的（连表查询)
####菲关系型数据库（Nosql） 不使用SQL语句 json（key:value） MongoDB、Redis、elasticsearch
####关系型数据库与非关系型数据库功能对比 关系型和非关系型特点对比 关系型数据库（RDBMS）的特点：
1.二维表 2.典型产品Oracle传统企业，MySQL互联网企业 3.数据存取是通过SQL（Structured Query Language结构化查询语言） 4.最大特点数据安全性方面强（ACID） 非关系型数据库（NoSQL：Not only SQL）的特点：
1.不是否定关系型数据库，而是做关系型数据库的补充。 时代特点对比 web1.0时代 1.1 企业提供内容，用户浏览，所以关系型数据库够用，并发并不高，所以不需要nosql。 web2.0时代 2.1 核心是企业提供平台，用户参与提供内容，这个时代关系型数据库无法满足需求了。 2003NoSQL出现 3.1 memcache的诞生，关注的点是性能，但是针对安全性能关注比较低，随着安全性能需求不断提升，所以有了redis。 redis的特点 4.1 依然高性能高并发 4.2 数据持久化功能 4.3 支持多数据类型，主从复制和集群 4.4 管理不再使用SQL了 NoSQL的分类、特点、典型产品
1.键值（KV）存储：memcached、redis 2.列存储（column-oriented）：HBASE（新浪、360）Cassandra（200台服务器集群） 3.文档数据库（document-oriented）：MongoDB（最接近关系型数据库的NoSQL） 4.图形存储（Graph）：Neo4j 大版本 经典版本号 7 7.3.4 8i（internet） 8.</description>
    </item>
    
    <item>
      <title>并发编程(下)</title>
      <link>https://jinkes-li.github.io/python/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8B/</link>
      <pubDate>Mon, 21 Nov 2022 22:42:59 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8B/</guid>
      <description>多进程实现TCP服务端并发 # 导入socket import socket from multiprocessing import Process # 用于创建进程的模块 # 创建一个进程对象，由于需要实现并发，需要使用函数包起来供调用 def get_server(): # 创建一个进程对象 server = socket.socket() # 绑定服务端对外的地址和接口 server.bind((&amp;#39;127.0.0.1&amp;#39;, 8080)) # 设置半连接池 server.listen(5) # 返回创建的对象供调用 return server # 定义一个用于接收客户端连接的函数 def get_talk(sock): # 需要循环接收信息 while True: # 定义接收的信息以及需要处理的操作 data = sock.recv(1024) print(data.decode(&amp;#39;utf8&amp;#39;)) # 将接收到的信息转为大写 sock.send(data.upper()) # 判断是否为执行文件，主要作为兼容win if __name__ == &amp;#39;__main__&amp;#39;: # 获取服务端信息 server = get_server() # 循环开设进程 while True: # 用于接收客户端请求 sock, addr = server.accept() # 开设进程聊天 p = Process(target=get_talk, args=(sock,)) # 启动进程 p.</description>
    </item>
    
    <item>
      <title>第七周总结</title>
      <link>https://jinkes-li.github.io/python/%E7%AC%AC%E4%B8%83%E5%91%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 20 Nov 2022 21:28:31 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%AC%AC%E4%B8%83%E5%91%A8%E6%80%BB%E7%BB%93/</guid>
      <description>网络编程 网络名词 单机： 单台计算机无法与其他计算机通讯 联机：一般指两台计算机可以进行相互通讯 局域网： 一个独立的网络环境内使用统一网段和子网掩码的计算机使用交换机相互通信 广域网： 涉及现代社会中的一个区或更大范围的地址，每个独立的局域网使用上层交换机和路由器进行信息交互 省网： 以省级单位为区域的计算机信息交互 国网： 同省级相同理念 以上数据交互可统称为以太网或者互联网
广播 主机之间“一对所有”的通讯模式，网络对其中每一台主机发出的信号都进行无条件复制并转发，所有主机都可以接收到所有信息（不管你是否需要），由于其不用路径选择，所以其网络成本可以很低廉。有线电视网就是典型的广播型网络，我们的电视机实际上是接受到所有频道的信号，但只将一个频道的信号还原成画面。在数据网络中也允许广播的存在，但其被限制在二层交换机的局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机
ip地址与ip协议 规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4 它规定网络地址由32位2进制表示 范围0.0.0.0-255.255.255.255 一个ip地址通常写成四段十进制数，例：172.16.10.1
mac地址
head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址。 mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）
arp协议 ——查询IP地址和MAC地址的对应关系 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。 主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址。 收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。 地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。
路由器 路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。 路由器是互联网络的枢纽，&amp;ldquo;交通警察&amp;rdquo;。目前路由器已经广泛应用于各行各业，各种不同档次的产品已成为实现各种骨干网内部连接、骨干网间互联和骨干网与互联网互联互通业务的主力军。路由和交换机之间的主要区别就是交换机发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换机在移动信息的过程中需使用不同的控制信息，所以说两者实现各自功能的方式是不同的。
局域网 局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。　子网掩码　所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。
比如，已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算， 172.16.10.1：10101100.00010000.00001010.000000001 255255.255.255.0:11111111.11111111.11111111.00000000 AND运算得网络地址结果：10101100.00010000.00001010.000000001-&amp;gt;172.16.10.0 172.16.10.2：10101100.00010000.00001010.00000010 255255.255.255.0:11111111.11111111.11111111.00000000 AND运算得网络地址结果：10101100.00010000.00001010.000000001-&amp;gt;172.16.10.0 结果都是172.16.10.0，因此它们在同一个子网络。 总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。
tcp协议和udp协议 用于应用程序之间的通信。如果说ip地址和mac地址帮我们确定唯一的一台机器，那么我们怎么找到一台机器上的一个软件呢？
端口 我们知道，一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。
TCP协议 当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。
这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。
TCP 三次握手和四次挥手 TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK[1]，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接。[1]</description>
    </item>
    
    <item>
      <title>并发编程(中)</title>
      <link>https://jinkes-li.github.io/python/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD/</link>
      <pubDate>Fri, 18 Nov 2022 23:35:48 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD/</guid>
      <description>同步与异步 阻塞与非阻塞 创建进程的多种方式 进程join方法 进程间数据隔离 进程间通信之IPC机制 进程对象诸多方法 生产者消费者模型 互斥锁 引言：
在了解接下里的概念需要先明白一些基本知识
任务：操作系统可以同时运行多个任务。例如：一边上网，一边听音乐。这就是操作系统的多任务。操作系统会轮流让各个任务交替执行，但由于CPU的执行实在是太快了，给我们感觉就像所有任务都在同时进行一样。 进程：一个任务就是一个进程 线程：线程是进程的基本单位，一个任务最少有一个线程 同步与异步 同步和异步说的都是编程语言在执行代码时的一个状态，简而言之的描述就是用来表达人物的提交方式
同步 当提交任务后会等待返回结果再向下执行，相当与如果没有返回代码会一直等待
异步 当提交任务后不会等待返回的结果，代码则继续执行，如果有结果会通过反馈机制返回
阻塞与非阻塞 阻塞和非阻塞说的就是当前程序的执行状态
阻塞 程序运行中的三状态的阻塞态
非阻塞 程序运行中的三状态的就绪态和运行态
需要明白的是一般我们再说这几种状态时，会组合着说
同步阻塞 同步非阻塞 异步阻塞 异步非阻塞（效率最高） 创建进程的方式 在使用桌面操作系统时，当我们使用鼠标双击一个应用程序，程序运行就相当于创建了一个进程 例如电脑上的qq可以开多个，这也就是相当于开了多进程 那么在python中如何开启多个进程，代码实例如下 小知识：win和linux/mac 操作系统创建经常方式的区别
win中在创建进程时会以模块导入的方式将代码导入内存中执行，这样会导致重复执行所以在win中创建多经常需要添加main来判断是不是执行文件，否则会出现重复导入的问题 linux或者mac系统同在创建多进程时，会直接将创建进程上面的代码复制到内存当中，所以在linux中或者mac中不存在这个问题 关于创建子进程，UNIX和windows 1.相同的是：进程创建后，父进程和子进程有各自不同的地址空间（多道技术要求物理层面实现进程之间内存的隔离），任何一个进程的在其地址空间中的修改都不会影响到另外一个进程。 2.不同的是：在UNIX中，子进程的初始地址空间是父进程的一个副本，提示：子进程和父进程是可以有只读的共享内存区的。但是对于windows系统来说，从一开始父进程与子进程的地址空间就是不同的。 # 创建进程的方式 # 需要使用multiprocessing 这个包下的Process from multiprocessing import Process import time def task(): print(&amp;#39;task is running&amp;#39;, &amp;#39;wesley&amp;#39;) time.sleep(3) print(&amp;#39;task is over&amp;#39;, &amp;#39;wesley&amp;#39;) if __name__ == &amp;#39;__main__&amp;#39;: p1 = Process(target=task) # 使用Process生成进程对象 p1.</description>
    </item>
    
    <item>
      <title>并发编程(上)</title>
      <link>https://jinkes-li.github.io/python/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8A/</link>
      <pubDate>Thu, 17 Nov 2022 21:36:13 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8A/</guid>
      <description>UDP基本代码使用
并发编程理论之操作系统发展史
多道技术
进程理论及调度算法
用户太与系统态
UDP协议
UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。 不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是有消息保护边界的。 对于空消息：tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），也可以被发送，udp协议会帮你封装上消息头发送过去。 不可靠不黏包的udp协议：udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠。
进程 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。 广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。 需要理解进程就需要先理解程序
程序： 值得是存放在存储设备上的可执行文件 进程：被操作系统运行起来的程序的另一种形式，可以看做是程序的另一种状态 单道技术和多道技术 单道技术 所有的程序排队执行 过程中不能重合 多道技术 利用空闲时间提前准备其他数据 最大化提升CPU利用率 多道技术详细 1.切换 计算机的CPU在两种情况下会切换(不让你用 给别人用) 1.程序有IO操作 输入\输出操作 input、time.sleep、read、write 2.程序长时间占用CPU	我们得雨露均沾 让多个程序都能被CPU运行一下 2.保存状态 CPU每次切换走之前都需要保存当前操作的状态 下次切换回来基于上次的进度继续执行 进程理论 进程与程序的区别 程序:一堆死代码(还没有被运行起来) 进程:正在运行的程序(被运行起来了) 进程的调度算法(重要) 1.FCFS(先来先服务) 对短作业不友好 2.短作业优先调度 对长作业不友好 3.时间片轮转法+多级反馈队列(目前还在用) 将时间均分 然后根据进程时间长短再分多个等级 等级越靠下表示耗时越长 每次分到的时间越多 但是优先级越低 进程的并行与并发 并行 多个进程同时执行 必须要有多个CPU参与 单个CPU无法实现并行 并发 多个进程看上去像同时执行 单个CPU可以实现 多个CPU肯定也可以 判断下列两句话孰对孰错 我写的程序很牛逼，运行起来之后可以实现14个亿的并行量 并行量必须要有对等的CPU才可以实现 我写的程序很牛逼，运行起来之后可以实现14个亿的并发量 合情合理 完全可以实现	以后我们的项目一般都会追求高并发 ps:目前国内可以说是最牛逼的&amp;gt;&amp;gt;&amp;gt;:12306 进程的三状态 就绪态 所有的进程在被CPU执行之前都必须先进入就绪态等待 运行态 CPU正在执行 阻塞态 进程运行过程中出现了IO操作 阻塞态无法直接进入运行态 需要先进入就绪态 用户态和内核态的转换 用户态切换到内核态的3种方式 a.</description>
    </item>
    
    <item>
      <title>网络技术(下)</title>
      <link>https://jinkes-li.github.io/python/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8B/</link>
      <pubDate>Wed, 16 Nov 2022 19:12:45 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8B/</guid>
      <description>网络编程 传输层之TCP与UDP 应用层 socket模块简介 socket模块基本使用 代码优化处理 socket黏包问题 黏包问题的解决问题 TCP/IP协议簇 由多个协议组成，其中以TCP于IP为代表，本文详细介绍TCP和UDP
UDP协议 UDP协议定义了端口，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息，当数据包到达主机以后，就可以根据端口号找到对应的应用程序了。UDP协议比较简单，实现容易，但它没有确认机制，数据包一旦发出，无法知道对方是否收到，因此可靠性较差，为了解决这个问题，提高网络可靠性，TCP协议就诞生了。 TCP协议 TCP即传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议。简单来说TCP就是有确认机制的UDP协议，每发出一个数据包都要求确认，如果有一个数据包丢失，就收不到确认，发送方就必须重发这个数据包。为了保证传输的可靠性，TCP协议在UDP基础之上建立了三次对话的确认机制，即在正式收发数据前，必须和对方建立可靠的连接。TCP数据包和UDP一样，都是由首部和数据两部分组成，唯一不同的是，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 TCP和UDP主要区别 简单来说一个TCP需要建立通道确认应答，UDP则直接发送 这里借鉴鸡哥博客中的原理图
TCP重要原理图，三次握手四次挥手 应用层 应用层相当于是相当于程序员自己写的程序，本层具有相当多的协议 这里常需要使用的是httpshttp FTP
socket模块 Socket 是应用层于TCP/IP协议簇通信的之间软件抽象层，是一组接口，在设计模式中，Socket其实就是一个门面模式 把复杂的TCP/IP协议簇隐藏在Socket接口后面，对于用户来说直接调用接口，已符合指定的协议
套接字（socket）的发展史 套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。
基于文件类型的套接字家族 套接字家族的名字：AF_UNIX unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信
基于网络类型的套接字家族 套接字家族的名字：AF_INET (还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)
Socket-TCP在python中的应用 本质上来说python中的Socket是一个类，也是一个内置模块，需要导入使用
1. Server import socket &amp;#34;&amp;#34;&amp;#34; 在写代码时建议查看源码写代码的思路 &amp;#34;&amp;#34;&amp;#34; # 1. 产生一个Socket对象并指定采用的通信版本和协议（TCP） server = socket.socket() # 括号内不写参数，默认使用TCP协议，查看源码得知family=AF_INET基于网络的套接字， type=SOCK_STREAM流式协议即TCP # 2. 绑定一个固定的地址，需要设定对外提供服务的端口和IP server.bind((&amp;#39;127.0.0.1&amp;#39;, 8080)) # 3. 设立半连接池 server.</description>
    </item>
    
    <item>
      <title>网络技术(上)</title>
      <link>https://jinkes-li.github.io/python/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8A/</link>
      <pubDate>Tue, 15 Nov 2022 20:56:06 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8A/</guid>
      <description>开发架构和网络相关 软件开发架构 架构发展趋势 网络编程前夕 OSI七层协议 各种重点协议 1.C/S架构 Client:客户端 Server:服务端 &amp;#34;&amp;#34;&amp;#34; 我们使用计算机下载下来的一个个app本质是各大互联网公司的客户端软件 通过这些客户端软件我们就可以体验到各个互联网公司给我们提供的服务 eg: 下载淘宝客户端 打开 体验淘宝服务端提供的购物服务 下载抖音客户端 打开 体验抖音服务端提供的视频服务 ps:一般情况下客户端与服务端交互需要互联网 但是有些不需要(因为客户端和服务端都在一台计算机上) 客户端:即将要去消费的客人 服务端:给客人提供服务的店 作为服务端必备的多个条件 1.24小时不间断提供服务 2.固定的地址 3.能够服务多个客人(高并发) &amp;#34;&amp;#34;&amp;#34; 2.B/S架构 Browser:浏览器 Server:服务器/端 &amp;#34;&amp;#34;&amp;#34; 浏览器可以充当所有服务端的客户端 ps:B/S架构本质还是C/S架构 &amp;#34;&amp;#34;&amp;#34; &amp;#39;&amp;#39;&amp;#39; C/S架构 优势:不同公司的客户端由不同公司独立开发 可以高度定制化客户端功能 劣势:需要下载才能使用 B/S架构 优势:不用下载直接访问 劣势:无法高度定制化 并且需要遵守很多规则 &amp;#39;&amp;#39;&amp;#39; 架构总结 ATM:三层架构 选课系统:三层架构 本质也属于软件开发架构的范畴 软件设计的大方向&amp;gt;&amp;gt;&amp;gt;:统一接口 微信小程序 支付宝小程序 网络编程前戏 1.什么是网络编程 基于网络编写代码 能够实现数据的远程交互 2.学习网络编程的目的 能够开发cs架构的软件 3.网络编程的起源 &amp;#34;&amp;#34;&amp;#34; 最早起源于美国军事领域 想实现计算机之间数据的交互 最早的时候只能用硬盘拷贝 之后发明了网络编程 &amp;#34;&amp;#34;&amp;#34; 4.网络编程必备条件 数据的远程交互 1.早期的电话 电话线 2.早期的大屁股电脑	网线 3.</description>
    </item>
    
    <item>
      <title>程序设计及单例实现</title>
      <link>https://jinkes-li.github.io/python/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 09 Nov 2022 16:01:38 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0/</guid>
      <description>程序设计及单例实现 程序设计23种模式
单例实现
pickle序列化模块
设计原则七大原则
单一职责原则（Single Reponsibility Principle） 是尽量让一个类负责一个接口（功能）。 开闭原则（Open/Close Principle） 是指编写类的时候，要符合对类扩展开放，对类的修改关闭。 里氏替换原则（Liskov substitution Principle） 是指我们的编写子类，可以在保证业务正确的情况下，替换掉父类。 接口隔离原则（Interface Segregation Principle） 是指接口应该保持单一性，一个接口干一件事情。不要合并多个接口到一个接口。 依赖反转原则（Dependency Inversion Principle） 指高层模块不应该依赖底层模块，具体就是Controller使用Service的接口，而不应该直接使用Service具体类。 迪米特原则/最少知识原则（Least Knowledge Principle） 是指使用类和被使用类之间有个中介，达到使用者尽可能少的知道被使用者的信息。也就是如果客户端要使用service，那么客户端直接使用service的中介就好了。 设计模式分类 创建型模式： 描述的是根据需求怎样创建对象。 结构型模式： 描述的是如何处理类或者对象之间的关系，通过某种布局组成一个比较完善的结构。然后方便客户端使用。 行为型模式： 描述多个类或者对象如何协同处理单个对象无法完成的任务。（程序在运行时复杂的流程控制）。 我们应该根据自己的应用场景，选择合适的模式类型，再定位具体的设计模式。
创建型模式 描述的是根据需求怎样创建对象。 单例模式（Singleton Pattern）: 如何在系统环境确保某个类的对象只能创建一个对象。 原型模式（Prototype Pattern）: 就是如何完全复制出已经存在的一个对象。主要是通过Clone,Serializable来实现。参看:深拷贝和浅拷贝（Shallow Copy and Deep Copy）
工厂方法模式（Fatory Method Pattern）: 是指在父类中定义获取对象接口（工厂方法）和使用对象，但是具体的创建对象由子类完成。
抽象工厂模式（Abstract Method Pattern）: 就是创建一个抽象的工厂，这个工厂可以生产想要的对象（具体有他的子类完成），然后通过FactoryProductor生产出工厂，客户端使用工厂对象获取对象。
建造者模式（Builder Pattern）: 就是创建一个用于方便创建对象的一个类。参考：建造者模式
结构型模式 描述的是如何处理类或者对象之间的关系，通过某种布局组成一个比较完善的结构。然后方便客户端使用。 代理模式（Proxy Pattern）: 实质上是创建一个代理对象，而这个带来对象包含了对目标对象的引用。动态代理可以带来任何对象，静态带来可以代理某一类对象。
适配器模式（Adapter Pattern）: 主要是组合两个不同的功能组件，通过适配器进行合并。具体办法就是：就是target是一个接口，Adapter实现这个接口，并且持有这个Adaptee的引用。
桥接模式（Bridge Pattern）: 通过抽象和实现分离 达到 对象可以独立变化。这种模式避免了过多的子类，通过使用组合的方法独立变化（interface和abstract）。</description>
    </item>
    
    <item>
      <title>面向对象(终章)</title>
      <link>https://jinkes-li.github.io/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%88%E7%AB%A0/</link>
      <pubDate>Tue, 08 Nov 2022 22:42:11 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%88%E7%AB%A0/</guid>
      <description>面向对象(终章) 面向对象的魔法方法 基于魔法方法的面试题 元类简介 创建类的两种方式 元类定制类的产生行为 元类定制对象的产生行为 魔法方法之双下new方法 设计模式简介及单例模式 面向对象的魔法方法
欢迎来到魔法学院 魔法方法：类中定义的双下方法都被称为魔法方法 魔法方法不需要人为调用，在特定的条件下会自动触发运行 eg: __init__创建空对象之后自动触发给对象添加独有的数据
常用的魔法方法 1. __init__ 对象添加独有数据时自动触发 2. __str__ 对象执行打印操作的时候会自动触发 3. __call__ 对象加括号调用的时候会自动触发 4. __getattr__ 对象使用句点符.一个不存在的名字的时候会自动触发 5. __getattribute__ 对象点名字会触发，无论名字是否存在，有它则不会执行上面的getattr方法 6. __setattr__ 给对象添加或修改数据的时候制动触发 对象.名字 = 值 7. __enter__ 当对象被当做with上下文管理里操作的时候开始自动触发，并且该方法返回什么 as 后面的变量名就会接收到什么 8. __exit__ with 上下文管理语法运行完毕后 自动触发（子代码结束） 魔法方法的实际应用 1. 案例一 &amp;#34;&amp;#34;&amp;#34; 题目： 思考如何对下列代码补全炒作，使代码运行不会报错 &amp;#34;&amp;#34;&amp;#34; class Context: def do_something(self): pass def __enter__(self): return self def __exit__(self, exc_type, exc_val, exc_tb): pass with Context() as f: f.</description>
    </item>
    
    <item>
      <title>Python面向对象(下)</title>
      <link>https://jinkes-li.github.io/python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8B/</link>
      <pubDate>Mon, 07 Nov 2022 20:02:49 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8B/</guid>
      <description>python面向对象 派生方法实站演练
面向对象三大特性之封装
面向对象三大特性之多态
面向对象之反射
反射的实战案例
派生方法实战演练
# 需使用序列化的方式的在字典中得到时间 import json import datetime d = { &amp;#39;t1&amp;#39;: datetime.date.today(), &amp;#39;t2&amp;#39;: datetime.datetime.today(), &amp;#39;t3&amp;#39;: &amp;#39;wesley&amp;#39; } res = json.dumps(d) print(res) # 这里打印直接发现报错 1. 方法一 # 使用字符串的方式直接强制转换，在字典的值中使用字符串强制转换 d = { &amp;#39;t1&amp;#39;: str(datetime.date.today()), &amp;#39;t2&amp;#39;: str(datetime.datetime.today()), &amp;#39;t3&amp;#39;: &amp;#39;wesley&amp;#39; } # 得到以下输出 {&amp;#34;t1&amp;#34;: &amp;#34;2022-11-07&amp;#34;, &amp;#34;t2&amp;#34;: &amp;#34;2022-11-07 14:47:01.042696&amp;#34;, &amp;#34;t3&amp;#34;: &amp;#34;wesley&amp;#34;} # 第二种 派生的方法 # 1. 序列化报错，先看一下dumps源码 # 2. 找到了一个命名关键字参数，cls=None 继续向下寻找相关 &amp;#34;&amp;#34;&amp;#34; 3. 通过上述行为找到了关于cls的判断，看到默认传参JSONEncoder，所以这里继续向下寻找 if cls is None: cls = JSONEncoder return cls( 4.</description>
    </item>
    
    <item>
      <title>第六周总结</title>
      <link>https://jinkes-li.github.io/python/%E7%AC%AC%E5%85%AD%E5%91%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 06 Nov 2022 16:56:07 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%AC%AC%E5%85%AD%E5%91%A8%E6%80%BB%E7%BB%93/</guid>
      <description>第六周总结 引言：
本周内容主要在于面向对象编程的思想
编程思想 面向对象重要理论 面向对象代码实操 对象的独有数据 对象的独有方法 动静态方法 面对对象继承 对象查找名字的顺序 继承的本质 基于继承的派生方法 编程思想 面向过程 面向过程指的是将一个问题进行流程化处理，在处理过程中问题将会越来越简单，最终得到结果 面向对象 面向对象需要把自己当做造物主，将问题拆分创造一个个对象具有解决问题的数据与功能 在面向对象编程中有三大特性
封装 继承 多态 名词解释： 1. 类： 用来描述具有相同属性和方法的对象的集合，类定义了该集合中每个对象所有的属性和方法，并切对象就是类的实例 2. 对象： 通过类定义的数据结构实例
面向对象重要理论 多个具有相同属性和功能的对象被称为类 同一个类中的对象都可以调用这个类中的公共功能和数据 在python语言中必须先定义类后才能定义对象 创造对象后 对象是无法控制和预测 面向对象代码实操 # 类的语法 class Class_name: &amp;#34;&amp;#34;&amp;#34; 类的描述 &amp;#34;&amp;#34;&amp;#34; # 类的公共数据 common_data = &amp;#39;123班级&amp;#39; # 类的公共功能 def common_func(self): pass # class 定义类的关键字，后面是类的名字，定义和变量名的区别是首字母大写用于区分 # 类的公共数据，这个类产生的所有对象都可以调用的相同数据，这个数据是共享的 # def common_func(self): 类的公共功能，具有一定功能的函数 在面向对象中，类和对象访问数据或者功能，可以通过句点符点出类中的数据和功能
查看名称空间 # 定义一个类 class Student: school_name = &amp;#39;野鸡大学&amp;#39; def common_func(self): pass # 查看当前的名称空间 print(Student.</description>
    </item>
    
    <item>
      <title>Python面对对象(中)</title>
      <link>https://jinkes-li.github.io/python/python%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B8%AD/</link>
      <pubDate>Thu, 03 Nov 2022 19:00:58 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B8%AD/</guid>
      <description>python面向对象 动静态方法
面对对象值继承理论
继承基本操作
对象查找名字的顺序
继承本质
基于继承的派生方法
动静态方法
方法也就是函数，什么叫动静态呢，就是指自己传参的就是动态，需要手动传参的就是静态，这些方法又是如何被定义的呢，主要方式有三种
1. 动态方法 class Student: school_name = &amp;#39;摆烂大学&amp;#39; # 1. 类中直接定义函数，默认绑定给对象，类调用有几个参数传几个，对象调用的第一个参数就是对象自身 def func1(self): print(&amp;#39;看看谁最能摆烂，很棒&amp;#39;) obj = Student() # 1. 绑定给对象的方法 obj.func1() # 类调用 Student.func1(123) 结果： 看看谁最能摆烂，很棒 看看谁最能摆烂，很棒 &amp;#34;&amp;#34;&amp;#34; 1. 第一种在定义方法时 在类中直接定义，默认是绑定给对象的，也就是说使用对象调用时会将对象名当做第一个参数传入，所以这里第一步调用的时候不需要额外的参数 2. 而在我们使用类调用这个方法时，有几个参数就需要写几个，需要对应传入的参数并不会有什么特殊的作用仅仅是占位传参 &amp;#34;&amp;#34;&amp;#34; 2. 动态方法 class Student: school_name = &amp;#39;摆烂大学&amp;#39; # 2. 被@classmethod修饰的函数，默认绑定给类，类调用的第一个参数就是类自身，对象也可以调用并且会自动将产生该对象的类当做第一个参数传入 @classmethod def func2(cls): print(&amp;#39;猜猜我是干嘛滴&amp;#39;, cls) obj = Student() # 2. 绑定给类的方法 Student.func2() obj.func2() 猜猜我是干嘛滴 &amp;lt;class &amp;#39;__main__.Student&amp;#39;&amp;gt; 猜猜我是干嘛滴 &amp;lt;class &amp;#39;__main__.</description>
    </item>
    
    <item>
      <title>Python面向对象(上)</title>
      <link>https://jinkes-li.github.io/python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/</link>
      <pubDate>Wed, 02 Nov 2022 20:27:48 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/</guid>
      <description>python之面对对象 面向对象前夕
面向对象编程思想
面向对象重要理论
面向对象代码实操
对象的独有数据
对象的独有方法
面对对象前夕
接下来主要看一下如果不使用面对对象的方式如何定义一些对象和会出现的问题
代码演示：人汪大战 在这一步可以推导出来，如果有很多的人和很多汪，我们则需要写很多次重复代码
# 实现步骤1，先定义人和汪汪 person1 ={ &amp;#39;name&amp;#39;: &amp;#39;wesley&amp;#39;, &amp;#39;age&amp;#39;: 18, &amp;#39;gender&amp;#39;: &amp;#39;male&amp;#39;, &amp;#39;p_type&amp;#39;: &amp;#39;猛男&amp;#39;, &amp;#39;attack_val&amp;#39;: 8000, &amp;#39;life_val&amp;#39;: 999999 } person2 = { &amp;#39;name&amp;#39;: &amp;#39;kevin&amp;#39;, &amp;#39;age&amp;#39;: 28, &amp;#39;gender&amp;#39;: &amp;#39;female&amp;#39;, &amp;#39;p_type&amp;#39;: &amp;#39;淑女&amp;#39;, &amp;#39;attack_val&amp;#39;: 1, &amp;#39;life_val&amp;#39;: 100 } dog1 = { &amp;#39;name&amp;#39;: &amp;#39;小黑&amp;#39;, &amp;#39;d_type&amp;#39;: &amp;#39;泰迪&amp;#39;, &amp;#39;attack_val&amp;#39;: 100, &amp;#39;life_val&amp;#39;: 8000 } dog2 = { &amp;#39;name&amp;#39;: &amp;#39;小白&amp;#39;, &amp;#39;d_type&amp;#39;: &amp;#39;恶霸&amp;#39;, &amp;#39;attack_val&amp;#39;: 2, &amp;#39;life_val&amp;#39;: 80000 } 继续向下推导，将产生人和汪星人的字典封装为函数，并封装人和汪星人的攻击函数 1. 创建一个可以传入人数据的函数 def create_person(name, age, gender, p_type, attack_val, life_val): person_dict = { &amp;#39;name&amp;#39;: name, &amp;#39;age&amp;#39;: age, &amp;#39;gender&amp;#39;: gender, &amp;#39;p_type&amp;#39;: p_type, &amp;#39;attack_val&amp;#39;: attack_val, &amp;#39;life_val&amp;#39;: life_val } return person_dict 2.</description>
    </item>
    
    <item>
      <title>阶段复习一</title>
      <link>https://jinkes-li.github.io/python/%E9%98%B6%E6%AE%B5%E5%A4%8D%E4%B9%A0%E4%B8%80/</link>
      <pubDate>Tue, 01 Nov 2022 21:29:31 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E9%98%B6%E6%AE%B5%E5%A4%8D%E4%B9%A0%E4%B8%80/</guid>
      <description>阶段复习一 1.计算机基础阶段 计算机五大组成部分 1. 运算器 2. 控制器 3. 存储器 4. 输入设备 5. 输出设备 计算机三大核心硬件 1. 磁盘 2. 内存 3. CPU 操作系统 操作系统就是人与计算机硬件交互的前两 文件路径 1. 相对路径 2. 绝对路径 2.变量与常量 变量名 赋值符号 数据值、变量名、函数名、函数调用、生成式 遇到赋值符号先看符号右侧再看左侧 3.python基本数据类型 int整型、float浮点型、str字符串、list列表、dict字典、tuple元组、set集合、bool布尔值 4.垃圾回收机制 引用计数、标记清除、分代回收 5.用户交互 input\print 格式化输出 6.流程控制 if elif else while else break continue for else break continue range() 7.数据类型常用内置方法 字符串:索引取值切片、len()、strip()、split()、upper()、isdigit() 列表:索引取值切片、len()、append()、insert()、extend()、pop() 字典:按键取值、len()、get()、d[k] = v、keys()、values()、items() 8.字符编码 编码与解码	ASCII GBK UTF UNICODE encode() decode() 9.文件处理 with open(文件路径,模式,encoding=&amp;#39;utf8&amp;#39;) as f:pass 函数 1.</description>
    </item>
    
    <item>
      <title>ATM购物车中文版</title>
      <link>https://jinkes-li.github.io/python/atm%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%B8%AD%E6%96%87%E7%89%88/</link>
      <pubDate>Mon, 31 Oct 2022 22:41:42 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/atm%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%B8%AD%E6%96%87%E7%89%88/</guid>
      <description>APM+购物车 创建目录 创建项目文件ATM 依据软件开发目录 创建bin下的start.py文件 conf下的settings.py文件 core下的scr.py文件 interface下的user_interface文件 shop_interface文件bank_interface文件 lib下的common文件 db目录下的handler文件 readme requriments文件 log目录可以代码创建 在将与用户交互的第一层放入在scr中搭建整体对的框架出来
注册功能 首先获取用户的输入对的用户名及密码 核对二次输入的密码是否正确 正确的话 根据用户名去db目录的handler文件创数据的增删改查 依据模块os 拼接文件目录路径 再依据用户名创建文件的路径 再判断该路径在与不在 在的话输出读取到的对象字典 没有则返回None(这一步得放在创建文件之后 文件没创肯定读取不到) 再去新建用户字典 依据handler建的save将用户字典从写入到文件中则用户注册成功
登入功能 获取用户输入的用户名及密码 用用户名去判断是否能将用户字典读取出来 能读取则判断用户存在 可以从里拿出来密码比对是否正确 正确则登入成功 这时创建的一个全局变量 用来储存登入的用户是谁 因为后面的功能实现都要基于用户是否登入成功 而且是涉及多个功能要用 所以创建装饰器放在lib的common文件中 再依据登入成功去改变全局的字典存储用户名 装饰器再依据全局字典是否登入则判断后面的功能能否实现
查看用户余额 依据全局字典存储了用户登入的用户名 再依据用户名传值给函数去到第二层中的接口层user_interface 将其封装成函数靠用户名 去打开用户的字典读取到用户的余额
查看用户余额 依据全局字典存储了用户登入的用户名 再依据用户名传值给函数去到第二层中的接口层user_interface 将其封装成函数靠用户名 去打开用户的字典读取到用户的余额
提现功能 获取用户需要提现的金额 把当前登录的用户名， 和需要提现的金额传给接口层 获取当前用户的信息 拿到用户的余额和提现额度 用户的余额和 （提现的金额+手续费）做对比 若余额小 则 返回 余额不足 若余额不小 则比较提现金额和 提现额度的大小 若提现额度大 则 余额 - 提现金额 保	存 手续费 为零 返回 提现成功 若提现金额大 则 余额 - 提现金额 - 手 续费 保存 返回 提现成功</description>
    </item>
    
    <item>
      <title>第五周总结</title>
      <link>https://jinkes-li.github.io/python/%E7%AC%AC%E4%BA%94%E5%91%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 30 Oct 2022 18:57:24 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%AC%AC%E4%BA%94%E5%91%A8%E6%80%BB%E7%BB%93/</guid>
      <description>第五周总结 正则表达式
第三方模块
python模块
正则表达式
正则表达式，又称规则表达式,（Regular Expression，在代码中常简写为regex、regexp或RE），是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为&amp;quot;元字符&amp;quot;），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串，通常被用来检索、替换那些符合某个模式（规则）的文本
正则表达式前夕 为什么需要使用正则表达式
1. 这里以京东的注册时需要输入手机号为例 # 1. 获取用户输入 usercode = input(&amp;#39;请输入注册手机号： &amp;#39;) # 2. 分析，手机号为11位，判断位数是否相等11 if len(usercode) == 11: # 3. 判断用户输入的是否为纯数字 if usercode.isdigit(): # 4. 继续分析，手机号一般有很多开头，这里演示188开头 if usercode.startswith(&amp;#39;188&amp;#39;): print(&amp;#39;验证通过&amp;#39;) else: print(&amp;#39;请输入正确的手机号&amp;#39;) else: print(&amp;#39;请输入数字&amp;#39;) else: print(&amp;#39;请输入正确的手机号长度&amp;#39;) # 代码执行结果，只有188开头的手机号码才可以通过注册 请输入注册手机号： 18800000000 验证通过 2. 第一种方式太过于麻烦，接下来使用正则表达式来写 import re # python中使用正则的模块，稍后介绍 user_code = inpot(&amp;#39;请输入手机号&amp;#39;).strip() if re.match(&amp;#39;^188[0-9]{8}$&amp;#39;, user_code) print(&amp;#39;合法的手机号&amp;#39;) else: print(&amp;#39;非法的手机号&amp;#39;) # 代码执行结果 请输入手机号： 18000000000 合法的手机号 字符组 字符组内所有的数据默认都是或的关系 字符组默认匹配规则是一个一个匹配 [0123456789] 匹配0~9任意一个数 [0-9] 匹配0到9任意一个数(缩写) [a-z] 匹配26个小写英文字母 [A-Z] 匹配26个大写英文字母 [0-9a-zA-Z] 匹配数字或者小写字母或者大写字母 特殊符号 特殊符号默认匹配方式是挨个匹配</description>
    </item>
    
    <item>
      <title>Python模块(下)</title>
      <link>https://jinkes-li.github.io/python/python%E6%A8%A1%E5%9D%97%E4%B8%8B/</link>
      <pubDate>Thu, 27 Oct 2022 21:54:09 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E6%A8%A1%E5%9D%97%E4%B8%8B/</guid>
      <description>python模块 hashlib 加密模块
subprocess模块
logging 日志模块
logging模块的实际应用
hashlib加密模块
什么是加密 将明文数据处理成密文数据，确保其他人无法直接得到原本的信息
为什么加密 保证数据的安全性，防止软件或文件被篡改
如何判断数据是否加密 加密后的数据一般都是各种字符的组合，无法是被直接看懂的
密文的长短 密文越长表示使用的加密算法越复杂
基本的加密算法 md5, bash64, hmac, sha系列
# 加密算法的基本操作 import hashlib # 选择需要使用的加密算法，比如下面使用的是md5 md5 = hashlib.md5() # 使用update传入明文数据，可以分段传输也可以单次传输 md5.update(b&amp;#39;hello&amp;#39;) # 需要传入二进制数据 # 获得数据加密后的MD5值 res = md5.hexdigest() print(res) # 5d41402abc4b2a76b9719d911017c592 加密算法补充 1. 加密算法不变，内容不变，结果也相同 import hashlib md5 = hashlib.md5() md5.update(b&amp;#39;wesley&amp;#39;) res = md5.hexdigest() print(res) # 加密后的值 a09f91f8be77e65b371a64bf1d8305c9 # 刚刚提到了多次的分段传入也是没有问题的，下列代码演示 import hashlib md5 = hashlib.md5() md5.update(b&amp;#39;we&amp;#39;) md5.update(b&amp;#39;sl&amp;#39;) md5.update(b&amp;#39;ey&amp;#39;) res = md5.</description>
    </item>
    
    <item>
      <title>第三方模块</title>
      <link>https://jinkes-li.github.io/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 26 Oct 2022 20:22:04 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/</guid>
      <description>python第三方模块 第三方模块指的是别人写的模块，一般情况下功能都是非常强大的 如果使用第三方模块第一次必须使用pip指令下载后才可以调用
第三方模块的下载方式
下载时可能会出现的问题
爬虫之requests模块
自动化办公openpyxl模块
第三方模块扩展(模块叠模块)
第三方模块的下载方式
1. pip工具， 每个版本的解释器都有pip工具，当电脑上存在多版本解释器时需要知道我们在使用哪一个，为了避免冲突，会在pip工具重新复制一份起别名 2. 在下载模块，使用命令下载 php3 install 模块名 3. 在下载模块时，默认仓库指向的是python的官网，如果下载太慢建议更改为国内 php3 install 模块名 -i 国内仓库地址 4. 在安装模块时，若不想使用最新的模块可以使用==来指定版本 php3 install 模块名==版本号 5. 在编写代码时，pycharm也提供了一些操作界面的安装方式，不太推荐使用，毕竟代码运行的平台大多数还是linux 安装时可能存在的问题 下载第三方模块可能会出现的问题 1.报错并有警告信息 WARNING: You are using pip version 20.2.1; 原因在于pip版本过低 只需要拷贝后面的命令执行更新操作即可 d:\python38\python.exe -m pip install --upgrade pip 更新完成后再次执行下载第三方模块的命令即可 2.报错并含有Timeout关键字 说明当前计算机网络不稳定 只需要换网或者重新执行几次即可 3.报错并没有关键字 面向百度搜索 pip下载XXX报错:拷贝错误信息 通常都是需要用户提前准备好一些环境才可以顺利下载 4.下载速度很慢 pip默认下载的仓库地址是国外的 python.org 我们可以切换下载的地址 pip install 模块名 -i 仓库地址 pip的仓库地址有很多 百度查询即可 清华大学 ：https://pypi.tuna.tsinghua.edu.cn/simple/ 阿里云：http://mirrors.</description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://jinkes-li.github.io/python/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 25 Oct 2022 16:42:45 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>正则表达式 正则表达式前夕
正则表达式之字符组
正则表达式之量词
正则表达式之特殊符号
正则表达式练习
正则表达式贪婪匹配和非贪婪匹配
正则表达式应用
python正则模块re
正则表达式前夕
正则表达式，又称规则表达式,（Regular Expression，在代码中常简写为regex、regexp或RE），是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为&amp;quot;元字符&amp;quot;），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串，通常被用来检索、替换那些符合某个模式（规则）的文本。
1. 例如京东的注册页面，可以检测手机号的输入是否正确，这个功能如何实现 # 这里先不使用正则去使用python代码实现 # 京东注册页面实现手机号检测 # 1. 获取用户输入 usercode = input(&amp;#39;请输入注册手机号： &amp;#39;) # 2. 分析，手机号为11位，判断位数是否相等11 if len(usercode) == 11: # 3. 判断用户输入的是否为纯数字 if usercode.isdigit(): # 4. 继续分析，手机号一般有很多开头，这里演示188开头 if usercode.startswith(&amp;#39;188&amp;#39;): print(&amp;#39;验证通过&amp;#39;) else: print(&amp;#39;请输入正确的手机号&amp;#39;) else: print(&amp;#39;请输入数字&amp;#39;) else: print(&amp;#39;请输入正确的手机号长度&amp;#39;) # 代码执行结果，只有188开头的手机号码才可以通过注册 请输入注册手机号： 18800000000 验证通过 # 如果使用正则这个功能如何书写 import re user_code = input(&amp;#39;请输入手机号： &amp;#39;).strip() if re.match(&amp;#39;^188[0-9]{8}$&amp;#39;, user_code): print(&amp;#39;合法的手机号&amp;#39;) else: print(&amp;#39;非法手机号码&amp;#39;) # 代码运行结果 请输入手机号： 18800000000 合法的手机号 # 接下来我们来学习如何使用正则表达式 正则表达式之字符组 1.</description>
    </item>
    
    <item>
      <title>第四周总结</title>
      <link>https://jinkes-li.github.io/python/%E7%AC%AC%E5%9B%9B%E5%91%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 23 Oct 2022 19:02:45 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%AC%AC%E5%9B%9B%E5%91%A8%E6%80%BB%E7%BB%93/</guid>
      <description>第四周总结
异常处理和生成器对象
模块的概念和使用
编程思想和包的使用
常用的python模块
异常处理
在写程序的过程中可能会报出很多异常，而异常报出之后程序就会停止运行，当时有部分异常是对于用户来说是非致命的，所以这里就需要对一些可能出现的异常进行预测解决方案
常见的异常类型 1. SyntexError # 语法错误 2. indexError # 索引错误 3. nameError # 名字错误 4. keyError # 键错误 5. IndetationError # 缩进错误 异常的语法结构 首先来看一下异常的语法结构
# 单异常解决 try: 待监测的代码 except &amp;#39;接收的异常类型&amp;#39; as e: 解决异常的方案 # 多异常解决，多异常解决和单异常是一样的，只是多放了几个异常类型 try: 待监测的代码 except &amp;#39;第一种异常类型&amp;#39; as e: &amp;#39;解决方案&amp;#39; except &amp;#39;第二种异常类型&amp;#39; as e: &amp;#39;解决方案&amp;#39; # 万能异常，万能异常可以用于接收任何的异常，常用的万能异常接收有Exception和BaseException，这两个可以接收所有的异常 try: 待检测的代码 except Exception e: &amp;#39;解决方案&amp;#39; # try 异常还可以配合else使用，在执行中没有异常else才被执行， try: 待监测的代码 except &amp;#39;异常类型&amp;#39; as e: 解决方案 else: print(&amp;#39;上面全部没有异常我才会执行&amp;#39;) # finally 在使用了finally，无论上面的是否执行finally都会执行 try: 待监测的代码 except &amp;#39;异常类型&amp;#39; as e: 解决方案 else: print(解决方案) finally: print(&amp;#39;上面都执行完了，现在我再执行&amp;#39;) 异常的处理实战 # 异常一，这是由于未调用到变量名导致的 name1 = &amp;#39;wesley&amp;#39; name = &amp;#39;wesley1&amp;#39; try: if name == naeme1: print(&amp;#39;123&amp;#39;) except NameError as e: print(&amp;#39;未定义变量名&amp;#39;) 异常之断言 # 断言是用于预测上面被监测代码的类型，如果断言错误也会报出异常 # 使用 name = &amp;#39;wesley&amp;#39; assert isinstance(name, str) print(&amp;#39;类型为字符串&amp;#39;) # 需要注意，如果name的类型不是字符串，这个时候就会报错 主动抛出异常 try: name = &amp;#39;andy&amp;#39; if name == &amp;#39;andy&amp;#39;: raise Exception(&amp;#39;Error&amp;#39;): else: print(&amp;#39;不是andy，继续run&amp;#39;) 使用异常的注意事项 在写代码的过程中，可以不使用异常就不使用异常 如果必须使用，尽量不要超过10行代码 当代码中有不可预期的异常时再使用 异常的应用 # 使用异常实现for循环 l1 = [11, 22, 33, 44, 55] try: new = l1.</description>
    </item>
    
    <item>
      <title>Python模块上</title>
      <link>https://jinkes-li.github.io/python/python%E6%A8%A1%E5%9D%97%E4%B8%8A/</link>
      <pubDate>Thu, 20 Oct 2022 17:12:26 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E6%A8%A1%E5%9D%97%E4%B8%8A/</guid>
      <description>python模块 os和sys模块
json模块
os和sys模块
os模块主要是针对目前执行文件对操作系统的操作 sys模块主要是正对python解释器操作 os模块的用法 1. 创建目录 os.mkdir(r&amp;#39;d1&amp;#39;) # 当前目录下创建d1，不可以创建多级目录 os.makedirs(r&amp;#39;a1/b1/c1/d1&amp;#39;) # 当前目录下创建多级目录，也可以创建单级目录 2. 删除目录 os.rmdir(r&amp;#39;d1&amp;#39;) # 可以删除单级目录，如果有文件不可以删除，并且不可以删除多级目录 os.removedirs(r&amp;#39;a1/b1/c1/d1&amp;#39;) # 可以删除多成目录，只能删除空目录 3. 列举文件路径下内容名称 print(os.listdir(r&amp;#39;modular&amp;#39;)) # 列出当前目录下的所有文件 4. 删除重命名文件 os.rename(r&amp;#39;test&amp;#39;, &amp;#39;test.py&amp;#39;) # 重命名test文件 os.remove(r&amp;#39;test.py&amp;#39;) # 删除test.py 文件 5. 获取/切换当前工作目录 print(os.getcwd()) # 获取当前工作目录 os.chdir(&amp;#39;..&amp;#39;) # 切换工作目录 6. 动态获取项目根目录 print(os.path.abspath(__file__)) # 获取执行文件的绝对路径 print(os.path.dirname(__file__)) # 获取执行文件所在目录路径 7. 判断路径是否存在(文件/目录) print(os.path.exists(r&amp;#39;osandsys.py&amp;#39;)) # 判断文件是否存在 print(os.path.exists(r&amp;#39;/Users/wesley/PycharmProjects/python-1&amp;#39;)) # 判断路径是否存在 print(os.path.isfile(&amp;#39;osandsys.py&amp;#39;)) # 判断路径是否文件 True print(os.path.isfile(&amp;#39;/Users/wesley/PycharmProjects/python-1&amp;#39;)) # 判断路径是否文件 False print(os.</description>
    </item>
    
    <item>
      <title>编程思想和包的使用</title>
      <link>https://jinkes-li.github.io/python/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%92%8C%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 19 Oct 2022 17:27:15 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%92%8C%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>编程思想和包的使用 包的具体使用
编程思想转变
目录开发规范
常用内置模块
collections 时间模块 随机数模块 包的具体使用
虽然python3中不强制要求包里必须要有__init__.py这个文件，但是在写代码时最好将这个文件创建出来，放在代码兼容问题的出现
程序员写包时 ，一般会写很多模块文件，然后将模块在__init__.py文件中引用，这样我们在使用的时候就可以通过导入这个包然后调用包里的模块文件 编程思想 编程思想就是指我们在运到一个编程问题时的想法和思路，比如如果规划程序的架构方便后期更改，如何做到高聚合低耦合的代码架构，不具备编程思想的人只能写一些简单逻辑的代码，当这个程序员具备了编程思想后，很多问题都会迎刃而解 如何学习编程思想，就是多写多练，参考优秀代码，思想碰撞，参考其他人看待问题的逻辑，完善自身
软件开发目录 在我们开始实现一个复杂性系统时，首先考虑的并不是使用什么技术去实现，而是分析需求，分类需求并设计合理的项目目录结构
# 通用性软件开发目录 wesley@------*****------ ⮀ ~/Desktop ⮀ tree myproject myproject # 项目目录 ├── README # 项目说明文件 ├── bin # 执行文价夹 │ └── start.py ├── conf # 配置文件 │ └── settings.py ├── core # 源码，主要的功能代码 │ └── src.py ├── db # 数据库相关操作代码 │ ├── db_handler.py │ └── userinfo.txt ├── interface # api文件夹 │ ├── accpunt.py │ ├── goods.</description>
    </item>
    
    <item>
      <title>模块的概念与使用</title>
      <link>https://jinkes-li.github.io/python/%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 18 Oct 2022 17:09:09 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>调包侠之Python模块 索引取值和迭代取值的差异
模块简介
导入模块的两种句式
导入模块句式补充
循环导入问题解决策略
判断文件类型
模块的查找顺序
模块的绝对导入和相对导入
包的概念
索引取值和迭代取值的差异
两者的使用主要是应用在不同的应用场景
索引取值 索引取值可以在不同的位置反复的取值 不支持无序类型的取值 迭代取值 只能重前往后取值且无法后退 支持对无序数据取值 模块介绍 模块的本质就是内部具有一定功能的py文件 python的黑历史，在刚开始不火的时候被人戏称为调包侠，随着越来越多的程序员加入，先在看到python都要称一声调包侠 python模块的表现形式 python文件也可以称为模块文件 包含多个python文件的文件夹被称为包，（python2中的包文件具有__init__.py文件） 已经编译为共享库或DLL的c或者C++扩展 使用C编写并链接到python解释器的内置模块 模块分类 自定义模块 自定义模块就是程序员自己写的py文件 内置模块 python解释器自带的模块 第三方模块 由一些开发者大佬写的模块，我们可以直接使用pip安装并调用 导入模块的两种句式 注意： 这里一定要注意谁是被执行文件
import modular_name from modular_name import parameter 1. import modular_name &amp;#34;&amp;#34;&amp;#34; 使用import导入模块的原理 案例： 现在run.py作为被执行文件需要导入同级目录下的register.py并调用其中的userinfo列表，代码如下： # run.py # 作为被执行文件 import register print(register.userinfo) # register.py # 作为模块 userinfo = [&amp;#39;wesley&amp;#39;, &amp;#39;otheruser&amp;#39;] def register(): &amp;#34;&amp;#34;&amp;#34;注册用户&amp;#34;&amp;#34;&amp;#34; pass 1. 被执行文件run运行，创建名称空间 2.</description>
    </item>
    
    <item>
      <title>异常与生成器</title>
      <link>https://jinkes-li.github.io/python/%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Mon, 17 Oct 2022 18:23:39 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>异常处理和生成器对象 异常语法结构
异常处理实战
生成器对象
生成器实现range方法
生成器表达式
生成器笔试题
异常简介 异常的分类：
语法错误 逻辑错误 异常结构 定位信息 错误类型 错误信息 异常常见错误类型 1. SyntexError 2. NameError 3. IndexError 4. KeyError 5. IndetationError 异常语法结构 try: 待监测的代码 except 错误类型 正对上述错误类型指定的方案 针对不同的错误类型指定不同的方案 try: 待监测的代码 except 错误类型1 as e: # e 就是报的错误类型 错误方案1 except 错误类型2 as e: 错误方案2 except 错误类型3 as e: 错误方案3 万能异常Exception/BaseException # 万能异常 try: 待监测代码 except Exception as e: 常见报错都都会执行此方案 # 结合else使用 try: 待监测代码 except Exception as e: 错误执行方案 else: # 在上面的代码正常执行没有执行异常方案时执行else print(&amp;#39;哈哈哈，上面没有异常&amp;#39;) # 结合finally try: 待监测代码 except Exception as e: 异常解决方案 else: print(&amp;#39;上面正常执行没有错误我就执行&amp;#39;) finally: print(&amp;#39;上面的先上，无聊他们如何我都执行&amp;#39;) 断言 断言：预测上面出现的错误类型，并确定错误异常类型</description>
    </item>
    
    <item>
      <title>第三周总结</title>
      <link>https://jinkes-li.github.io/python/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 16 Oct 2022 21:31:48 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/</guid>
      <description>第三周总结 文件操作
函数
装饰器
基础算法及表达式
可迭代对象
文件操作
使用python炒作文本文件
创建或打开文件 python中的两种文件操作方式 1. open() # 直接使用open打开文件需要使用close方法关闭文件不推荐使用，仅仅演示 file1 = open(r&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) print(file1.read()) file1.close() 2. with open() # with会自动帮助我们关闭文件，推荐使用 with open(r&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) as f print(f.read()) - 注意在写路径时最好带上r参数，防止win系统下的文件路径被解析为其他含义 编辑文件 文件的读写模式
r - read 只读模式：只能读不能写 w - write 只写模式：只能写不能读，如果不对光标进行操作，w操作会将原文件全部覆盖 a - append 只追加模式，只能在文件的末行追加 r r (读模式，只读不写) # 如果文件不存在直接报错 with open(r&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, &amp;#39;encoding&amp;#39;=&amp;#39;utf8&amp;#39;) as f: print(f.read()) -w
w (只写不读) # 文件不存在则会新建 whth open(r&amp;#39;a.txt&amp;#39;, &amp;#39;w&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) as f: f.</description>
    </item>
    
    <item>
      <title>内置函数及for循环原理</title>
      <link>https://jinkes-li.github.io/python/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%8F%8Afor%E5%BE%AA%E7%8E%AF%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 14 Oct 2022 21:36:14 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%8F%8Afor%E5%BE%AA%E7%8E%AF%E5%8E%9F%E7%90%86/</guid>
      <description>python中常见内置函数 python常见内置函数 可迭代对象 迭代器对象 for 循环的本质 python中的内置函数 python中的内置函数非常的多，这里主要介绍常用的一部分
序号 内置函数名 功能 1 abs() 求绝对值 2 all() ， any() 判断容器类型中所有的数据值对应的布尔值是否为Ture 3 bin()，oct(), hex, 进制转换 4 int() 进制转换，其他进制转十进制 5 bytes() 类型转换 6 Callable() call在IT专业名词中翻译成调用 7 chr(),ord() 依据ASCII码表实现字符与字符的转换 8 dir() 获取对象内部可以通过句点符获取的数据 9 divmod() 获取除法之后的整数和与数 10 enumerate() 枚举 11 eval(),exec() 能够识别字符串中python代码并执行 12 hash() 对数据进行hash加密，返回一串哈希值 13 help() 查看帮助信息 14 Isinstance(123,int) True 15 isinstance(123, str) False 16 pow() 幂指数 17 round() 四舍五入 可迭代对象 迭代就是更新换代，每次迭代都需要基于上一次的结果 比如说我们手机上的软件更新，其实这就是迭代的过程 # 代码实现 1.</description>
    </item>
    
    <item>
      <title>常见算法及表达式</title>
      <link>https://jinkes-li.github.io/python/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%8F%8A%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Thu, 13 Oct 2022 21:09:37 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%8F%8A%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>常见算法及表达式 算法之二分法 三元表达式 各种生成式 匿名函数 重要的内置函数 常见的内置函数 算法简介之二分法 算法简单理解就是解决某些特定场景的特定方法 常见的算法有，二分法，冒泡，排序，红黑树，B+Tree 算法的应用场景：
淘宝搜索产品后会一直推荐同产品给用户，这是淘宝的推荐算法 抖音，用户在使用抖音时，算法会将每个视频分类，具有相同喜欢视频类型的人群分类，从而实现对视频和人群进行不同的流量推送 二分法 二分法使用，待查找的数据集必须有序 二分法的缺陷，如果结果数据再初始位置，或者末尾位置，效率很低 基础原理： 对需要处理的数据进行中间值一分为二，对比需要查找的结果值，与前后两位值对比，如果结果值闭前者小，则对前面的数据再次进行二分处理依次类推，若结果值比前者大，则用二分的方式对后续的数据进行处理。
python实现二分法 # 需要在以下数据中找到987 l1 = [12, 21, 32, 43, 56, 76, 87, 98, 123, 321, 453, 565, 678, 754, 812, 987, 1001, 1232] def look(l1, res_num): median = len(l1) // 2 # 判断，列表中的索引的值是否大于传入的值 if res_num &amp;gt; l1[median]: # 如果大于，将原列表中的后面的值取出赋值为new_list new_list = l1[median:] # 返回函数重新调用 return look(new_list, res_num) elif res_num &amp;lt; l1[median]: new_list = l1[:median] return look(new_list, res_num) else: print(&amp;#39;找到了&amp;#39;) look(l1, 21) 三元表达式 主要作用为简化代码</description>
    </item>
    
    <item>
      <title>Pythons新手村Boss装饰器</title>
      <link>https://jinkes-li.github.io/python/pythons%E6%96%B0%E6%89%8B%E6%9D%91boss%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Tue, 11 Oct 2022 22:49:12 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/pythons%E6%96%B0%E6%89%8B%E6%9D%91boss%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <description>python新手村Boss装饰器 装饰器简介
无产装饰器
有参装饰器
装饰器模版
装饰器语法糖及修复技术
多层装饰器
装饰器简介
概念： 在不改变被装饰器源代码和调用方式的情况下给被装饰的对象添加新的功能 装饰器的本质： 装饰器并不是一个新的技术，而是由函数参数，名称空间，函数名多种用法，闭包函数所组成到一起的结果 口诀： 对修改封闭，对扩展开放 储备知识 这里需要先需要提前使用一个time包来实现一下时间戳功能，代码如下
时间相关操作(time) import time # time 获取时间戳 print(time.time()) # 时间戳(距离1970-01-01 00:00:00所经历的秒数) time.sleep(3) # 程序暂停3秒再运行 print(&amp;#39;这里是代码体&amp;#39;) print(time.time()) # 代码运行结束的时间戳 1665485696.789707 这里是代码体 1665485699.794832 2. 小程序，获取当前代码运行的时长 import time count = 0 start_time = time.time() while count &amp;lt; 10000000: print(&amp;#39;运行中...&amp;#39;) count += 1 end_time = time.time() print(f&amp;#39;当前程序运行需要的时长为{end_time - start_time}&amp;#39;) 当前程序运行需要的时长为16.997233867645264 # 这里是time的用法 装饰器的推导流程（重要） *1*. 第一部分 import time def index(): time.</description>
    </item>
    
    <item>
      <title>Python函数(下)</title>
      <link>https://jinkes-li.github.io/python/python%E5%87%BD%E6%95%B0%E4%B8%8B/</link>
      <pubDate>Mon, 10 Oct 2022 19:49:24 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E5%87%BD%E6%95%B0%E4%B8%8B/</guid>
      <description>python函数（下） 本文将链接上一章的python函数的参数继续讲下去
函数的参数
名称空间与作用域
global与nonlocal
函数名的多种用法
函数的参数
函数参数的概念
形式参数 函数定义阶段括号内填写的参数 实际参数 函数调用阶段括号内填写的参数 1. 位置参数 位置形参 在定义函数时，在括号内从左到右依次填写的变量名 # 如何子代码只有一行或者很简短可以直接在冒号后面编写不用换行 def function(a, b, c):pass pass 位置实参 在函数调用时，在括号内依次从左往右填写的参数值 function(1, 2, 3) 位置参数的注意事项 # 定义一个函数并且写上ab两个位置形参 def func1(a, b): pass(a, b) 1. func1(1, 2) # 按照位置从左往右依次传值 2. func1(1) # 少了一个传入的值，报错 3. func1(1, 2, 3) # 多了一个值，还是报错 4. func1(b=1, a=2) # 关键字参数，将1传给b，2传给a 5. func1(b=1, 2) # 关键字参数一定要跟在位置参数后面否则会报错 6 func1(2, b=1) # 这里关键字参数在位置参数后面就可以正常传入 7. func1(1, a=2, b=3) # 同一个形参在调用的时候不能传入多个值 name = &amp;#39;wesley&amp;#39; pwd = 123 8.</description>
    </item>
    
    <item>
      <title>Python函数(上)</title>
      <link>https://jinkes-li.github.io/python/python%E5%87%BD%E6%95%B0%E4%B8%8A/</link>
      <pubDate>Sun, 09 Oct 2022 16:19:35 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E5%87%BD%E6%95%B0%E4%B8%8A/</guid>
      <description>函数 引言：
函数就相当于提前定义的工具，在使用时可以直接调用工具使用 函数比较类似于循环的代码，都是重复调用一个功能性问题，主要区别如下
循环是相同的代码在相同的位置反复执行 函数是相同的代码在不同的位置反复调用 函数的语法结构 函数的定义与调用 函数的分类 函数的返回值 函数的参数 函数的语法结构 def def_name(): # 关键字，函数名，是否带参数 &amp;#34;&amp;#34;&amp;#34; 打印123，这里主要是对函数功能的描述 &amp;#34;&amp;#34;&amp;#34; print(123) #函数代码体 return 456 # 返回值 1. def 关键字 def关键字就是用来定义函数的 2. 函数名 函数名就相当于我们使用的变量名需要见名知意 3. () 参数 函数参数主要是用于接受外部数据传入内部给括号里面的参数使用 1. 形参： 在函数定义阶段，函数的括号中写入的参数叫做形参 2. 实参： 在函数调用阶段，被调用的函数中写入的数据被称为实参 4. 函数注释 函数注释是用于描述这个函数的功能 5. 函数代码体 函数代码体是实现一个功能的具体代码 6. return 返回值 调用函数后返回给用户的返回值，可有可无需要看具体使用 函数的定义与调用 # 函数的定义 def print_def(): &amp;#34;&amp;#34;&amp;#34; 这是一个打印123的功能 &amp;#34;&amp;#34;&amp;#34; print(123) # 函数的调用，函数的调用直接使用函数名加括号调用 print_def() &amp;#34;&amp;#34;&amp;#34; 注意： 1. 函数在定义阶段python只会检查语法，并不会执行 2. 函数需要先定义再调用 &amp;#34;&amp;#34;&amp;#34; 函数的分类 # 函数的三分类 1.</description>
    </item>
    
    <item>
      <title>文件操作方法</title>
      <link>https://jinkes-li.github.io/python/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 09 Oct 2022 01:29:28 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</guid>
      <description>引言:
平时操作文件都是在计算机中直接新建或编辑文件，这种就类似操作系统直接给我们创建了一个快捷方式，可以直接对硬盘进行操作，今天这里介绍如何使用python代码来对一个文件进行操作
文件操作简介 定义： 文件就是操作系统提供的直接操作硬盘的快捷方式 文件的操作流程 创建或打开文件 编辑文件 保存文件 关闭文件 # Python代码操作文件的语法 # 方式一：（不推荐使用，需要写close来关闭打开的文件） l1 = open(&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) print(l1.read()) l1.close() # 方式二： （推荐使用，with会自动帮助我们关闭文件） with open(&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) as f: print(f.read()) &amp;#34;&amp;#34;&amp;#34; 注意： 如果对文件进行操作时使用到了反斜杠，如 &amp;#39;C：/admin/a.txt&amp;#39;，这里则需要使用&amp;#39;r&amp;#39;将反斜杠的特殊含义转义掉，仅仅作文一个源字符使用 &amp;#34;&amp;#34;&amp;#34; 文件的读写模式 r &amp;ndash; read 只读模式： 只能读不能写 w &amp;ndash; write 只写模式： 只能写不能读，需要注意如果不对光标进行操作。w操作会将原本文件中存在的数据全部覆盖 a &amp;ndash; append 只追加面膜是 ：只能在文件最后追加 read r 模式 read r 模式 # 如果文件不存在会直接报错 with open(r&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) as f: print(f.read()) write w 模式</description>
    </item>
    
    <item>
      <title>第二周总结</title>
      <link>https://jinkes-li.github.io/python/%E7%AC%AC%E4%BA%8C%E5%91%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 07 Oct 2022 20:14:40 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%AC%AC%E4%BA%8C%E5%91%A8%E6%80%BB%E7%BB%93/</guid>
      <description>引言. 本文对Python知识的的基础阶段整理归纳
基本数据类型 用户交互与格式化输出运算符 赋值方式 垃圾回收以及流程控制 For循环和数据类型方法 数据类型内置方法理论 数据类型和字符编码 基本数据类型 Python中不同的数据需要有不同的数据类型来表示，用于更好的读取和修改
1.1 布尔值（bool） 布尔值只有两个状态，True和Fales ，当数据为真时结果为True，数据为假时结果为Fales
注意： Python中有一些数据默认值就为False，比如 0 ，None， &amp;lsquo;&amp;rsquo;, {}, [], 这些数据类型如果 没有数据默认为False，除了这些其他基本都为True 一般我们也可以使用变量来定义布尔值，比较建议的名称为is开头。
1.2 字符串 （str） 字符串就是使用单引号或者双引号包含起来的字符就是字符串，字符串中都是文本数据，无法用于计算
1.3 整型 （int） 整型： 整型就是整数，如 0， 1 ，2 等，可用用于运算和条件判断
1.4 浮点型 （foalt） 浮点型： 浮点型就是小数，比如 3.14等
1.5 列表 （list） 列表: 列表是使用中括号包含起来的数据，并以逗号分隔，可以存放多种数据类型，列表是有序的，可以通过索引来取值
1.6 字典 （dict） 字典： 使用花括号括起来的数据，里面同样可以存放多种类型的数据，同时需要注意的是字典是以键值对来存放数据的，并且字典无序，只能通过键来取值
1.7 元组 （tople） 元组： 使用小括号包含起来的数据，数据可以是多种数据类型，元组索引对应的数据值不可以修改，但是如果这个数据值为列表或者字典等，其中列表或者字典的值是可以修改的，元组这里同样有索引的概念
1.8 集合 （set） 集合： 集合与字典一样同样使用花括号来定义，与之不同的是，字典存放数据需要以键值对的方式存放，集合中的数据使用逗号分隔，集合内存放的数据只能是不可变类型，并且在使用集合时，一般只应用于去重和关系运算
用户交互与格式化输出运算符 2.1 用户交互 用户交互就是让与计算机的交流通讯，让计算机理解我们需要做什么
# 关键字 1.</description>
    </item>
    
    <item>
      <title>数据类型和字符编码</title>
      <link>https://jinkes-li.github.io/python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</link>
      <pubDate>Fri, 30 Sep 2022 17:35:33 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</guid>
      <description>python 数据类型操作 今日内容 字典相关操作 元组相关操作 集合相关操作 字符编码(理论) 字典操作 1. 类型转换，字典的转换一般不使用关键字，而是自己手动转 dict() 2. 字典需要掌握的操作 # 原始数据 user_dict = {&amp;#39;username&amp;#39;: &amp;#39;jason&amp;#39;, &amp;#39;password&amp;#39;: 123, &amp;#39;hobby&amp;#39;: [&amp;#39;read&amp;#39;, &amp;#39;music&amp;#39;, &amp;#39;run&amp;#39;] } 2.1 按key取值（不推荐使用，如果这个key不存在会报错） print(user_dict[&amp;#39;username&amp;#39;]) # username jason jason 2.2 使用内置方法get取值（推荐使用） 2.2.1 使用get获取已经存在的key值 print(user_dict.get(&amp;#39;username&amp;#39;)) jason 2.2.2 使用get获取不存在的值 print(user_dict.get(&amp;#39;age&amp;#39;)) None 2.2.3 使用get获取不存在的值，并通过第二个参数设定默认返回值 print(user_dict.get(&amp;#39;age&amp;#39;, &amp;#39;False&amp;#39;)) False 3.1 字典修改数据值，和列表的重新赋值类似 print(id(user_dict)) user_dict[&amp;#39;username&amp;#39;] = &amp;#39;wesley&amp;#39; print(id(user_dict), user_dict) 4337316352 # 从内存ID上看，字典是一个可变参数 4337316352 {&amp;#39;username&amp;#39;: &amp;#39;wesley&amp;#39;, &amp;#39;password&amp;#39;: 123, &amp;#39;hobby&amp;#39;: [&amp;#39;read&amp;#39;, &amp;#39;music&amp;#39;, &amp;#39;run&amp;#39;]} 3.2 如果修改的key并不存在，则会新建 user_dict[&amp;#39;age&amp;#39;] = 18 print(user_dict) {&amp;#39;username&amp;#39;: &amp;#39;jason&amp;#39;, &amp;#39;password&amp;#39;: 123, &amp;#39;hobby&amp;#39;: [&amp;#39;read&amp;#39;, &amp;#39;music&amp;#39;, &amp;#39;run&amp;#39;], &amp;#39;age&amp;#39;: 18} 3.</description>
    </item>
    
    <item>
      <title>Python数据类型内置方法理论</title>
      <link>https://jinkes-li.github.io/python/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E7%90%86%E8%AE%BA/</link>
      <pubDate>Thu, 29 Sep 2022 20:51:22 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E7%90%86%E8%AE%BA/</guid>
      <description>Python数据类型内置方法和理论 引言： Python自身对数字的敏感度比较低（精确度低） 如果是用在数据分析和金融量化方向，可以使用第三方包模块numpy
本文内容
数据类型内置方法理论 进制数转换 整型相关操作 浮点型相关操作 字符串相关操作 列表相关操作 数据类型内置方法理论 前面文章所提到的每一种数据类型本身都包含有一系列的操作方法，内置方法，是自身带的功能 Python中的数据类型调用内置方法的统一句式为: &amp;ldquo;.&amp;quot;:句点符 &amp;lsquo;wesley&amp;rsquo;.字符串的内置方法 str. 字符串内置方法 数据类型的内置方法比较的多，其中有一些经常使用的以及部分不经常使用的，需要在工作中使用，并且熟悉 进制数转化 开头前两位代表的是转换后表示的进制数 0b代表的是二进制 0o代表的是八进制 0x代表的是十六进制 # 代码实例 # 十进制转换其他进制 # 十转二 print(bin(100)) 0b1100100 # 十转八 print(oct(100)) 0o144 # 十转十六 print(hex(100))i 0x64 # 如果需要八进制转换成其他进制直接反打就可以了 # 二转十 print(int(0b1100100), 2) 100 2 # 八转十 print(int(0o144), 8) 100 8 # 十六转十 print(int(0x64), 16) 100 16 整型的相关操作 类型转换（可以将其他类型转换为整型） int(其他数据类型)，原始数据为浮点型可以直接转换，如果是字符串必须满足内部是纯数字才可以 # 代码实例 # str转int，注意字符串是不可变类型，这里需要重新赋值 a = &amp;#39;1111&amp;#39; a = int(a) print(type(a)) &amp;lt;class &amp;#39;int&amp;#39;&amp;gt; # float转int, 注意在float转int的时候int方法会将小数点后面的数据全部切除，而不是四舍五入，并且如果字符串中存在多个小数点，int无法识别并转换 a = 11.</description>
    </item>
    
    <item>
      <title>For循环和数据类型方法</title>
      <link>https://jinkes-li.github.io/python/for%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 28 Sep 2022 18:58:47 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/for%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95/</guid>
      <description>while 循环补充说明 流程控制之for循环 while循环之死循环
真正的死循环一旦执行，cpu功耗会急剧上升 # 死循环 while True: i = 99 ** 99 print(i) while嵌套及全局标志位
注意： 一个break只能结束它所在的那一乘循环 注意：有几个while的嵌套，如果想一次性结束就应该写几个break 注意：如果不想反复的写break，可以使用全局标志位，就是在循环开始之初，定义一个变量为True，如果需要跳出while循环把这个变量赋值为False即可 is_flag = True # 这里定义一个全局标志位 while is_flag: # while的条件是如果is_flag = True就运行False就不运行 username = input(&amp;#39;username&amp;gt;&amp;gt;&amp;gt;:&amp;#39;) password = input(&amp;#39;password&amp;gt;&amp;gt;&amp;gt;:&amp;#39;) if username == &amp;#39;jason&amp;#39; and password == &amp;#39;123&amp;#39;: while is_flag: # 判断is_flag cmd = input(&amp;#39;请输入您的指令&amp;gt;&amp;gt;&amp;gt;:&amp;#39;) if cmd == &amp;#39;q&amp;#39;: # 这里判断我们输入的命令是什么，如果为q 直接将is_flag 从新赋值为False is_flag = False print(&amp;#39;正在执行您的指令:%s&amp;#39; % cmd) else: print(&amp;#39;用户名或密码错误&amp;#39;) 流程控制之for循环</description>
    </item>
    
    <item>
      <title>垃圾回收以及流程控制</title>
      <link>https://jinkes-li.github.io/python/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Tue, 27 Sep 2022 22:10:23 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>Python垃圾回收以及流程控制 垃圾回收 流程控制理论 流程控制之分支结构 流程控制之循环结构 垃圾回收机制 在不分语言中，内存空间的申请和释放都需要程序员自己写代码才可以完成，但是Python这里不需要，有自身的垃圾回收机制自动管理
引用计数 引用计数，每一个变量值都有对应的计数值，每增加一个变量的引用，计数值则会加一，每减少一个引用计数值则会减一， 当引用值等于0时，就会触发垃圾回收机制 引用计数-原理图 标记清除 标记清除主要针对循环引用的问题 # 代码实例 l1 = [11, 22] # 引用计数1 l2 = [33, 44] # 引用计数1 # 循环引用 l1.append(l2) # l1 = [11, 22, [33, 44]] # 引用值为2 l2.append(l1) # l2 = [33, 44, [11, 22]] # 引用值为2 del l1 # 断开变量名l1与列表的绑定关系，引用值变更为1 del l2 # 断开变量名l2与列表的绑定关系，引用值变更为1 # 当内存占用到达临界值的时候，程序会自动停止，然后扫描程序中所有的数据，并给只产生循环引用的数据打上标记，之后一次性清除 标记清除-原理图
分代回收 用的越久的对象，被回收的可能性越小 请直接看原理图 分代原理图 流程控制理论 在编程的世界中下列三者会出现混合使用
Python代码中建议使用空格表示代码的从属关系，建议使用4个空格
从属关系：缩进的代码（子代码）是否执行取决于上层代码，并不是所有的代码都有子代码
如果多行子代码同属于一个父代码，那么这些子代码需要保持相同的缩进
当一行代码需要编写子代码时，必须以冒号结尾</description>
    </item>
    
    <item>
      <title>用户交互与格式化输出运算符</title>
      <link>https://jinkes-li.github.io/python/%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Mon, 26 Sep 2022 21:25:44 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>Python 本篇文章接着上一个文章继续介绍Python
Python基本的数据类型
与用户交互
格式化输出
基本运算符
多种赋值方式
逻辑运算符
成员运算符
身份运算符
1. Python基本数据类型 布尔值 （bool） 定义：用来判断事务的对错，是否可行，应用与流程控制中 布尔值只有两种状态 True 真的，可行的，对的 False 假的，不可行的，错的 Python中所有的数据都是自带布尔值的，自带布尔值的数据有下列两种 布尔值默认为False的数据有：0 None &amp;rsquo;&amp;rsquo; [] {} 布尔值默认为True的数据有：一般除了上面的都是True 布尔值的变量名一般推荐使用is开头 # 代码实例 is_boo1f = False is_boolt = True 小知识： 在企业中一般说的数据库数据伪删除使用的就是类似这种判断逻辑。
# 代码实例 # 一般企业提供的账号注销功能就是使用布尔值判断逻辑 # 比如下列表格中 is_delete 字段0代表着账户存在，字段1代表账户被删除，其实只是修改李程序取值的逻辑，并未删除实际数据 id	username	password phone is_delete 1 jason	123	110 1 2	kevin	321	120	0 # 一般这种方式大多应用于数据库中 元组（tuple） 定义： 小括号括起来 内部存放多个数据值 数据值与数据值之间逗号隔 开 数据值可以是任何数据类型 被称为不可变列表，是因为元组内存放的地址不能修改 # 代码实例 # 列表与元组的对比 # 列表使用[]进行定义 l1 = [11, 22, 33] # 定义一个列表并赋值给l1 l1[0] = 123 # 使用重复赋值将123替换到l1列表的0号索引 print(l1[0]) # 这里发现最终打印的123，而不是11，所以列表值是可变的 123 ​ 列表修改数据图表参考如下</description>
    </item>
    
    <item>
      <title>周末总结</title>
      <link>https://jinkes-li.github.io/tags/%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 25 Sep 2022 17:05:19 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/tags/%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93/</guid>
      <description>周末总结 硬件总结 计算机基础知识 安装Pycharm 遇见Python Markdown文档编写 计算机基础硬件 CPU
控制器
调度计算机硬件之间的工作，相当于人类的大脑
运算器
在计算机中负责数学运算以及逻辑运算，同样相当于人类的大脑
存储
内存
基于电工作，内存将磁盘中的数据加载到自身于CPU交互，数据仅次于 CPU，但是断电未持久化的数据将会丢失
磁盘 将内存需要存储的数据，在磁盘中永久的存储下去
输入设备 计算机中的键盘鼠标，扫描仪等，都属于输入设备，是将外界信息录入计算机的一种设备
输出设备 将计算机中的数据输出的设备被称为输出设备，例如显示器，投影机等
计算机基础知识 路径 路径就是计算机中用来定位资源的路径，C:\user\admin\a.txt 这就是一个文件的路径
相对路径 相对路径就是具有参照物的路径，可以不用从根目录开始寻找 绝对路径 绝对路径就是需要从根路径开始寻找 环境变量 当系统需要寻找一个文件时会先寻找当前路径，如果当前路径寻找不到就	会寻找系统中的环境变量，环境变量相当于告诉计算机，如果这个文件找不	到就去环境变量的这个文件下寻找
进制
二进制 0 1 10 11 ，0和1 就是二进制用来表示高低电平，可以直接被计算机识别，二进制逢二进一 八进制 0 1 2 3 4 5 6 7 ，0到7就是八进制，逢八进一 十进制 0 1 2 3 4 5 6 7 8 9 ，0-9时十进制，逢十进一 十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f ，0 -f是十六进制，逢十六进一 单位换算</description>
    </item>
    
    <item>
      <title>遇见Python</title>
      <link>https://jinkes-li.github.io/python/%E9%81%87%E8%A7%81python/</link>
      <pubDate>Fri, 23 Sep 2022 19:12:39 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E9%81%87%E8%A7%81python/</guid>
      <description>遇见Python 引言：
接下来本文开始将在学习和工作中记录Python的使用
本文内容
Python语法-注释
关键字
变量与常量
​	变量与常量的基本使用
​	变量规范和命名规则
数据类型
​	整型（int）
​	浮点型（float）
​	字符串（str）
​	列表（list）
​	字典（dict）
PEP8规范
Python语法-注释
注释的意思就是被注释的代码不执行，参见下列示例
注释符号 # &amp;#39;&amp;#39;&amp;#39; &amp;#39;&amp;#39;&amp;#39; &amp;#34;&amp;#34;&amp;#34; &amp;#34;&amp;#34;&amp;#34; # 打印123 print(123) # 这一行是代码，代码后面也可以加注释 &amp;#39;&amp;#39;&amp;#39; 123 456 这是多行注释，被包含的内容都不执行 &amp;#39;&amp;#39;&amp;#39; &amp;#34;&amp;#34;&amp;#34; 666 这也是多行注释，被包含的内容都不执行 &amp;#34;&amp;#34;&amp;#34; 关键字 # 具有一定功能的特定单词，例如 print(&amp;#39;打印&amp;#39;) print(&amp;#39;123&amp;#39;) 123 # 查看数据类型 type() name = &amp;#39;wesley&amp;#39; print(type(name)) &amp;lt;class &amp;#39;str&amp;#39;&amp;gt; # 通过输出结果可以看出数据类型为str 也就是字符串 变量与常量
变量就是会变化的量，常量就是不会变化的量或者说长时间不会改变的量
​	变量：比如说我们的年龄会随着每年增涨，今年18，明年19，年龄在不断发生变化，这就是变量
​	常量：比如我们的身份证号码就属于常量，无论什么时间身份证号都不会发生变化，这就是常量
变量的命名规则和特性</description>
    </item>
    
    <item>
      <title>JetBrains IDE 产品使用</title>
      <link>https://jinkes-li.github.io/python/jetbrains-ide-%E4%BA%A7%E5%93%81%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 23 Sep 2022 19:03:58 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/jetbrains-ide-%E4%BA%A7%E5%93%81%E4%BD%BF%E7%94%A8/</guid>
      <description>JetBrains IDE 产品使用（Pycharm ） ​	引言：本文使用的系统为 MacOS 12.5 M1
接下来我们需要写Python相关的代码这里强烈推荐使用Pycharm，由于免费的社区版某些功能没有，这里我们使用Pycharm专业版（仅测试使用）
JetBrains官网 下载安装你需要的 IDE这里下载PyCharm，下载完成后直接双击安装 下载 Jetbrains.zip，下载后解压，得到 fineagent.jar，将该文件复制到 /Users/你的用户名/ 文件夹下
#使用cd进入到Users下面的你电脑的用户名下 wesley@wesleydeMacBook-Pro ⮀ ~ ⮀ cd /Users/wesley/ #将下载的fineagent.zip 复制到当前目录并解压，注意：我这里是吧fineagent.zip下载到了Downloads这个目录下，请以你的下载目录为准 wesley@wesleydeMacBook-Pro ⮀ ~ ⮀ cp /Users/wesley/Downloads/fineagent.zip ./ &amp;amp;&amp;amp; unzip fineagent.zip &amp;amp;&amp;amp; ll -rw-r--r--@ 1 wesley staff 35K Aug 15 10:21 fineagent.jar wesley@wesleydeMacBook-Pro ⮀ ~ ⮀ 打开访达，点击左侧的 应用程序 找到 PyCharm，在 PyCharm 图标上右键，点击 显示包内容
进入 Contents 目录，再进入 bin 目录，使用文本编辑器打开 pycharm.vmoptions文件
5.在最后面添加 -javaagent:/Users/你的用户名/fineagent.jar，记得修改一下你的用户名。
运行 PyCharm, 选择 Activate PyCharm，再点击 Activation Code</description>
    </item>
    
    <item>
      <title>基础和py解释器</title>
      <link>https://jinkes-li.github.io/python/%E5%9F%BA%E7%A1%80%E5%92%8Cpy%E8%A7%A3%E9%87%8A%E5%99%A8/</link>
      <pubDate>Thu, 22 Sep 2022 20:12:55 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%9F%BA%E7%A1%80%E5%92%8Cpy%E8%A7%A3%E9%87%8A%E5%99%A8/</guid>
      <description>引言：
​	继续接着上一个文章干活哈
本文内容： 计算机三大核心硬件部分详解 操作系统 编程与编程语言 编程语言的发展史 编程语言的分类 Python解释器 Python解释器多版本共存 计算机主要三核心硬件详解 CPU ​ 中央处理器（CPU），是电子计算机的主要设备之一，电脑中的核心配件。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU是计算机中负责读取指令，对指令译码并执行指令的核心部件。中央处理器主要包括两个部分，即控制器、运算器，其中还包括高速缓冲存储器及实现它们之间联系的数据、控制的总线。电子计算机三大核心部件就是CPU、内部存储器、输入/输出设备。中央处理器的功效主要为处理指令、执行操作、控制时间、处理数据。
存储器 ​	按信息的可保存性分类
​	非永久记忆的存储器：断电后信息即消失的存储器。
​	永久记忆性存储器：断电后仍能保存信息的存储器。
​	按在计算机系统中的作用分类
​	主存储器（内存）：用于存放活动的程序和数据，其速度高、容量较小、每位价位高。
​	辅助存储器（外存储器）：主要用于存放当前不活跃的程序和数据，其速度慢、容量大、每位价位低。
​	缓冲存储器：主要在两个不同工作速度的部件起缓冲作用。
输入设备 ​	输入设备是向计算机输入数据和信息的设备，是计算机与用户或其他设备通信的桥梁，是用户和计算机系统之间进行信息交换的主要装置之一。输入设备的任务是把数据、指令及某些标志信息等输送到计算机中去。键盘、鼠标、摄像头、扫描仪、光笔、手写输入板、游戏杆、语音输入装置等都属于输入设备（Input Device ），是人或外部与计算机进行交互的一种装置，用于把原始数据和处理这些数据的程序输入到计算机中。
输出设备 ​	输出设备（Output Device）是把计算或处理的结果或中间结果以人能识别的各种形式,如数字、符号、字母等表示出来,因此输入输出设备起了人与机器之间进行联系的作用。常见的有显示器、打印机、绘图仪、影像输出系统、语音输出系统、磁记录设备等。
操作系统 ​	计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出（文字、图片、音频、视频等）。计算机由硬件和软件组成：
硬件是计算机赖以工作的实体，包括显示器、键盘、鼠标、硬盘、CPU、主板等； 软件会按照用户的要求协调整台计算机的工作，比如 Windows、Linux、Mac OS、Android 等操作系统，以及 Office、QQ、迅雷、微信等应用程序。 操作系统是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁（或者说接口、中间人、中介等）。
编程与编程语言 编程 ​	指的是给计算机编定程序，使计算机能够完成我们需要的指令，得到相应的结果。这种人与计算机之间的交流过程就叫做编程。编程是一种逻辑的思维运算。
编程语言
编程语言（programming language）可以简单的理解为一种计算机和人都能识别的语言。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。
编程语言的3大类 机器语言： 定义 优点 缺点 计算机直接识别的二进制代码 直接执行，速度快，资源占用少 可读性、可移植性差，编程繁杂 机器语言是直接可以被计算机认识的语言，无需经过翻译，每一操作码在计算机内部都有相应的电	路来完成它。
汇编语言： 定义 优点 缺点 汇编无法直接被机器直接识别需要汇编 编译阅读（相对机器语言），速度块，资源占用少 可读性、可移植性差，可维护性差 汇编语言具有更高的机器相关性，更加便于记忆和书写，但又同时保留了机器语言高速度和高效率的特点。汇编语言仍是面向机器的语言，很难从其代码上理解程序设计意图，设计出来的程序不易被移植，故不像其他大多数的高级计算机语言一样被广泛应用</description>
    </item>
    
    <item>
      <title>关于博主</title>
      <link>https://jinkes-li.github.io/about/%E5%85%B3%E4%BA%8E%E5%8D%9A%E4%B8%BB/</link>
      <pubDate>Wed, 21 Sep 2022 19:37:41 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/about/%E5%85%B3%E4%BA%8E%E5%8D%9A%E4%B8%BB/</guid>
      <description>关于博主： ​	博主不是一个技术大牛，只是一个拥抱开源技术的爱好者，目前正在从事运维开发工作，希望在闲暇时间可以将好的项目和技术知识对大家进行分享，除此之外也是一名自我救赎者。
​	&amp;ndash;来自一名互联网的小透明</description>
    </item>
    
    <item>
      <title>计算机基础及Markdown基础</title>
      <link>https://jinkes-li.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%8F%8Amarkdown%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Wed, 21 Sep 2022 16:17:14 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%8F%8Amarkdown%E5%9F%BA%E7%A1%80/</guid>
      <description>引言： 干活干活～
整理一下Markdown一些常见的用法 再来一点计算机基础，ok ，现在开始。
计算机基础 想了想还是吧计算机基础写在前面吧，后续更新python慢慢深入哈～
​	世界上第一台通用计算机“ENIAC”于1946年2月14日在美国宾夕法尼亚大学诞生。发明人是美国人莫克利（JohnW.Mauchly）和艾克特（J.PresperEckert）。
​	对于我们来说计算机到底是什么，为什么说计算机是互联网世界的基石呢，首先我们需要理解计算机创造之初的设计理念。
由于在人类社会中存在大量重复性工作，以及随着文明的进步衍生出许许多多需要海量计算的数据，那这些数据依靠人脑需要计算几十上百年甚至是上万年才能被计算出来，由此计算机参照人类本身的行为逻辑应运而出。
我们需要先了解计算机的核心硬件：
控制器-CPU （相当于人类的大脑，用于协调身体的各个器官合作工作） 运算器-CPU （这个也相当于人类的大脑思考如何解决这个问题并给出解决方案） 存储器-RAM-DISK （相当于记忆，区分为短暂记忆(RAM)和永久记忆(DISK)） 输入设备-键盘 （比如耳朵，眼睛，嗅觉等，只用于接收信息由大脑处理） 输出设备-显示屏（比如嘴巴，教师向学生授课就想当于输出，学生们就相当于被灌输知识，这里也就是输入） 说完计算机的基本组成，我们再浅谈一下计算机是如何工作的。
​	人不吃饭不行，计算机主要依靠电信号，离开了电当然也是不可以的，是依靠着高低电频来组成不同的信息，这个电频不是高就是低，感觉能组成的信息太少了怎么办，这就不得不说一下进制的概念了
进制 二进制	0 1（逢二进一 0 1 10） 八进制 0 1 2 3 4 5 6 7 （逢八进一） 十进制 0 1 2 3 4 5 6 7 8 9 （逢十进一） 十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f （逢十六进一） ​	其中十进制和十六进制一半用于各种电子设备的IP地址，二进制一半是二进制文件，至于八进制 en&amp;hellip;好像没怎么遇到过，这里顺便加一下存储的单位转换。然后说一下计算机如何通过路径找文件，对于人来说哈。</description>
    </item>
    
    <item>
      <title>Mac设置不休眠</title>
      <link>https://jinkes-li.github.io/posts/mac%E8%AE%BE%E7%BD%AE%E4%B8%8D%E4%BC%91%E7%9C%A0/</link>
      <pubDate>Fri, 19 Aug 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/mac%E8%AE%BE%E7%BD%AE%E4%B8%8D%E4%BC%91%E7%9C%A0/</guid>
      <description>Mac默认情况下合上盖子就会进入休眠状态，正在进行的任务也会停止。我们在终端执行两条命令来将Mac设置为合盖不休眠。
打开Terminal，执行如下两条语句：
sudo pmset -b sleep 0 sudo pmset -b disablesleep 1 若需要恢复原有合盖自动休眠的设置，则执行如下两条语句：
sudo pmset -b sleep 5 sudo pmset -b disablesleep 0 关于pmset命令更多的用法可以在终端执行man pmset来查看。</description>
    </item>
    
    <item>
      <title>aliyun Centos7 如何安装python3.7.4和pip3</title>
      <link>https://jinkes-li.github.io/posts/%E9%98%BF%E9%87%8C%E4%BA%91centos7%E5%AE%89%E8%A3%85python3.7.4%E5%92%8Cpip3/</link>
      <pubDate>Tue, 19 Jul 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E9%98%BF%E9%87%8C%E4%BA%91centos7%E5%AE%89%E8%A3%85python3.7.4%E5%92%8Cpip3/</guid>
      <description>aliyun Centos7 如何安装python3.7.4和pip3
亲测有效，针对 阿里云 centos 7 轻量服务器
python ==&amp;gt; 3.7.4
pip ==&amp;gt; 3
一，打开python官网，找到下载Python的tgz文件，有两种方式下载 （版本可能更新，进官网核实为准）
1，直接在windows系统下了完了，通过xtfp上传文件到/usr/local/下 python官网下载地址：https://www.python.org/downloads/release/python-374/
2、通过wget命令，至于命令后半段下载链接，直接右键点击Gzi&amp;hellip;&amp;hellip;复制链接即可
wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz 二，解压文件，添加一些安装依赖 在/usr/local/目录下解压 (习惯将这里当做文件下载，解压的地方，根据个人情况而定)
tar zxvf Python-3.7.4.tgz 安装依赖
yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel gcc libffi-devel gcc make automake autoconf libtool libffi-devel 且需要安装一个包，libffi-devel为3.7版本需要的一个新的包，否则安装的时候报错 ModuleNotFoundError: No module named &amp;lsquo;_ctypes&amp;rsquo;
yum install libffi-devel -y 进入解压目录
cd Python-3.7.4 进行初始配置 注意：在这之前先将安装目录创建好，否则&amp;hellip;&amp;hellip;.，这里我安装到 /usr/local/python3 目录下
mkdir /usr/local/python3 ./configure --prefix=/usr/local/python3　执行安装</description>
    </item>
    
    <item>
      <title>Kubernetes Coredns 服务发现</title>
      <link>https://jinkes-li.github.io/posts/kubernetes-coredns-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Tue, 19 Jul 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/kubernetes-coredns-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B5%8B%E8%AF%95/</guid>
      <description>测试 1111服务发现是指服务之间的通讯联通，对于Kubernetes来说服务发现具有3个痛点
服务的动态性强 服务更新发布频繁 服务支持自动伸缩 Kubernetes中的PODIP是不断变化的，这里如何以不变应万变呢，以下两组概念就可以解决这个问题
Kubernetes中抽象出来Service资源，通过标签选择器来关联一组POD Kubernetes中抽象出来了集群网络，通过相对固定的集群IP，使服务的接入点固定 那么如何自动关联Service资源的“名称”和“集群网络IP”，从而达到服务被集群自动发现的目的？
我们可以考虑一下传统的NDS模型： baidu.com —&amp;gt; 111.213.123.1
Kubernetes这里通过Coredns也去建立类似于传统DNS的模型，实现域名和IP（也就是固定接入点）的绑定
部署Coredns
在hdss7-200.host.com上，配置一个NGINX，用以提供kubernetes统一的访问资源清单入口
[root@hdss7-200 ~]# vim /etc/nginx/conf.d/k8s-yaml.od.com.conf server { listen 80; server_name k8s-yaml.od.com; location / { autoindex on; default_type text/plain; root /data/k8s-yaml; } } [root@hdss7-200 html]# cd /data [root@hdss7-200 data]# mkdir k8s-yaml [root@hdss7-200 data]# cd k8s-yaml/ [root@hdss7-200 k8s-yaml]# mkdir coredns [root@hdss7-200 k8s-yaml]# nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful [root@hdss7-200 k8s-yaml]# nginx -s reload [root@hdss7-200 k8s-yaml]# nginx配置中使用了新的域名，需要在内网DNS服务器上配置解析</description>
    </item>
    
    <item>
      <title>项目环境</title>
      <link>https://jinkes-li.github.io/posts/%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Wed, 26 May 2021 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/</guid>
      <description>BI 项目启动环境 此项目使用的是Centos7.9 内核版本5.19，升级历史操作如下 [可参考]
17 rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 18 rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 19 yum --disablerepo=&amp;#34;*&amp;#34; --enablerepo=&amp;#34;elrepo-kernel&amp;#34; list available 20 $ yum --enablerepo=elrepo-kernel install kernel-ml 21 yum --enablerepo=elrepo-kernel install kernel-ml 22 awk -F\&amp;#39; &amp;#39;$1==&amp;#34;menuentry &amp;#34; {print i++ &amp;#34; : &amp;#34; $2}&amp;#39; /etc/grub2.cfg 23 grub2-set-default 0 24 reboot 25 uname -a 26 history 基本环境安装 install git
[root@web ~]# yum install git -y install docker
安装教程
[root@web ~]# yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine [root@web ~]# yum install -y yum-utils [root@web ~]# yum-config-manager \ --add-repo \ https://download.</description>
    </item>
    
    <item>
      <title>服务状态</title>
      <link>https://jinkes-li.github.io/posts/%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</link>
      <pubDate>Tue, 21 Jan 2020 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</guid>
      <description>服务状体
常常听到的服务状态是什么意思？ 什么是无服务状态和什么是有服务状态
无状态服务
无状态服务不会在本地存储持久化数据.多个服务实例对于同一个用户请求的响应结果是完全一致的.这种多服务实例之间是没有依赖关系,比如web应用,在k8s控制器 中动态启停无状态服务的pod并不会对其它的pod产生影响.
有状态服务
有状态服务需要在本地存储持久化数据,典型的是分布式数据库的应用,分布式节点实例之间有依赖的拓扑关系.比如,主从关系. 如果K8S停止分布式集群中任 一实例pod,就可能会导致数据丢失或者集群的crash.
了解这个之后我们提出一个问题， Deployment部署的问题?
Deployment被设计用来管理无状态服务的pod,每个pod完全一致.什么意思呢?
无状态服务内的多个Pod创建的顺序是没有顺序的. 无状态服务内的多个Pod的名称是随机的.pod被重新启动调度后,它的名称与IP都会发生变化. 无状态服务内的多个Pod背后是共享存储的.
现在看一个新的问题？
对于数据库有状态的服务容器编排,Deployment解决方案就变得无能为力了. 比如,Redis是主从的架构,只能允许集群中出现一个主节点提供写,其它节点提供读能力.如果同时出现二个主节点后,必须会出现并发写的 操作,进一步导致集群写数据的不一致. 所以问题来了,针对Redis这种有状态的服务,它管理的多个Pod(代表master/slave角色)必须有自己独立的持久化存储组件. 有状态的服务Pod是用来运行有状态应用的,其在数据卷上存储的数据非常重要,因为Stateful就是要依赖存储数据卷上对每个Pod的状态进行建模与存储. 所以K8S提供了一个新的工具——StatefulSet来统一解决问题.
Deployment组件是为无状态服务而设计的,其中的Pod名称,主机名,存储都是随机,不稳定的,并且Pod的创建与销毁也是无序的.这个设计决定了无状态服务并 不适合数据库领域的应用.
而Stateful管理有状态的应用,它的Pod有如下特征:
唯一性: 每个Pod会被分配一个唯一序号. 顺序性: Pod启动,更新,销毁是按顺序进行. 稳定的网络标识: Pod主机名,DNS地址不会随着Pod被重新调度而发生变化. 稳定的持久化存储: Pod被重新调度后,仍然能挂载原有的PV,从而保证了数据的完整性和一致性.
等待更新···</description>
    </item>
    
  </channel>
</rss>
