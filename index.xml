<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>self-salvation</title>
    <link>https://jinkes-li.github.io/</link>
    <description>Recent content on self-salvation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 11 Oct 2022 22:49:12 +0800</lastBuildDate><atom:link href="https://jinkes-li.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Pythons新手村Boss装饰器</title>
      <link>https://jinkes-li.github.io/python/pythons%E6%96%B0%E6%89%8B%E6%9D%91boss%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Tue, 11 Oct 2022 22:49:12 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/pythons%E6%96%B0%E6%89%8B%E6%9D%91boss%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <description>python新手村Boss装饰器 装饰器简介
无产装饰器
有参装饰器
装饰器模版
装饰器语法糖及修复技术
多层装饰器
装饰器简介
概念： 在不改变被装饰器源代码和调用方式的情况下给被装饰的对象添加新的功能 装饰器的本质： 装饰器并不是一个新的技术，而是由函数参数，名称空间，函数名多种用法，闭包函数所组成到一起的结果 口诀： 对修改封闭，对扩展开放 储备知识 这里需要先需要提前使用一个time包来实现一下时间戳功能，代码如下
时间相关操作(time) import time # time 获取时间戳 print(time.time()) # 时间戳(距离1970-01-01 00:00:00所经历的秒数) time.sleep(3) # 程序暂停3秒再运行 print(&amp;#39;这里是代码体&amp;#39;) print(time.time()) # 代码运行结束的时间戳 1665485696.789707 这里是代码体 1665485699.794832 2. 小程序，获取当前代码运行的时长 import time count = 0 start_time = time.time() while count &amp;lt; 10000000: print(&amp;#39;运行中...&amp;#39;) count += 1 end_time = time.time() print(f&amp;#39;当前程序运行需要的时长为{end_time - start_time}&amp;#39;) 当前程序运行需要的时长为16.997233867645264 # 这里是time的用法 装饰器的推导流程（重要） *1*. 第一部分 import time def index(): time.</description>
    </item>
    
    <item>
      <title>Python函数(下)</title>
      <link>https://jinkes-li.github.io/python/python%E5%87%BD%E6%95%B0%E4%B8%8B/</link>
      <pubDate>Mon, 10 Oct 2022 19:49:24 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E5%87%BD%E6%95%B0%E4%B8%8B/</guid>
      <description>python函数（下） 本文将链接上一章的python函数的参数继续讲下去
函数的参数
名称空间与作用域
global与nonlocal
函数名的多种用法
函数的参数
函数参数的概念
形式参数 函数定义阶段括号内填写的参数 实际参数 函数调用阶段括号内填写的参数 1. 位置参数 位置形参 在定义函数时，在括号内从左到右依次填写的变量名 # 如何子代码只有一行或者很简短可以直接在冒号后面编写不用换行 def function(a, b, c):pass pass 位置实参 在函数调用时，在括号内依次从左往右填写的参数值 function(1, 2, 3) 位置参数的注意事项 # 定义一个函数并且写上ab两个位置形参 def func1(a, b): pass(a, b) 1. func1(1, 2) # 按照位置从左往右依次传值 2. func1(1) # 少了一个传入的值，报错 3. func1(1, 2, 3) # 多了一个值，还是报错 4. func1(b=1, a=2) # 关键字参数，将1传给b，2传给a 5. func1(b=1, 2) # 关键字参数一定要跟在位置参数后面否则会报错 6 func1(2, b=1) # 这里关键字参数在位置参数后面就可以正常传入 7. func1(1, a=2, b=3) # 同一个形参在调用的时候不能传入多个值 name = &amp;#39;wesley&amp;#39; pwd = 123 8.</description>
    </item>
    
    <item>
      <title>Python函数(上)</title>
      <link>https://jinkes-li.github.io/python/python%E5%87%BD%E6%95%B0%E4%B8%8A/</link>
      <pubDate>Sun, 09 Oct 2022 16:19:35 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E5%87%BD%E6%95%B0%E4%B8%8A/</guid>
      <description>函数 引言：
函数就相当于提前定义的工具，在使用时可以直接调用工具使用 函数比较类似于循环的代码，都是重复调用一个功能性问题，主要区别如下
循环是相同的代码在相同的位置反复执行 函数是相同的代码在不同的位置反复调用 函数的语法结构 函数的定义与调用 函数的分类 函数的返回值 函数的参数 函数的语法结构 def def_name(): # 关键字，函数名，是否带参数 &amp;#34;&amp;#34;&amp;#34; 打印123，这里主要是对函数功能的描述 &amp;#34;&amp;#34;&amp;#34; print(123) #函数代码体 return 456 # 返回值 1. def 关键字 def关键字就是用来定义函数的 2. 函数名 函数名就相当于我们使用的变量名需要见名知意 3. () 参数 函数参数主要是用于接受外部数据传入内部给括号里面的参数使用 1. 形参： 在函数定义阶段，函数的括号中写入的参数叫做形参 2. 实参： 在函数调用阶段，被调用的函数中写入的数据被称为实参 4. 函数注释 函数注释是用于描述这个函数的功能 5. 函数代码体 函数代码体是实现一个功能的具体代码 6. return 返回值 调用函数后返回给用户的返回值，可有可无需要看具体使用 函数的定义与调用 # 函数的定义 def print_def(): &amp;#34;&amp;#34;&amp;#34; 这是一个打印123的功能 &amp;#34;&amp;#34;&amp;#34; print(123) # 函数的调用，函数的调用直接使用函数名加括号调用 print_def() &amp;#34;&amp;#34;&amp;#34; 注意： 1. 函数在定义阶段python只会检查语法，并不会执行 2. 函数需要先定义再调用 &amp;#34;&amp;#34;&amp;#34; 函数的分类 # 函数的三分类 1.</description>
    </item>
    
    <item>
      <title>文件操作方法</title>
      <link>https://jinkes-li.github.io/python/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 09 Oct 2022 01:29:28 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</guid>
      <description>引言:
平时操作文件都是在计算机中直接新建或编辑文件，这种就类似操作系统直接给我们创建了一个快捷方式，可以直接对硬盘进行操作，今天这里介绍如何使用python代码来对一个文件进行操作
文件操作简介 定义： 文件就是操作系统提供的直接操作硬盘的快捷方式 文件的操作流程 创建或打开文件 编辑文件 保存文件 关闭文件 # Python代码操作文件的语法 # 方式一：（不推荐使用，需要写close来关闭打开的文件） l1 = open(&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) print(l1.read()) l1.close() # 方式二： （推荐使用，with会自动帮助我们关闭文件） with open(&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) as f: print(f.read()) &amp;#34;&amp;#34;&amp;#34; 注意： 如果对文件进行操作时使用到了反斜杠，如 &amp;#39;C：/admin/a.txt&amp;#39;，这里则需要使用&amp;#39;r&amp;#39;将反斜杠的特殊含义转义掉，仅仅作文一个源字符使用 &amp;#34;&amp;#34;&amp;#34; 文件的读写模式 r &amp;ndash; read 只读模式： 只能读不能写 w &amp;ndash; write 只写模式： 只能写不能读，需要注意如果不对光标进行操作。w操作会将原本文件中存在的数据全部覆盖 a &amp;ndash; append 只追加面膜是 ：只能在文件最后追加 read r 模式 read r 模式 # 如果文件不存在会直接报错 with open(r&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) as f: print(f.read()) write w 模式</description>
    </item>
    
    <item>
      <title>第二周总结</title>
      <link>https://jinkes-li.github.io/python/%E7%AC%AC%E4%BA%8C%E5%91%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 07 Oct 2022 20:14:40 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%AC%AC%E4%BA%8C%E5%91%A8%E6%80%BB%E7%BB%93/</guid>
      <description>引言 本文对Python知识的的基础阶段整理归纳
基本数据类型 用户交互与格式化输出运算符 赋值方式 垃圾回收以及流程控制 For循环和数据类型方法 数据类型内置方法理论 数据类型和字符编码 基本数据类型 Python中不同的数据需要有不同的数据类型来表示，用于更好的读取和修改
1.1 布尔值（bool） 布尔值只有两个状态，True和Fales ，当数据为真时结果为True，数据为假时结果为Fales
注意： Python中有一些数据默认值就为False，比如 0 ，None， &amp;lsquo;&amp;rsquo;, {}, [], 这些数据类型如果 没有数据默认为False，除了这些其他基本都为True 一般我们也可以使用变量来定义布尔值，比较建议的名称为is开头。
1.2 字符串 （str） 字符串就是使用单引号或者双引号包含起来的字符就是字符串，字符串中都是文本数据，无法用于计算
1.3 整型 （int） 整型： 整型就是整数，如 0， 1 ，2 等，可用用于运算和条件判断
1.4 浮点型 （foalt） 浮点型： 浮点型就是小数，比如 3.14等
1.5 列表 （list） 列表: 列表是使用中括号包含起来的数据，并以逗号分隔，可以存放多种数据类型，列表是有序的，可以通过索引来取值
1.6 字典 （dict） 字典： 使用花括号括起来的数据，里面同样可以存放多种类型的数据，同时需要注意的是字典是以键值对来存放数据的，并且字典无序，只能通过键来取值
1.7 元组 （tople） 元组： 使用小括号包含起来的数据，数据可以是多种数据类型，元组索引对应的数据值不可以修改，但是如果这个数据值为列表或者字典等，其中列表或者字典的值是可以修改的，元组这里同样有索引的概念
1.8 集合 （set） 集合： 集合与字典一样同样使用花括号来定义，与之不同的是，字典存放数据需要以键值对的方式存放，集合中的数据使用逗号分隔，集合内存放的数据只能是不可变类型，并且在使用集合时，一般只应用于去重和关系运算
用户交互与格式化输出运算符 2.1 用户交互 用户交互就是让与计算机的交流通讯，让计算机理解我们需要做什么
# 关键字 1.</description>
    </item>
    
    <item>
      <title>数据类型和字符编码</title>
      <link>https://jinkes-li.github.io/python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</link>
      <pubDate>Fri, 30 Sep 2022 17:35:33 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</guid>
      <description>python 数据类型操作 今日内容 字典相关操作 元组相关操作 集合相关操作 字符编码(理论) 字典操作 1. 类型转换，字典的转换一般不使用关键字，而是自己手动转 dict() 2. 字典需要掌握的操作 # 原始数据 user_dict = {&amp;#39;username&amp;#39;: &amp;#39;jason&amp;#39;, &amp;#39;password&amp;#39;: 123, &amp;#39;hobby&amp;#39;: [&amp;#39;read&amp;#39;, &amp;#39;music&amp;#39;, &amp;#39;run&amp;#39;] } 2.1 按key取值（不推荐使用，如果这个key不存在会报错） print(user_dict[&amp;#39;username&amp;#39;]) # username jason jason 2.2 使用内置方法get取值（推荐使用） 2.2.1 使用get获取已经存在的key值 print(user_dict.get(&amp;#39;username&amp;#39;)) jason 2.2.2 使用get获取不存在的值 print(user_dict.get(&amp;#39;age&amp;#39;)) None 2.2.3 使用get获取不存在的值，并通过第二个参数设定默认返回值 print(user_dict.get(&amp;#39;age&amp;#39;, &amp;#39;False&amp;#39;)) False 3.1 字典修改数据值，和列表的重新赋值类似 print(id(user_dict)) user_dict[&amp;#39;username&amp;#39;] = &amp;#39;wesley&amp;#39; print(id(user_dict), user_dict) 4337316352 # 从内存ID上看，字典是一个可变参数 4337316352 {&amp;#39;username&amp;#39;: &amp;#39;wesley&amp;#39;, &amp;#39;password&amp;#39;: 123, &amp;#39;hobby&amp;#39;: [&amp;#39;read&amp;#39;, &amp;#39;music&amp;#39;, &amp;#39;run&amp;#39;]} 3.2 如果修改的key并不存在，则会新建 user_dict[&amp;#39;age&amp;#39;] = 18 print(user_dict) {&amp;#39;username&amp;#39;: &amp;#39;jason&amp;#39;, &amp;#39;password&amp;#39;: 123, &amp;#39;hobby&amp;#39;: [&amp;#39;read&amp;#39;, &amp;#39;music&amp;#39;, &amp;#39;run&amp;#39;], &amp;#39;age&amp;#39;: 18} 3.</description>
    </item>
    
    <item>
      <title>Python数据类型内置方法理论</title>
      <link>https://jinkes-li.github.io/python/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E7%90%86%E8%AE%BA/</link>
      <pubDate>Thu, 29 Sep 2022 20:51:22 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E7%90%86%E8%AE%BA/</guid>
      <description>Python数据类型内置方法和理论 引言： Python自身对数字的敏感度比较低（精确度低） 如果是用在数据分析和金融量化方向，可以使用第三方包模块numpy
本文内容
数据类型内置方法理论 进制数转换 整型相关操作 浮点型相关操作 字符串相关操作 列表相关操作 数据类型内置方法理论 前面文章所提到的每一种数据类型本身都包含有一系列的操作方法，内置方法，是自身带的功能 Python中的数据类型调用内置方法的统一句式为: &amp;ldquo;.&amp;quot;:句点符 &amp;lsquo;wesley&amp;rsquo;.字符串的内置方法 str. 字符串内置方法 数据类型的内置方法比较的多，其中有一些经常使用的以及部分不经常使用的，需要在工作中使用，并且熟悉 进制数转化 开头前两位代表的是转换后表示的进制数 0b代表的是二进制 0o代表的是八进制 0x代表的是十六进制 # 代码实例 # 十进制转换其他进制 # 十转二 print(bin(100)) 0b1100100 # 十转八 print(oct(100)) 0o144 # 十转十六 print(hex(100)) 0x64 # 如果需要八进制转换成其他进制直接反打就可以了 # 二转十 print(int(0b1100100), 2) 100 2 # 八转十 print(int(0o144), 8) 100 8 # 十六转十 print(int(0x64), 16) 100 16 整型的相关操作 类型转换（可以将其他类型转换为整型） int(其他数据类型)，原始数据为浮点型可以直接转换，如果是字符串必须满足内部是纯数字才可以 # 代码实例 # str转int，注意字符串是不可变类型，这里需要重新赋值 a = &amp;#39;1111&amp;#39; a = int(a) print(type(a)) &amp;lt;class &amp;#39;int&amp;#39;&amp;gt; # float转int, 注意在float转int的时候int方法会将小数点后面的数据全部切除，而不是四舍五入，并且如果字符串中存在多个小数点，int无法识别并转换 a = 11.</description>
    </item>
    
    <item>
      <title>For循环和数据类型方法</title>
      <link>https://jinkes-li.github.io/python/for%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 28 Sep 2022 18:58:47 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/for%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95/</guid>
      <description>while 循环补充说明 流程控制之for循环 while循环之死循环
真正的死循环一旦执行，cpu功耗会急剧上升 # 死循环 while True: i = 99 ** 99 print(i) while嵌套及全局标志位
注意： 一个break只能结束它所在的那一乘循环 注意：有几个while的嵌套，如果想一次性结束就应该写几个break 注意：如果不想反复的写break，可以使用全局标志位，就是在循环开始之初，定义一个变量为True，如果需要跳出while循环把这个变量赋值为False即可 is_flag = True # 这里定义一个全局标志位 while is_flag: # while的条件是如果is_flag = True就运行False就不运行 username = input(&amp;#39;username&amp;gt;&amp;gt;&amp;gt;:&amp;#39;) password = input(&amp;#39;password&amp;gt;&amp;gt;&amp;gt;:&amp;#39;) if username == &amp;#39;jason&amp;#39; and password == &amp;#39;123&amp;#39;: while is_flag: # 判断is_flag cmd = input(&amp;#39;请输入您的指令&amp;gt;&amp;gt;&amp;gt;:&amp;#39;) if cmd == &amp;#39;q&amp;#39;: # 这里判断我们输入的命令是什么，如果为q 直接将is_flag 从新赋值为False is_flag = False print(&amp;#39;正在执行您的指令:%s&amp;#39; % cmd) else: print(&amp;#39;用户名或密码错误&amp;#39;) 流程控制之for循环</description>
    </item>
    
    <item>
      <title>垃圾回收以及流程控制</title>
      <link>https://jinkes-li.github.io/python/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Tue, 27 Sep 2022 22:10:23 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>Python垃圾回收以及流程控制 垃圾回收 流程控制理论 流程控制之分支结构 流程控制之循环结构 垃圾回收机制 在不分语言中，内存空间的申请和释放都需要程序员自己写代码才可以完成，但是Python这里不需要，有自身的垃圾回收机制自动管理
引用计数 引用计数，每一个变量值都有对应的计数值，每增加一个变量的引用，计数值则会加一，每减少一个引用计数值则会减一， 当引用值等于0时，就会触发垃圾回收机制 引用计数-原理图 标记清除 标记清除主要针对循环引用的问题 # 代码实例 l1 = [11, 22] # 引用计数1 l2 = [33, 44] # 引用计数1 # 循环引用 l1.append(l2) # l1 = [11, 22, [33, 44]] # 引用值为2 l2.append(l1) # l2 = [33, 44, [11, 22]] # 引用值为2 del l1 # 断开变量名l1与列表的绑定关系，引用值变更为1 del l2 # 断开变量名l2与列表的绑定关系，引用值变更为1 # 当内存占用到达临界值的时候，程序会自动停止，然后扫描程序中所有的数据，并给只产生循环引用的数据打上标记，之后一次性清除 标记清除-原理图
分代回收 用的越久的对象，被回收的可能性越小 请直接看原理图 分代原理图 流程控制理论 在编程的世界中下列三者会出现混合使用
Python代码中建议使用空格表示代码的从属关系，建议使用4个空格
从属关系：缩进的代码（子代码）是否执行取决于上层代码，并不是所有的代码都有子代码
如果多行子代码同属于一个父代码，那么这些子代码需要保持相同的缩进
当一行代码需要编写子代码时，必须以冒号结尾</description>
    </item>
    
    <item>
      <title>用户交互与格式化输出运算符</title>
      <link>https://jinkes-li.github.io/python/%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Mon, 26 Sep 2022 21:25:44 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>Python 本篇文章接着上一个文章继续介绍Python
Python基本的数据类型
与用户交互
格式化输出
基本运算符
多种赋值方式
逻辑运算符
成员运算符
身份运算符
1. Python基本数据类型 布尔值 （bool） 定义：用来判断事务的对错，是否可行，应用与流程控制中 布尔值只有两种状态 True 真的，可行的，对的 False 假的，不可行的，错的 Python中所有的数据都是自带布尔值的，自带布尔值的数据有下列两种 布尔值默认为False的数据有：0 None &amp;rsquo;&amp;rsquo; [] {} 布尔值默认为True的数据有：一般除了上面的都是True 布尔值的变量名一般推荐使用is开头 # 代码实例 is_boo1f = False is_boolt = True 小知识： 在企业中一般说的数据库数据伪删除使用的就是类似这种判断逻辑。
# 代码实例 # 一般企业提供的账号注销功能就是使用布尔值判断逻辑 # 比如下列表格中 is_delete 字段0代表着账户存在，字段1代表账户被删除，其实只是修改李程序取值的逻辑，并未删除实际数据 id	username	password phone is_delete 1 jason	123	110 1 2	kevin	321	120	0 # 一般这种方式大多应用于数据库中 元组（tuple） 定义： 小括号括起来 内部存放多个数据值 数据值与数据值之间逗号隔 开 数据值可以是任何数据类型 被称为不可变列表，是因为元组内存放的地址不能修改 # 代码实例 # 列表与元组的对比 # 列表使用[]进行定义 l1 = [11, 22, 33] # 定义一个列表并赋值给l1 l1[0] = 123 # 使用重复赋值将123替换到l1列表的0号索引 print(l1[0]) # 这里发现最终打印的123，而不是11，所以列表值是可变的 123 ​ 列表修改数据图表参考如下</description>
    </item>
    
    <item>
      <title>周末总结</title>
      <link>https://jinkes-li.github.io/python/%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 25 Sep 2022 17:05:19 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93/</guid>
      <description>周末总结 硬件总结 计算机基础知识 安装Pycharm 遇见Python Markdown文档编写 计算机基础硬件 CPU
控制器
调度计算机硬件之间的工作，相当于人类的大脑
运算器
在计算机中负责数学运算以及逻辑运算，同样相当于人类的大脑
存储
内存
基于电工作，内存将磁盘中的数据加载到自身于CPU交互，数据仅次于 CPU，但是断电未持久化的数据将会丢失
磁盘 将内存需要存储的数据，在磁盘中永久的存储下去
输入设备 计算机中的键盘鼠标，扫描仪等，都属于输入设备，是将外界信息录入计算机的一种设备
输出设备 将计算机中的数据输出的设备被称为输出设备，例如显示器，投影机等
计算机基础知识 路径 路径就是计算机中用来定位资源的路径，C:\user\admin\a.txt 这就是一个文件的路径
相对路径 相对路径就是具有参照物的路径，可以不用从根目录开始寻找 绝对路径 绝对路径就是需要从根路径开始寻找 环境变量 当系统需要寻找一个文件时会先寻找当前路径，如果当前路径寻找不到就	会寻找系统中的环境变量，环境变量相当于告诉计算机，如果这个文件找不	到就去环境变量的这个文件下寻找
进制
二进制 0 1 10 11 ，0和1 就是二进制用来表示高低电平，可以直接被计算机识别，二进制逢二进一 八进制 0 1 2 3 4 5 6 7 ，0到7就是八进制，逢八进一 十进制 0 1 2 3 4 5 6 7 8 9 ，0-9时十进制，逢十进一 十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f ，0 -f是十六进制，逢十六进一 单位换算</description>
    </item>
    
    <item>
      <title>遇见Python</title>
      <link>https://jinkes-li.github.io/python/%E9%81%87%E8%A7%81python/</link>
      <pubDate>Fri, 23 Sep 2022 19:12:39 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E9%81%87%E8%A7%81python/</guid>
      <description>遇见Python 引言：
接下来本文开始将在学习和工作中记录Python的使用
本文内容
Python语法-注释
关键字
变量与常量
​	变量与常量的基本使用
​	变量规范和命名规则
数据类型
​	整型（int）
​	浮点型（float）
​	字符串（str）
​	列表（list）
​	字典（dict）
PEP8规范
Python语法-注释
注释的意思就是被注释的代码不执行，参见下列示例
注释符号 # &amp;#39;&amp;#39;&amp;#39; &amp;#39;&amp;#39;&amp;#39; &amp;#34;&amp;#34;&amp;#34; &amp;#34;&amp;#34;&amp;#34; # 打印123 print(123) # 这一行是代码，代码后面也可以加注释 &amp;#39;&amp;#39;&amp;#39; 123 456 这是多行注释，被包含的内容都不执行 &amp;#39;&amp;#39;&amp;#39; &amp;#34;&amp;#34;&amp;#34; 666 这也是多行注释，被包含的内容都不执行 &amp;#34;&amp;#34;&amp;#34; 关键字 # 具有一定功能的特定单词，例如 print(&amp;#39;打印&amp;#39;) print(&amp;#39;123&amp;#39;) 123 # 查看数据类型 type() name = &amp;#39;wesley&amp;#39; print(type(name)) &amp;lt;class &amp;#39;str&amp;#39;&amp;gt; # 通过输出结果可以看出数据类型为str 也就是字符串 变量与常量
变量就是会变化的量，常量就是不会变化的量或者说长时间不会改变的量
​	变量：比如说我们的年龄会随着每年增涨，今年18，明年19，年龄在不断发生变化，这就是变量
​	常量：比如我们的身份证号码就属于常量，无论什么时间身份证号都不会发生变化，这就是常量
变量的命名规则和特性</description>
    </item>
    
    <item>
      <title>JetBrains IDE 产品使用</title>
      <link>https://jinkes-li.github.io/python/jetbrains-ide-%E4%BA%A7%E5%93%81%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 23 Sep 2022 19:03:58 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/jetbrains-ide-%E4%BA%A7%E5%93%81%E4%BD%BF%E7%94%A8/</guid>
      <description>JetBrains IDE 产品使用（Pycharm ） ​	引言：本文使用的系统为 MacOS 12.5 M1
接下来我们需要写Python相关的代码这里强烈推荐使用Pycharm，由于免费的社区版某些功能没有，这里我们使用Pycharm专业版（仅测试使用）
JetBrains官网 下载安装你需要的 IDE这里下载PyCharm，下载完成后直接双击安装 下载 Jetbrains.zip，下载后解压，得到 fineagent.jar，将该文件复制到 /Users/你的用户名/ 文件夹下
#使用cd进入到Users下面的你电脑的用户名下 wesley@wesleydeMacBook-Pro ⮀ ~ ⮀ cd /Users/wesley/ #将下载的fineagent.zip 复制到当前目录并解压，注意：我这里是吧fineagent.zip下载到了Downloads这个目录下，请以你的下载目录为准 wesley@wesleydeMacBook-Pro ⮀ ~ ⮀ cp /Users/wesley/Downloads/fineagent.zip ./ &amp;amp;&amp;amp; unzip fineagent.zip &amp;amp;&amp;amp; ll -rw-r--r--@ 1 wesley staff 35K Aug 15 10:21 fineagent.jar wesley@wesleydeMacBook-Pro ⮀ ~ ⮀ 打开访达，点击左侧的 应用程序 找到 PyCharm，在 PyCharm 图标上右键，点击 显示包内容
进入 Contents 目录，再进入 bin 目录，使用文本编辑器打开 pycharm.vmoptions文件
5.在最后面添加 -javaagent:/Users/你的用户名/fineagent.jar，记得修改一下你的用户名。
运行 PyCharm, 选择 Activate PyCharm，再点击 Activation Code</description>
    </item>
    
    <item>
      <title>基础和py解释器</title>
      <link>https://jinkes-li.github.io/python/%E5%9F%BA%E7%A1%80%E5%92%8Cpy%E8%A7%A3%E9%87%8A%E5%99%A8/</link>
      <pubDate>Thu, 22 Sep 2022 20:12:55 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%9F%BA%E7%A1%80%E5%92%8Cpy%E8%A7%A3%E9%87%8A%E5%99%A8/</guid>
      <description>引言：
​	继续接着上一个文章干活哈
本文内容： 计算机三大核心硬件部分详解 操作系统 编程与编程语言 编程语言的发展史 编程语言的分类 Python解释器 Python解释器多版本共存 计算机主要三核心硬件详解 CPU ​ 中央处理器（CPU），是电子计算机的主要设备之一，电脑中的核心配件。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU是计算机中负责读取指令，对指令译码并执行指令的核心部件。中央处理器主要包括两个部分，即控制器、运算器，其中还包括高速缓冲存储器及实现它们之间联系的数据、控制的总线。电子计算机三大核心部件就是CPU、内部存储器、输入/输出设备。中央处理器的功效主要为处理指令、执行操作、控制时间、处理数据。
存储器 ​	按信息的可保存性分类
​	非永久记忆的存储器：断电后信息即消失的存储器。
​	永久记忆性存储器：断电后仍能保存信息的存储器。
​	按在计算机系统中的作用分类
​	主存储器（内存）：用于存放活动的程序和数据，其速度高、容量较小、每位价位高。
​	辅助存储器（外存储器）：主要用于存放当前不活跃的程序和数据，其速度慢、容量大、每位价位低。
​	缓冲存储器：主要在两个不同工作速度的部件起缓冲作用。
输入设备 ​	输入设备是向计算机输入数据和信息的设备，是计算机与用户或其他设备通信的桥梁，是用户和计算机系统之间进行信息交换的主要装置之一。输入设备的任务是把数据、指令及某些标志信息等输送到计算机中去。键盘、鼠标、摄像头、扫描仪、光笔、手写输入板、游戏杆、语音输入装置等都属于输入设备（Input Device ），是人或外部与计算机进行交互的一种装置，用于把原始数据和处理这些数据的程序输入到计算机中。
输出设备 ​	输出设备（Output Device）是把计算或处理的结果或中间结果以人能识别的各种形式,如数字、符号、字母等表示出来,因此输入输出设备起了人与机器之间进行联系的作用。常见的有显示器、打印机、绘图仪、影像输出系统、语音输出系统、磁记录设备等。
操作系统 ​	计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出（文字、图片、音频、视频等）。计算机由硬件和软件组成：
硬件是计算机赖以工作的实体，包括显示器、键盘、鼠标、硬盘、CPU、主板等； 软件会按照用户的要求协调整台计算机的工作，比如 Windows、Linux、Mac OS、Android 等操作系统，以及 Office、QQ、迅雷、微信等应用程序。 操作系统是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁（或者说接口、中间人、中介等）。
编程与编程语言 编程 ​	指的是给计算机编定程序，使计算机能够完成我们需要的指令，得到相应的结果。这种人与计算机之间的交流过程就叫做编程。编程是一种逻辑的思维运算。
编程语言
编程语言（programming language）可以简单的理解为一种计算机和人都能识别的语言。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。
编程语言的3大类 机器语言： 定义 优点 缺点 计算机直接识别的二进制代码 直接执行，速度快，资源占用少 可读性、可移植性差，编程繁杂 机器语言是直接可以被计算机认识的语言，无需经过翻译，每一操作码在计算机内部都有相应的电	路来完成它。
汇编语言： 定义 优点 缺点 汇编无法直接被机器直接识别需要汇编 编译阅读（相对机器语言），速度块，资源占用少 可读性、可移植性差，可维护性差 汇编语言具有更高的机器相关性，更加便于记忆和书写，但又同时保留了机器语言高速度和高效率的特点。汇编语言仍是面向机器的语言，很难从其代码上理解程序设计意图，设计出来的程序不易被移植，故不像其他大多数的高级计算机语言一样被广泛应用</description>
    </item>
    
    <item>
      <title>关于博主</title>
      <link>https://jinkes-li.github.io/about/%E5%85%B3%E4%BA%8E%E5%8D%9A%E4%B8%BB/</link>
      <pubDate>Wed, 21 Sep 2022 19:37:41 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/about/%E5%85%B3%E4%BA%8E%E5%8D%9A%E4%B8%BB/</guid>
      <description>关于博主： ​	博主不是一个技术大牛，只是一个拥抱开源技术的爱好者，目前正在从事运维开发工作，希望在闲暇时间可以将好的项目和技术知识对大家进行分享，除此之外也是一名自我救赎者。
​	&amp;ndash;来自一名互联网的小透明</description>
    </item>
    
    <item>
      <title>计算机基础及Markdown基础</title>
      <link>https://jinkes-li.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%8F%8Amarkdown%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Wed, 21 Sep 2022 16:17:14 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%8F%8Amarkdown%E5%9F%BA%E7%A1%80/</guid>
      <description>引言： 干活干活～
整理一下Markdown一些常见的用法 再来一点计算机基础，ok ，现在开始。
计算机基础 想了想还是吧计算机基础写在前面吧，后续更新python慢慢深入哈～
​	世界上第一台通用计算机“ENIAC”于1946年2月14日在美国宾夕法尼亚大学诞生。发明人是美国人莫克利（JohnW.Mauchly）和艾克特（J.PresperEckert）。
​	对于我们来说计算机到底是什么，为什么说计算机是互联网世界的基石呢，首先我们需要理解计算机创造之初的设计理念。
由于在人类社会中存在大量重复性工作，以及随着文明的进步衍生出许许多多需要海量计算的数据，那这些数据依靠人脑需要计算几十上百年甚至是上万年才能被计算出来，由此计算机参照人类本身的行为逻辑应运而出。
我们需要先了解计算机的核心硬件：
控制器-CPU （相当于人类的大脑，用于协调身体的各个器官合作工作） 运算器-CPU （这个也相当于人类的大脑思考如何解决这个问题并给出解决方案） 存储器-RAM-DISK （相当于记忆，区分为短暂记忆(RAM)和永久记忆(DISK)） 输入设备-键盘 （比如耳朵，眼睛，嗅觉等，只用于接收信息由大脑处理） 输出设备-显示屏（比如嘴巴，教师向学生授课就想当于输出，学生们就相当于被灌输知识，这里也就是输入） 说完计算机的基本组成，我们再浅谈一下计算机是如何工作的。
​	人不吃饭不行，计算机主要依靠电信号，离开了电当然也是不可以的，是依靠着高低电频来组成不同的信息，这个电频不是高就是低，感觉能组成的信息太少了怎么办，这就不得不说一下进制的概念了
进制 二进制	0 1（逢二进一 0 1 10） 八进制 0 1 2 3 4 5 6 7 （逢八进一） 十进制 0 1 2 3 4 5 6 7 8 9 （逢十进一） 十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f （逢十六进一） ​	其中十进制和十六进制一半用于各种电子设备的IP地址，二进制一半是二进制文件，至于八进制 en&amp;hellip;好像没怎么遇到过，这里顺便加一下存储的单位转换。然后说一下计算机如何通过路径找文件，对于人来说哈。</description>
    </item>
    
    <item>
      <title>Mac设置不休眠</title>
      <link>https://jinkes-li.github.io/posts/mac%E8%AE%BE%E7%BD%AE%E4%B8%8D%E4%BC%91%E7%9C%A0/</link>
      <pubDate>Fri, 19 Aug 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/mac%E8%AE%BE%E7%BD%AE%E4%B8%8D%E4%BC%91%E7%9C%A0/</guid>
      <description>Mac默认情况下合上盖子就会进入休眠状态，正在进行的任务也会停止。我们在终端执行两条命令来将Mac设置为合盖不休眠。
打开Terminal，执行如下两条语句：
sudo pmset -b sleep 0 sudo pmset -b disablesleep 1 若需要恢复原有合盖自动休眠的设置，则执行如下两条语句：
sudo pmset -b sleep 5 sudo pmset -b disablesleep 0 关于pmset命令更多的用法可以在终端执行man pmset来查看。</description>
    </item>
    
    <item>
      <title>aliyun Centos7 如何安装python3.7.4和pip3</title>
      <link>https://jinkes-li.github.io/posts/%E9%98%BF%E9%87%8C%E4%BA%91centos7%E5%AE%89%E8%A3%85python3.7.4%E5%92%8Cpip3/</link>
      <pubDate>Tue, 19 Jul 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E9%98%BF%E9%87%8C%E4%BA%91centos7%E5%AE%89%E8%A3%85python3.7.4%E5%92%8Cpip3/</guid>
      <description>aliyun Centos7 如何安装python3.7.4和pip3
亲测有效，针对 阿里云 centos 7 轻量服务器
python ==&amp;gt; 3.7.4
pip ==&amp;gt; 3
一，打开python官网，找到下载Python的tgz文件，有两种方式下载 （版本可能更新，进官网核实为准）
1，直接在windows系统下了完了，通过xtfp上传文件到/usr/local/下 python官网下载地址：https://www.python.org/downloads/release/python-374/
2、通过wget命令，至于命令后半段下载链接，直接右键点击Gzi&amp;hellip;&amp;hellip;复制链接即可
wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz 二，解压文件，添加一些安装依赖 在/usr/local/目录下解压 (习惯将这里当做文件下载，解压的地方，根据个人情况而定)
tar zxvf Python-3.7.4.tgz 安装依赖
yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel gcc libffi-devel gcc make automake autoconf libtool libffi-devel 且需要安装一个包，libffi-devel为3.7版本需要的一个新的包，否则安装的时候报错 ModuleNotFoundError: No module named &amp;lsquo;_ctypes&amp;rsquo;
yum install libffi-devel -y 进入解压目录
cd Python-3.7.4 进行初始配置 注意：在这之前先将安装目录创建好，否则&amp;hellip;&amp;hellip;.，这里我安装到 /usr/local/python3 目录下
mkdir /usr/local/python3 ./configure --prefix=/usr/local/python3　执行安装</description>
    </item>
    
    <item>
      <title>Kubernetes Coredns 服务发现</title>
      <link>https://jinkes-li.github.io/posts/kubernetes-coredns-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Tue, 19 Jul 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/kubernetes-coredns-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B5%8B%E8%AF%95/</guid>
      <description>测试 1111服务发现是指服务之间的通讯联通，对于Kubernetes来说服务发现具有3个痛点
服务的动态性强 服务更新发布频繁 服务支持自动伸缩 Kubernetes中的PODIP是不断变化的，这里如何以不变应万变呢，以下两组概念就可以解决这个问题
Kubernetes中抽象出来Service资源，通过标签选择器来关联一组POD Kubernetes中抽象出来了集群网络，通过相对固定的集群IP，使服务的接入点固定 那么如何自动关联Service资源的“名称”和“集群网络IP”，从而达到服务被集群自动发现的目的？
我们可以考虑一下传统的NDS模型： baidu.com —&amp;gt; 111.213.123.1
Kubernetes这里通过Coredns也去建立类似于传统DNS的模型，实现域名和IP（也就是固定接入点）的绑定
部署Coredns
在hdss7-200.host.com上，配置一个NGINX，用以提供kubernetes统一的访问资源清单入口
[root@hdss7-200 ~]# vim /etc/nginx/conf.d/k8s-yaml.od.com.conf server { listen 80; server_name k8s-yaml.od.com; location / { autoindex on; default_type text/plain; root /data/k8s-yaml; } } [root@hdss7-200 html]# cd /data [root@hdss7-200 data]# mkdir k8s-yaml [root@hdss7-200 data]# cd k8s-yaml/ [root@hdss7-200 k8s-yaml]# mkdir coredns [root@hdss7-200 k8s-yaml]# nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful [root@hdss7-200 k8s-yaml]# nginx -s reload [root@hdss7-200 k8s-yaml]# nginx配置中使用了新的域名，需要在内网DNS服务器上配置解析</description>
    </item>
    
    <item>
      <title>项目环境</title>
      <link>https://jinkes-li.github.io/posts/%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Wed, 26 May 2021 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/</guid>
      <description>BI 项目启动环境 此项目使用的是Centos7.9 内核版本5.19，升级历史操作如下 [可参考]
17 rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 18 rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 19 yum --disablerepo=&amp;#34;*&amp;#34; --enablerepo=&amp;#34;elrepo-kernel&amp;#34; list available 20 $ yum --enablerepo=elrepo-kernel install kernel-ml 21 yum --enablerepo=elrepo-kernel install kernel-ml 22 awk -F\&amp;#39; &amp;#39;$1==&amp;#34;menuentry &amp;#34; {print i++ &amp;#34; : &amp;#34; $2}&amp;#39; /etc/grub2.cfg 23 grub2-set-default 0 24 reboot 25 uname -a 26 history 基本环境安装 install git
[root@web ~]# yum install git -y install docker
安装教程
[root@web ~]# yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine [root@web ~]# yum install -y yum-utils [root@web ~]# yum-config-manager \ --add-repo \ https://download.</description>
    </item>
    
    <item>
      <title>服务状态</title>
      <link>https://jinkes-li.github.io/posts/%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</link>
      <pubDate>Tue, 21 Jan 2020 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</guid>
      <description>服务状体
常常听到的服务状态是什么意思？ 什么是无服务状态和什么是有服务状态
无状态服务
无状态服务不会在本地存储持久化数据.多个服务实例对于同一个用户请求的响应结果是完全一致的.这种多服务实例之间是没有依赖关系,比如web应用,在k8s控制器 中动态启停无状态服务的pod并不会对其它的pod产生影响.
有状态服务
有状态服务需要在本地存储持久化数据,典型的是分布式数据库的应用,分布式节点实例之间有依赖的拓扑关系.比如,主从关系. 如果K8S停止分布式集群中任 一实例pod,就可能会导致数据丢失或者集群的crash.
了解这个之后我们提出一个问题， Deployment部署的问题?
Deployment被设计用来管理无状态服务的pod,每个pod完全一致.什么意思呢?
无状态服务内的多个Pod创建的顺序是没有顺序的. 无状态服务内的多个Pod的名称是随机的.pod被重新启动调度后,它的名称与IP都会发生变化. 无状态服务内的多个Pod背后是共享存储的.
现在看一个新的问题？
对于数据库有状态的服务容器编排,Deployment解决方案就变得无能为力了. 比如,Redis是主从的架构,只能允许集群中出现一个主节点提供写,其它节点提供读能力.如果同时出现二个主节点后,必须会出现并发写的 操作,进一步导致集群写数据的不一致. 所以问题来了,针对Redis这种有状态的服务,它管理的多个Pod(代表master/slave角色)必须有自己独立的持久化存储组件. 有状态的服务Pod是用来运行有状态应用的,其在数据卷上存储的数据非常重要,因为Stateful就是要依赖存储数据卷上对每个Pod的状态进行建模与存储. 所以K8S提供了一个新的工具——StatefulSet来统一解决问题.
Deployment组件是为无状态服务而设计的,其中的Pod名称,主机名,存储都是随机,不稳定的,并且Pod的创建与销毁也是无序的.这个设计决定了无状态服务并 不适合数据库领域的应用.
而Stateful管理有状态的应用,它的Pod有如下特征:
唯一性: 每个Pod会被分配一个唯一序号. 顺序性: Pod启动,更新,销毁是按顺序进行. 稳定的网络标识: Pod主机名,DNS地址不会随着Pod被重新调度而发生变化. 稳定的持久化存储: Pod被重新调度后,仍然能挂载原有的PV,从而保证了数据的完整性和一致性.
等待更新···</description>
    </item>
    
  </channel>
</rss>
