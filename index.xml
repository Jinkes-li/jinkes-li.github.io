<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>self-salvation</title>
    <link>https://jinkes-li.github.io/</link>
    <description>Recent content on self-salvation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Nov 2022 16:56:07 +0800</lastBuildDate><atom:link href="https://jinkes-li.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>第六周总结</title>
      <link>https://jinkes-li.github.io/python/%E7%AC%AC%E5%85%AD%E5%91%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 06 Nov 2022 16:56:07 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%AC%AC%E5%85%AD%E5%91%A8%E6%80%BB%E7%BB%93/</guid>
      <description>第六周总结 引言：
本周内容主要在于面向对象编程的思想
编程思想 面向对象重要理论 面向对象代码实操 对象的独有数据 对象的独有方法 动静态方法 面对对象继承 对象查找名字的顺序 继承的本质 基于继承的派生方法 编程思想 面向过程 面向过程指的是将一个问题进行流程化处理，在处理过程中问题将会越来越简单，最终得到结果 面向对象 面向对象需要把自己当做造物主，将问题拆分创造一个个对象具有解决问题的数据与功能 在面向对象编程中有三大特性
封装 继承 多态 名词解释： 1. 类： 用来描述具有相同属性和方法的对象的集合，类定义了该集合中每个对象所有的属性和方法，并切对象就是类的实例 2. 对象： 通过类定义的数据结构实例
面向对象重要理论 多个具有相同属性和功能的对象被称为类 同一个类中的对象都可以调用这个类中的公共功能和数据 在python语言中必须先定义类后才能定义对象 创造对象后 对象是无法控制和预测 面向对象代码实操 # 类的语法 class Class_name: &amp;#34;&amp;#34;&amp;#34; 类的描述 &amp;#34;&amp;#34;&amp;#34; # 类的公共数据 common_data = &amp;#39;123班级&amp;#39; # 类的公共功能 def common_func(self): pass # class 定义类的关键字，后面是类的名字，定义和变量名的区别是首字母大写用于区分 # 类的公共数据，这个类产生的所有对象都可以调用的相同数据，这个数据是共享的 # def common_func(self): 类的公共功能，具有一定功能的函数 在面向对象中，类和对象访问数据或者功能，可以通过句点符点出类中的数据和功能
查看名称空间 # 定义一个类 class Student: school_name = &amp;#39;野鸡大学&amp;#39; def common_func(self): pass # 查看当前的名称空间 print(Student.</description>
    </item>
    
    <item>
      <title>Python面对对象(中)</title>
      <link>https://jinkes-li.github.io/python/python%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B8%AD/</link>
      <pubDate>Thu, 03 Nov 2022 19:00:58 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B8%AD/</guid>
      <description>python面向对象 动静态方法
面对对象值继承理论
继承基本操作
对象查找名字的顺序
继承本质
基于继承的派生方法
动静态方法
方法也就是函数，什么叫动静态呢，就是指自己传参的就是动态，需要手动传参的就是静态，这些方法又是如何被定义的呢，主要方式有三种
1. 动态方法 class Student: school_name = &amp;#39;摆烂大学&amp;#39; # 1. 类中直接定义函数，默认绑定给对象，类调用有几个参数传几个，对象调用的第一个参数就是对象自身 def func1(self): print(&amp;#39;看看谁最能摆烂，很棒&amp;#39;) obj = Student() # 1. 绑定给对象的方法 obj.func1() # 类调用 Student.func1(123) 结果： 看看谁最能摆烂，很棒 看看谁最能摆烂，很棒 &amp;#34;&amp;#34;&amp;#34; 1. 第一种在定义方法时 在类中直接定义，默认是绑定给对象的，也就是说使用对象调用时会将对象名当做第一个参数传入，所以这里第一步调用的时候不需要额外的参数 2. 而在我们使用类调用这个方法时，有几个参数就需要写几个，需要对应传入的参数并不会有什么特殊的作用仅仅是占位传参 &amp;#34;&amp;#34;&amp;#34; 2. 动态方法 class Student: school_name = &amp;#39;摆烂大学&amp;#39; # 2. 被@classmethod修饰的函数，默认绑定给类，类调用的第一个参数就是类自身，对象也可以调用并且会自动将产生该对象的类当做第一个参数传入 @classmethod def func2(cls): print(&amp;#39;猜猜我是干嘛滴&amp;#39;, cls) obj = Student() # 2. 绑定给类的方法 Student.func2() obj.func2() 猜猜我是干嘛滴 &amp;lt;class &amp;#39;__main__.Student&amp;#39;&amp;gt; 猜猜我是干嘛滴 &amp;lt;class &amp;#39;__main__.</description>
    </item>
    
    <item>
      <title>Python面向对象(上)</title>
      <link>https://jinkes-li.github.io/python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/</link>
      <pubDate>Wed, 02 Nov 2022 20:27:48 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8A/</guid>
      <description>python之面对对象 面向对象前夕
面向对象编程思想
面向对象重要理论
面向对象代码实操
对象的独有数据
对象的独有方法
面对对象前夕
接下来主要看一下如果不使用面对对象的方式如何定义一些对象和会出现的问题
代码演示：人汪大战 在这一步可以推导出来，如果有很多的人和很多汪，我们则需要写很多次重复代码
# 实现步骤1，先定义人和汪汪 person1 ={ &amp;#39;name&amp;#39;: &amp;#39;wesley&amp;#39;, &amp;#39;age&amp;#39;: 18, &amp;#39;gender&amp;#39;: &amp;#39;male&amp;#39;, &amp;#39;p_type&amp;#39;: &amp;#39;猛男&amp;#39;, &amp;#39;attack_val&amp;#39;: 8000, &amp;#39;life_val&amp;#39;: 999999 } person2 = { &amp;#39;name&amp;#39;: &amp;#39;kevin&amp;#39;, &amp;#39;age&amp;#39;: 28, &amp;#39;gender&amp;#39;: &amp;#39;female&amp;#39;, &amp;#39;p_type&amp;#39;: &amp;#39;淑女&amp;#39;, &amp;#39;attack_val&amp;#39;: 1, &amp;#39;life_val&amp;#39;: 100 } dog1 = { &amp;#39;name&amp;#39;: &amp;#39;小黑&amp;#39;, &amp;#39;d_type&amp;#39;: &amp;#39;泰迪&amp;#39;, &amp;#39;attack_val&amp;#39;: 100, &amp;#39;life_val&amp;#39;: 8000 } dog2 = { &amp;#39;name&amp;#39;: &amp;#39;小白&amp;#39;, &amp;#39;d_type&amp;#39;: &amp;#39;恶霸&amp;#39;, &amp;#39;attack_val&amp;#39;: 2, &amp;#39;life_val&amp;#39;: 80000 } 继续向下推导，将产生人和汪星人的字典封装为函数，并封装人和汪星人的攻击函数 1. 创建一个可以传入人数据的函数 def create_person(name, age, gender, p_type, attack_val, life_val): person_dict = { &amp;#39;name&amp;#39;: name, &amp;#39;age&amp;#39;: age, &amp;#39;gender&amp;#39;: gender, &amp;#39;p_type&amp;#39;: p_type, &amp;#39;attack_val&amp;#39;: attack_val, &amp;#39;life_val&amp;#39;: life_val } return person_dict 2.</description>
    </item>
    
    <item>
      <title>阶段复习一</title>
      <link>https://jinkes-li.github.io/python/%E9%98%B6%E6%AE%B5%E5%A4%8D%E4%B9%A0%E4%B8%80/</link>
      <pubDate>Tue, 01 Nov 2022 21:29:31 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E9%98%B6%E6%AE%B5%E5%A4%8D%E4%B9%A0%E4%B8%80/</guid>
      <description>阶段复习一 1.计算机基础阶段 计算机五大组成部分 1. 运算器 2. 控制器 3. 存储器 4. 输入设备 5. 输出设备 计算机三大核心硬件 1. 磁盘 2. 内存 3. CPU 操作系统 操作系统就是人与计算机硬件交互的前两 文件路径 1. 相对路径 2. 绝对路径 2.变量与常量 变量名 赋值符号 数据值、变量名、函数名、函数调用、生成式 遇到赋值符号先看符号右侧再看左侧 3.python基本数据类型 int整型、float浮点型、str字符串、list列表、dict字典、tuple元组、set集合、bool布尔值 4.垃圾回收机制 引用计数、标记清除、分代回收 5.用户交互 input\print 格式化输出 6.流程控制 if elif else while else break continue for else break continue range() 7.数据类型常用内置方法 字符串:索引取值切片、len()、strip()、split()、upper()、isdigit() 列表:索引取值切片、len()、append()、insert()、extend()、pop() 字典:按键取值、len()、get()、d[k] = v、keys()、values()、items() 8.字符编码 编码与解码	ASCII GBK UTF UNICODE encode() decode() 9.文件处理 with open(文件路径,模式,encoding=&amp;#39;utf8&amp;#39;) as f:pass 函数 1.</description>
    </item>
    
    <item>
      <title>ATM购物车中文版</title>
      <link>https://jinkes-li.github.io/python/atm%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%B8%AD%E6%96%87%E7%89%88/</link>
      <pubDate>Mon, 31 Oct 2022 22:41:42 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/atm%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%B8%AD%E6%96%87%E7%89%88/</guid>
      <description>APM+购物车 创建目录 创建项目文件ATM 依据软件开发目录 创建bin下的start.py文件 conf下的settings.py文件 core下的scr.py文件 interface下的user_interface文件 shop_interface文件bank_interface文件 lib下的common文件 db目录下的handler文件 readme requriments文件 log目录可以代码创建 在将与用户交互的第一层放入在scr中搭建整体对的框架出来
注册功能 首先获取用户的输入对的用户名及密码 核对二次输入的密码是否正确 正确的话 根据用户名去db目录的handler文件创数据的增删改查 依据模块os 拼接文件目录路径 再依据用户名创建文件的路径 再判断该路径在与不在 在的话输出读取到的对象字典 没有则返回None(这一步得放在创建文件之后 文件没创肯定读取不到) 再去新建用户字典 依据handler建的save将用户字典从写入到文件中则用户注册成功
登入功能 获取用户输入的用户名及密码 用用户名去判断是否能将用户字典读取出来 能读取则判断用户存在 可以从里拿出来密码比对是否正确 正确则登入成功 这时创建的一个全局变量 用来储存登入的用户是谁 因为后面的功能实现都要基于用户是否登入成功 而且是涉及多个功能要用 所以创建装饰器放在lib的common文件中 再依据登入成功去改变全局的字典存储用户名 装饰器再依据全局字典是否登入则判断后面的功能能否实现
查看用户余额 依据全局字典存储了用户登入的用户名 再依据用户名传值给函数去到第二层中的接口层user_interface 将其封装成函数靠用户名 去打开用户的字典读取到用户的余额
查看用户余额 依据全局字典存储了用户登入的用户名 再依据用户名传值给函数去到第二层中的接口层user_interface 将其封装成函数靠用户名 去打开用户的字典读取到用户的余额
提现功能 获取用户需要提现的金额 把当前登录的用户名， 和需要提现的金额传给接口层 获取当前用户的信息 拿到用户的余额和提现额度 用户的余额和 （提现的金额+手续费）做对比 若余额小 则 返回 余额不足 若余额不小 则比较提现金额和 提现额度的大小 若提现额度大 则 余额 - 提现金额 保	存 手续费 为零 返回 提现成功 若提现金额大 则 余额 - 提现金额 - 手 续费 保存 返回 提现成功</description>
    </item>
    
    <item>
      <title>第五周总结</title>
      <link>https://jinkes-li.github.io/python/%E7%AC%AC%E4%BA%94%E5%91%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 30 Oct 2022 18:57:24 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%AC%AC%E4%BA%94%E5%91%A8%E6%80%BB%E7%BB%93/</guid>
      <description>第五周总结 正则表达式
第三方模块
python模块
正则表达式
正则表达式，又称规则表达式,（Regular Expression，在代码中常简写为regex、regexp或RE），是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为&amp;quot;元字符&amp;quot;），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串，通常被用来检索、替换那些符合某个模式（规则）的文本
正则表达式前夕 为什么需要使用正则表达式
1. 这里以京东的注册时需要输入手机号为例 # 1. 获取用户输入 usercode = input(&amp;#39;请输入注册手机号： &amp;#39;) # 2. 分析，手机号为11位，判断位数是否相等11 if len(usercode) == 11: # 3. 判断用户输入的是否为纯数字 if usercode.isdigit(): # 4. 继续分析，手机号一般有很多开头，这里演示188开头 if usercode.startswith(&amp;#39;188&amp;#39;): print(&amp;#39;验证通过&amp;#39;) else: print(&amp;#39;请输入正确的手机号&amp;#39;) else: print(&amp;#39;请输入数字&amp;#39;) else: print(&amp;#39;请输入正确的手机号长度&amp;#39;) # 代码执行结果，只有188开头的手机号码才可以通过注册 请输入注册手机号： 18800000000 验证通过 2. 第一种方式太过于麻烦，接下来使用正则表达式来写 import re # python中使用正则的模块，稍后介绍 user_code = inpot(&amp;#39;请输入手机号&amp;#39;).strip() if re.match(&amp;#39;^188[0-9]{8}$&amp;#39;, user_code) print(&amp;#39;合法的手机号&amp;#39;) else: print(&amp;#39;非法的手机号&amp;#39;) # 代码执行结果 请输入手机号： 18000000000 合法的手机号 字符组 字符组内所有的数据默认都是或的关系 字符组默认匹配规则是一个一个匹配 [0123456789] 匹配0~9任意一个数 [0-9] 匹配0到9任意一个数(缩写) [a-z] 匹配26个小写英文字母 [A-Z] 匹配26个大写英文字母 [0-9a-zA-Z] 匹配数字或者小写字母或者大写字母 特殊符号 特殊符号默认匹配方式是挨个匹配</description>
    </item>
    
    <item>
      <title>Python模块(下)</title>
      <link>https://jinkes-li.github.io/python/python%E6%A8%A1%E5%9D%97%E4%B8%8B/</link>
      <pubDate>Thu, 27 Oct 2022 21:54:09 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E6%A8%A1%E5%9D%97%E4%B8%8B/</guid>
      <description>python模块 hashlib 加密模块
subprocess模块
logging 日志模块
logging模块的实际应用
hashlib加密模块
什么是加密 将明文数据处理成密文数据，确保其他人无法直接得到原本的信息
为什么加密 保证数据的安全性，防止软件或文件被篡改
如何判断数据是否加密 加密后的数据一般都是各种字符的组合，无法是被直接看懂的
密文的长短 密文越长表示使用的加密算法越复杂
基本的加密算法 md5, bash64, hmac, sha系列
# 加密算法的基本操作 import hashlib # 选择需要使用的加密算法，比如下面使用的是md5 md5 = hashlib.md5() # 使用update传入明文数据，可以分段传输也可以单次传输 md5.update(b&amp;#39;hello&amp;#39;) # 需要传入二进制数据 # 获得数据加密后的MD5值 res = md5.hexdigest() print(res) # 5d41402abc4b2a76b9719d911017c592 加密算法补充 1. 加密算法不变，内容不变，结果也相同 import hashlib md5 = hashlib.md5() md5.update(b&amp;#39;wesley&amp;#39;) res = md5.hexdigest() print(res) # 加密后的值 a09f91f8be77e65b371a64bf1d8305c9 # 刚刚提到了多次的分段传入也是没有问题的，下列代码演示 import hashlib md5 = hashlib.md5() md5.update(b&amp;#39;we&amp;#39;) md5.update(b&amp;#39;sl&amp;#39;) md5.update(b&amp;#39;ey&amp;#39;) res = md5.</description>
    </item>
    
    <item>
      <title>第三方模块</title>
      <link>https://jinkes-li.github.io/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Wed, 26 Oct 2022 20:22:04 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/</guid>
      <description>python第三方模块 第三方模块指的是别人写的模块，一般情况下功能都是非常强大的 如果使用第三方模块第一次必须使用pip指令下载后才可以调用
第三方模块的下载方式
下载时可能会出现的问题
爬虫之requests模块
自动化办公openpyxl模块
第三方模块扩展(模块叠模块)
第三方模块的下载方式
1. pip工具， 每个版本的解释器都有pip工具，当电脑上存在多版本解释器时需要知道我们在使用哪一个，为了避免冲突，会在pip工具重新复制一份起别名 2. 在下载模块，使用命令下载 php3 install 模块名 3. 在下载模块时，默认仓库指向的是python的官网，如果下载太慢建议更改为国内 php3 install 模块名 -i 国内仓库地址 4. 在安装模块时，若不想使用最新的模块可以使用==来指定版本 php3 install 模块名==版本号 5. 在编写代码时，pycharm也提供了一些操作界面的安装方式，不太推荐使用，毕竟代码运行的平台大多数还是linux 安装时可能存在的问题 下载第三方模块可能会出现的问题 1.报错并有警告信息 WARNING: You are using pip version 20.2.1; 原因在于pip版本过低 只需要拷贝后面的命令执行更新操作即可 d:\python38\python.exe -m pip install --upgrade pip 更新完成后再次执行下载第三方模块的命令即可 2.报错并含有Timeout关键字 说明当前计算机网络不稳定 只需要换网或者重新执行几次即可 3.报错并没有关键字 面向百度搜索 pip下载XXX报错:拷贝错误信息 通常都是需要用户提前准备好一些环境才可以顺利下载 4.下载速度很慢 pip默认下载的仓库地址是国外的 python.org 我们可以切换下载的地址 pip install 模块名 -i 仓库地址 pip的仓库地址有很多 百度查询即可 清华大学 ：https://pypi.tuna.tsinghua.edu.cn/simple/ 阿里云：http://mirrors.</description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://jinkes-li.github.io/python/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 25 Oct 2022 16:42:45 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>正则表达式 正则表达式前夕
正则表达式之字符组
正则表达式之量词
正则表达式之特殊符号
正则表达式练习
正则表达式贪婪匹配和非贪婪匹配
正则表达式应用
python正则模块re
正则表达式前夕
正则表达式，又称规则表达式,（Regular Expression，在代码中常简写为regex、regexp或RE），是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为&amp;quot;元字符&amp;quot;），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串，通常被用来检索、替换那些符合某个模式（规则）的文本。
1. 例如京东的注册页面，可以检测手机号的输入是否正确，这个功能如何实现 # 这里先不使用正则去使用python代码实现 # 京东注册页面实现手机号检测 # 1. 获取用户输入 usercode = input(&amp;#39;请输入注册手机号： &amp;#39;) # 2. 分析，手机号为11位，判断位数是否相等11 if len(usercode) == 11: # 3. 判断用户输入的是否为纯数字 if usercode.isdigit(): # 4. 继续分析，手机号一般有很多开头，这里演示188开头 if usercode.startswith(&amp;#39;188&amp;#39;): print(&amp;#39;验证通过&amp;#39;) else: print(&amp;#39;请输入正确的手机号&amp;#39;) else: print(&amp;#39;请输入数字&amp;#39;) else: print(&amp;#39;请输入正确的手机号长度&amp;#39;) # 代码执行结果，只有188开头的手机号码才可以通过注册 请输入注册手机号： 18800000000 验证通过 # 如果使用正则这个功能如何书写 import re user_code = input(&amp;#39;请输入手机号： &amp;#39;).strip() if re.match(&amp;#39;^188[0-9]{8}$&amp;#39;, user_code): print(&amp;#39;合法的手机号&amp;#39;) else: print(&amp;#39;非法手机号码&amp;#39;) # 代码运行结果 请输入手机号： 18800000000 合法的手机号 # 接下来我们来学习如何使用正则表达式 正则表达式之字符组 1.</description>
    </item>
    
    <item>
      <title>第四周总结</title>
      <link>https://jinkes-li.github.io/python/%E7%AC%AC%E5%9B%9B%E5%91%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 23 Oct 2022 19:02:45 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%AC%AC%E5%9B%9B%E5%91%A8%E6%80%BB%E7%BB%93/</guid>
      <description>第四周总结
异常处理和生成器对象
模块的概念和使用
编程思想和包的使用
常用的python模块
异常处理
在写程序的过程中可能会报出很多异常，而异常报出之后程序就会停止运行，当时有部分异常是对于用户来说是非致命的，所以这里就需要对一些可能出现的异常进行预测解决方案
常见的异常类型 1. SyntexError # 语法错误 2. indexError # 索引错误 3. nameError # 名字错误 4. keyError # 键错误 5. IndetationError # 缩进错误 异常的语法结构 首先来看一下异常的语法结构
# 单异常解决 try: 待监测的代码 except &amp;#39;接收的异常类型&amp;#39; as e: 解决异常的方案 # 多异常解决，多异常解决和单异常是一样的，只是多放了几个异常类型 try: 待监测的代码 except &amp;#39;第一种异常类型&amp;#39; as e: &amp;#39;解决方案&amp;#39; except &amp;#39;第二种异常类型&amp;#39; as e: &amp;#39;解决方案&amp;#39; # 万能异常，万能异常可以用于接收任何的异常，常用的万能异常接收有Exception和BaseException，这两个可以接收所有的异常 try: 待检测的代码 except Exception e: &amp;#39;解决方案&amp;#39; # try 异常还可以配合else使用，在执行中没有异常else才被执行， try: 待监测的代码 except &amp;#39;异常类型&amp;#39; as e: 解决方案 else: print(&amp;#39;上面全部没有异常我才会执行&amp;#39;) # finally 在使用了finally，无论上面的是否执行finally都会执行 try: 待监测的代码 except &amp;#39;异常类型&amp;#39; as e: 解决方案 else: print(解决方案) finally: print(&amp;#39;上面都执行完了，现在我再执行&amp;#39;) 异常的处理实战 # 异常一，这是由于未调用到变量名导致的 name1 = &amp;#39;wesley&amp;#39; name = &amp;#39;wesley1&amp;#39; try: if name == naeme1: print(&amp;#39;123&amp;#39;) except NameError as e: print(&amp;#39;未定义变量名&amp;#39;) 异常之断言 # 断言是用于预测上面被监测代码的类型，如果断言错误也会报出异常 # 使用 name = &amp;#39;wesley&amp;#39; assert isinstance(name, str) print(&amp;#39;类型为字符串&amp;#39;) # 需要注意，如果name的类型不是字符串，这个时候就会报错 主动抛出异常 try: name = &amp;#39;andy&amp;#39; if name == &amp;#39;andy&amp;#39;: raise Exception(&amp;#39;Error&amp;#39;): else: print(&amp;#39;不是andy，继续run&amp;#39;) 使用异常的注意事项 在写代码的过程中，可以不使用异常就不使用异常 如果必须使用，尽量不要超过10行代码 当代码中有不可预期的异常时再使用 异常的应用 # 使用异常实现for循环 l1 = [11, 22, 33, 44, 55] try: new = l1.</description>
    </item>
    
    <item>
      <title>Python模块上</title>
      <link>https://jinkes-li.github.io/python/python%E6%A8%A1%E5%9D%97%E4%B8%8A/</link>
      <pubDate>Thu, 20 Oct 2022 17:12:26 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E6%A8%A1%E5%9D%97%E4%B8%8A/</guid>
      <description>python模块 os和sys模块
json模块
os和sys模块
os模块主要是针对目前执行文件对操作系统的操作 sys模块主要是正对python解释器操作 os模块的用法 1. 创建目录 os.mkdir(r&amp;#39;d1&amp;#39;) # 当前目录下创建d1，不可以创建多级目录 os.makedirs(r&amp;#39;a1/b1/c1/d1&amp;#39;) # 当前目录下创建多级目录，也可以创建单级目录 2. 删除目录 os.rmdir(r&amp;#39;d1&amp;#39;) # 可以删除单级目录，如果有文件不可以删除，并且不可以删除多级目录 os.removedirs(r&amp;#39;a1/b1/c1/d1&amp;#39;) # 可以删除多成目录，只能删除空目录 3. 列举文件路径下内容名称 print(os.listdir(r&amp;#39;modular&amp;#39;)) # 列出当前目录下的所有文件 4. 删除重命名文件 os.rename(r&amp;#39;test&amp;#39;, &amp;#39;test.py&amp;#39;) # 重命名test文件 os.remove(r&amp;#39;test.py&amp;#39;) # 删除test.py 文件 5. 获取/切换当前工作目录 print(os.getcwd()) # 获取当前工作目录 os.chdir(&amp;#39;..&amp;#39;) # 切换工作目录 6. 动态获取项目根目录 print(os.path.abspath(__file__)) # 获取执行文件的绝对路径 print(os.path.dirname(__file__)) # 获取执行文件所在目录路径 7. 判断路径是否存在(文件/目录) print(os.path.exists(r&amp;#39;osandsys.py&amp;#39;)) # 判断文件是否存在 print(os.path.exists(r&amp;#39;/Users/wesley/PycharmProjects/python-1&amp;#39;)) # 判断路径是否存在 print(os.path.isfile(&amp;#39;osandsys.py&amp;#39;)) # 判断路径是否文件 True print(os.path.isfile(&amp;#39;/Users/wesley/PycharmProjects/python-1&amp;#39;)) # 判断路径是否文件 False print(os.</description>
    </item>
    
    <item>
      <title>编程思想和包的使用</title>
      <link>https://jinkes-li.github.io/python/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%92%8C%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 19 Oct 2022 17:27:15 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E5%92%8C%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>编程思想和包的使用 包的具体使用
编程思想转变
目录开发规范
常用内置模块
collections 时间模块 随机数模块 包的具体使用
虽然python3中不强制要求包里必须要有__init__.py这个文件，但是在写代码时最好将这个文件创建出来，放在代码兼容问题的出现
程序员写包时 ，一般会写很多模块文件，然后将模块在__init__.py文件中引用，这样我们在使用的时候就可以通过导入这个包然后调用包里的模块文件 编程思想 编程思想就是指我们在运到一个编程问题时的想法和思路，比如如果规划程序的架构方便后期更改，如何做到高聚合低耦合的代码架构，不具备编程思想的人只能写一些简单逻辑的代码，当这个程序员具备了编程思想后，很多问题都会迎刃而解 如何学习编程思想，就是多写多练，参考优秀代码，思想碰撞，参考其他人看待问题的逻辑，完善自身
软件开发目录 在我们开始实现一个复杂性系统时，首先考虑的并不是使用什么技术去实现，而是分析需求，分类需求并设计合理的项目目录结构
# 通用性软件开发目录 wesley@------*****------ ⮀ ~/Desktop ⮀ tree myproject myproject # 项目目录 ├── README # 项目说明文件 ├── bin # 执行文价夹 │ └── start.py ├── conf # 配置文件 │ └── settings.py ├── core # 源码，主要的功能代码 │ └── src.py ├── db # 数据库相关操作代码 │ ├── db_handler.py │ └── userinfo.txt ├── interface # api文件夹 │ ├── accpunt.py │ ├── goods.</description>
    </item>
    
    <item>
      <title>模块的概念与使用</title>
      <link>https://jinkes-li.github.io/python/%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 18 Oct 2022 17:09:09 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>调包侠之Python模块 索引取值和迭代取值的差异
模块简介
导入模块的两种句式
导入模块句式补充
循环导入问题解决策略
判断文件类型
模块的查找顺序
模块的绝对导入和相对导入
包的概念
索引取值和迭代取值的差异
两者的使用主要是应用在不同的应用场景
索引取值 索引取值可以在不同的位置反复的取值 不支持无序类型的取值 迭代取值 只能重前往后取值且无法后退 支持对无序数据取值 模块介绍 模块的本质就是内部具有一定功能的py文件 python的黑历史，在刚开始不火的时候被人戏称为调包侠，随着越来越多的程序员加入，先在看到python都要称一声调包侠 python模块的表现形式 python文件也可以称为模块文件 包含多个python文件的文件夹被称为包，（python2中的包文件具有__init__.py文件） 已经编译为共享库或DLL的c或者C++扩展 使用C编写并链接到python解释器的内置模块 模块分类 自定义模块 自定义模块就是程序员自己写的py文件 内置模块 python解释器自带的模块 第三方模块 由一些开发者大佬写的模块，我们可以直接使用pip安装并调用 导入模块的两种句式 注意： 这里一定要注意谁是被执行文件
import modular_name from modular_name import parameter 1. import modular_name &amp;#34;&amp;#34;&amp;#34; 使用import导入模块的原理 案例： 现在run.py作为被执行文件需要导入同级目录下的register.py并调用其中的userinfo列表，代码如下： # run.py # 作为被执行文件 import register print(register.userinfo) # register.py # 作为模块 userinfo = [&amp;#39;wesley&amp;#39;, &amp;#39;otheruser&amp;#39;] def register(): &amp;#34;&amp;#34;&amp;#34;注册用户&amp;#34;&amp;#34;&amp;#34; pass 1. 被执行文件run运行，创建名称空间 2.</description>
    </item>
    
    <item>
      <title>异常与生成器</title>
      <link>https://jinkes-li.github.io/python/%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Mon, 17 Oct 2022 18:23:39 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>异常处理和生成器对象 异常语法结构
异常处理实战
生成器对象
生成器实现range方法
生成器表达式
生成器笔试题
异常简介 异常的分类：
语法错误 逻辑错误 异常结构 定位信息 错误类型 错误信息 异常常见错误类型 1. SyntexError 2. NameError 3. IndexError 4. KeyError 5. IndetationError 异常语法结构 try: 待监测的代码 except 错误类型 正对上述错误类型指定的方案 针对不同的错误类型指定不同的方案 try: 待监测的代码 except 错误类型1 as e: # e 就是报的错误类型 错误方案1 except 错误类型2 as e: 错误方案2 except 错误类型3 as e: 错误方案3 万能异常Exception/BaseException # 万能异常 try: 待监测代码 except Exception as e: 常见报错都都会执行此方案 # 结合else使用 try: 待监测代码 except Exception as e: 错误执行方案 else: # 在上面的代码正常执行没有执行异常方案时执行else print(&amp;#39;哈哈哈，上面没有异常&amp;#39;) # 结合finally try: 待监测代码 except Exception as e: 异常解决方案 else: print(&amp;#39;上面正常执行没有错误我就执行&amp;#39;) finally: print(&amp;#39;上面的先上，无聊他们如何我都执行&amp;#39;) 断言 断言：预测上面出现的错误类型，并确定错误异常类型</description>
    </item>
    
    <item>
      <title>第三周总结</title>
      <link>https://jinkes-li.github.io/python/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 16 Oct 2022 21:31:48 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/</guid>
      <description>第三周总结 文件操作
函数
装饰器
基础算法及表达式
可迭代对象
文件操作
使用python炒作文本文件
创建或打开文件 python中的两种文件操作方式 1. open() # 直接使用open打开文件需要使用close方法关闭文件不推荐使用，仅仅演示 file1 = open(r&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) print(file1.read()) file1.close() 2. with open() # with会自动帮助我们关闭文件，推荐使用 with open(r&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) as f print(f.read()) - 注意在写路径时最好带上r参数，防止win系统下的文件路径被解析为其他含义 编辑文件 文件的读写模式
r - read 只读模式：只能读不能写 w - write 只写模式：只能写不能读，如果不对光标进行操作，w操作会将原文件全部覆盖 a - append 只追加模式，只能在文件的末行追加 r r (读模式，只读不写) # 如果文件不存在直接报错 with open(r&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, &amp;#39;encoding&amp;#39;=&amp;#39;utf8&amp;#39;) as f: print(f.read()) -w
w (只写不读) # 文件不存在则会新建 whth open(r&amp;#39;a.txt&amp;#39;, &amp;#39;w&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) as f: f.</description>
    </item>
    
    <item>
      <title>内置函数及for循环原理</title>
      <link>https://jinkes-li.github.io/python/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%8F%8Afor%E5%BE%AA%E7%8E%AF%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 14 Oct 2022 21:36:14 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%8F%8Afor%E5%BE%AA%E7%8E%AF%E5%8E%9F%E7%90%86/</guid>
      <description>python中常见内置函数 python常见内置函数 可迭代对象 迭代器对象 for 循环的本质 python中的内置函数 python中的内置函数非常的多，这里主要介绍常用的一部分
序号 内置函数名 功能 1 abs() 求绝对值 2 all() ， any() 判断容器类型中所有的数据值对应的布尔值是否为Ture 3 bin()，oct(), hex, 进制转换 4 int() 进制转换，其他进制转十进制 5 bytes() 类型转换 6 Callable() call在IT专业名词中翻译成调用 7 chr(),ord() 依据ASCII码表实现字符与字符的转换 8 dir() 获取对象内部可以通过句点符获取的数据 9 divmod() 获取除法之后的整数和与数 10 enumerate() 枚举 11 eval(),exec() 能够识别字符串中python代码并执行 12 hash() 对数据进行hash加密，返回一串哈希值 13 help() 查看帮助信息 14 Isinstance(123,int) True 15 isinstance(123, str) False 16 pow() 幂指数 17 round() 四舍五入 可迭代对象 迭代就是更新换代，每次迭代都需要基于上一次的结果 比如说我们手机上的软件更新，其实这就是迭代的过程 # 代码实现 1.</description>
    </item>
    
    <item>
      <title>常见算法及表达式</title>
      <link>https://jinkes-li.github.io/python/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%8F%8A%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Thu, 13 Oct 2022 21:09:37 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%8F%8A%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>常见算法及表达式 算法之二分法 三元表达式 各种生成式 匿名函数 重要的内置函数 常见的内置函数 算法简介之二分法 算法简单理解就是解决某些特定场景的特定方法 常见的算法有，二分法，冒泡，排序，红黑树，B+Tree 算法的应用场景：
淘宝搜索产品后会一直推荐同产品给用户，这是淘宝的推荐算法 抖音，用户在使用抖音时，算法会将每个视频分类，具有相同喜欢视频类型的人群分类，从而实现对视频和人群进行不同的流量推送 二分法 二分法使用，待查找的数据集必须有序 二分法的缺陷，如果结果数据再初始位置，或者末尾位置，效率很低 基础原理： 对需要处理的数据进行中间值一分为二，对比需要查找的结果值，与前后两位值对比，如果结果值闭前者小，则对前面的数据再次进行二分处理依次类推，若结果值比前者大，则用二分的方式对后续的数据进行处理。
python实现二分法 # 需要在以下数据中找到987 l1 = [12, 21, 32, 43, 56, 76, 87, 98, 123, 321, 453, 565, 678, 754, 812, 987, 1001, 1232] def look(l1, res_num): median = len(l1) // 2 # 判断，列表中的索引的值是否大于传入的值 if res_num &amp;gt; l1[median]: # 如果大于，将原列表中的后面的值取出赋值为new_list new_list = l1[median:] # 返回函数重新调用 return look(new_list, res_num) elif res_num &amp;lt; l1[median]: new_list = l1[:median] return look(new_list, res_num) else: print(&amp;#39;找到了&amp;#39;) look(l1, 21) 三元表达式 主要作用为简化代码</description>
    </item>
    
    <item>
      <title>Pythons新手村Boss装饰器</title>
      <link>https://jinkes-li.github.io/python/pythons%E6%96%B0%E6%89%8B%E6%9D%91boss%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Tue, 11 Oct 2022 22:49:12 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/pythons%E6%96%B0%E6%89%8B%E6%9D%91boss%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <description>python新手村Boss装饰器 装饰器简介
无产装饰器
有参装饰器
装饰器模版
装饰器语法糖及修复技术
多层装饰器
装饰器简介
概念： 在不改变被装饰器源代码和调用方式的情况下给被装饰的对象添加新的功能 装饰器的本质： 装饰器并不是一个新的技术，而是由函数参数，名称空间，函数名多种用法，闭包函数所组成到一起的结果 口诀： 对修改封闭，对扩展开放 储备知识 这里需要先需要提前使用一个time包来实现一下时间戳功能，代码如下
时间相关操作(time) import time # time 获取时间戳 print(time.time()) # 时间戳(距离1970-01-01 00:00:00所经历的秒数) time.sleep(3) # 程序暂停3秒再运行 print(&amp;#39;这里是代码体&amp;#39;) print(time.time()) # 代码运行结束的时间戳 1665485696.789707 这里是代码体 1665485699.794832 2. 小程序，获取当前代码运行的时长 import time count = 0 start_time = time.time() while count &amp;lt; 10000000: print(&amp;#39;运行中...&amp;#39;) count += 1 end_time = time.time() print(f&amp;#39;当前程序运行需要的时长为{end_time - start_time}&amp;#39;) 当前程序运行需要的时长为16.997233867645264 # 这里是time的用法 装饰器的推导流程（重要） *1*. 第一部分 import time def index(): time.</description>
    </item>
    
    <item>
      <title>Python函数(下)</title>
      <link>https://jinkes-li.github.io/python/python%E5%87%BD%E6%95%B0%E4%B8%8B/</link>
      <pubDate>Mon, 10 Oct 2022 19:49:24 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E5%87%BD%E6%95%B0%E4%B8%8B/</guid>
      <description>python函数（下） 本文将链接上一章的python函数的参数继续讲下去
函数的参数
名称空间与作用域
global与nonlocal
函数名的多种用法
函数的参数
函数参数的概念
形式参数 函数定义阶段括号内填写的参数 实际参数 函数调用阶段括号内填写的参数 1. 位置参数 位置形参 在定义函数时，在括号内从左到右依次填写的变量名 # 如何子代码只有一行或者很简短可以直接在冒号后面编写不用换行 def function(a, b, c):pass pass 位置实参 在函数调用时，在括号内依次从左往右填写的参数值 function(1, 2, 3) 位置参数的注意事项 # 定义一个函数并且写上ab两个位置形参 def func1(a, b): pass(a, b) 1. func1(1, 2) # 按照位置从左往右依次传值 2. func1(1) # 少了一个传入的值，报错 3. func1(1, 2, 3) # 多了一个值，还是报错 4. func1(b=1, a=2) # 关键字参数，将1传给b，2传给a 5. func1(b=1, 2) # 关键字参数一定要跟在位置参数后面否则会报错 6 func1(2, b=1) # 这里关键字参数在位置参数后面就可以正常传入 7. func1(1, a=2, b=3) # 同一个形参在调用的时候不能传入多个值 name = &amp;#39;wesley&amp;#39; pwd = 123 8.</description>
    </item>
    
    <item>
      <title>Python函数(上)</title>
      <link>https://jinkes-li.github.io/python/python%E5%87%BD%E6%95%B0%E4%B8%8A/</link>
      <pubDate>Sun, 09 Oct 2022 16:19:35 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E5%87%BD%E6%95%B0%E4%B8%8A/</guid>
      <description>函数 引言：
函数就相当于提前定义的工具，在使用时可以直接调用工具使用 函数比较类似于循环的代码，都是重复调用一个功能性问题，主要区别如下
循环是相同的代码在相同的位置反复执行 函数是相同的代码在不同的位置反复调用 函数的语法结构 函数的定义与调用 函数的分类 函数的返回值 函数的参数 函数的语法结构 def def_name(): # 关键字，函数名，是否带参数 &amp;#34;&amp;#34;&amp;#34; 打印123，这里主要是对函数功能的描述 &amp;#34;&amp;#34;&amp;#34; print(123) #函数代码体 return 456 # 返回值 1. def 关键字 def关键字就是用来定义函数的 2. 函数名 函数名就相当于我们使用的变量名需要见名知意 3. () 参数 函数参数主要是用于接受外部数据传入内部给括号里面的参数使用 1. 形参： 在函数定义阶段，函数的括号中写入的参数叫做形参 2. 实参： 在函数调用阶段，被调用的函数中写入的数据被称为实参 4. 函数注释 函数注释是用于描述这个函数的功能 5. 函数代码体 函数代码体是实现一个功能的具体代码 6. return 返回值 调用函数后返回给用户的返回值，可有可无需要看具体使用 函数的定义与调用 # 函数的定义 def print_def(): &amp;#34;&amp;#34;&amp;#34; 这是一个打印123的功能 &amp;#34;&amp;#34;&amp;#34; print(123) # 函数的调用，函数的调用直接使用函数名加括号调用 print_def() &amp;#34;&amp;#34;&amp;#34; 注意： 1. 函数在定义阶段python只会检查语法，并不会执行 2. 函数需要先定义再调用 &amp;#34;&amp;#34;&amp;#34; 函数的分类 # 函数的三分类 1.</description>
    </item>
    
    <item>
      <title>文件操作方法</title>
      <link>https://jinkes-li.github.io/python/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 09 Oct 2022 01:29:28 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95/</guid>
      <description>引言:
平时操作文件都是在计算机中直接新建或编辑文件，这种就类似操作系统直接给我们创建了一个快捷方式，可以直接对硬盘进行操作，今天这里介绍如何使用python代码来对一个文件进行操作
文件操作简介 定义： 文件就是操作系统提供的直接操作硬盘的快捷方式 文件的操作流程 创建或打开文件 编辑文件 保存文件 关闭文件 # Python代码操作文件的语法 # 方式一：（不推荐使用，需要写close来关闭打开的文件） l1 = open(&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) print(l1.read()) l1.close() # 方式二： （推荐使用，with会自动帮助我们关闭文件） with open(&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) as f: print(f.read()) &amp;#34;&amp;#34;&amp;#34; 注意： 如果对文件进行操作时使用到了反斜杠，如 &amp;#39;C：/admin/a.txt&amp;#39;，这里则需要使用&amp;#39;r&amp;#39;将反斜杠的特殊含义转义掉，仅仅作文一个源字符使用 &amp;#34;&amp;#34;&amp;#34; 文件的读写模式 r &amp;ndash; read 只读模式： 只能读不能写 w &amp;ndash; write 只写模式： 只能写不能读，需要注意如果不对光标进行操作。w操作会将原本文件中存在的数据全部覆盖 a &amp;ndash; append 只追加面膜是 ：只能在文件最后追加 read r 模式 read r 模式 # 如果文件不存在会直接报错 with open(r&amp;#39;a.txt&amp;#39;, &amp;#39;r&amp;#39;, encoding=&amp;#39;utf8&amp;#39;) as f: print(f.read()) write w 模式</description>
    </item>
    
    <item>
      <title>第二周总结</title>
      <link>https://jinkes-li.github.io/python/%E7%AC%AC%E4%BA%8C%E5%91%A8%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 07 Oct 2022 20:14:40 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%AC%AC%E4%BA%8C%E5%91%A8%E6%80%BB%E7%BB%93/</guid>
      <description>引言. 本文对Python知识的的基础阶段整理归纳
基本数据类型 用户交互与格式化输出运算符 赋值方式 垃圾回收以及流程控制 For循环和数据类型方法 数据类型内置方法理论 数据类型和字符编码 基本数据类型 Python中不同的数据需要有不同的数据类型来表示，用于更好的读取和修改
1.1 布尔值（bool） 布尔值只有两个状态，True和Fales ，当数据为真时结果为True，数据为假时结果为Fales
注意： Python中有一些数据默认值就为False，比如 0 ，None， &amp;lsquo;&amp;rsquo;, {}, [], 这些数据类型如果 没有数据默认为False，除了这些其他基本都为True 一般我们也可以使用变量来定义布尔值，比较建议的名称为is开头。
1.2 字符串 （str） 字符串就是使用单引号或者双引号包含起来的字符就是字符串，字符串中都是文本数据，无法用于计算
1.3 整型 （int） 整型： 整型就是整数，如 0， 1 ，2 等，可用用于运算和条件判断
1.4 浮点型 （foalt） 浮点型： 浮点型就是小数，比如 3.14等
1.5 列表 （list） 列表: 列表是使用中括号包含起来的数据，并以逗号分隔，可以存放多种数据类型，列表是有序的，可以通过索引来取值
1.6 字典 （dict） 字典： 使用花括号括起来的数据，里面同样可以存放多种类型的数据，同时需要注意的是字典是以键值对来存放数据的，并且字典无序，只能通过键来取值
1.7 元组 （tople） 元组： 使用小括号包含起来的数据，数据可以是多种数据类型，元组索引对应的数据值不可以修改，但是如果这个数据值为列表或者字典等，其中列表或者字典的值是可以修改的，元组这里同样有索引的概念
1.8 集合 （set） 集合： 集合与字典一样同样使用花括号来定义，与之不同的是，字典存放数据需要以键值对的方式存放，集合中的数据使用逗号分隔，集合内存放的数据只能是不可变类型，并且在使用集合时，一般只应用于去重和关系运算
用户交互与格式化输出运算符 2.1 用户交互 用户交互就是让与计算机的交流通讯，让计算机理解我们需要做什么
# 关键字 1.</description>
    </item>
    
    <item>
      <title>数据类型和字符编码</title>
      <link>https://jinkes-li.github.io/python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</link>
      <pubDate>Fri, 30 Sep 2022 17:35:33 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</guid>
      <description>python 数据类型操作 今日内容 字典相关操作 元组相关操作 集合相关操作 字符编码(理论) 字典操作 1. 类型转换，字典的转换一般不使用关键字，而是自己手动转 dict() 2. 字典需要掌握的操作 # 原始数据 user_dict = {&amp;#39;username&amp;#39;: &amp;#39;jason&amp;#39;, &amp;#39;password&amp;#39;: 123, &amp;#39;hobby&amp;#39;: [&amp;#39;read&amp;#39;, &amp;#39;music&amp;#39;, &amp;#39;run&amp;#39;] } 2.1 按key取值（不推荐使用，如果这个key不存在会报错） print(user_dict[&amp;#39;username&amp;#39;]) # username jason jason 2.2 使用内置方法get取值（推荐使用） 2.2.1 使用get获取已经存在的key值 print(user_dict.get(&amp;#39;username&amp;#39;)) jason 2.2.2 使用get获取不存在的值 print(user_dict.get(&amp;#39;age&amp;#39;)) None 2.2.3 使用get获取不存在的值，并通过第二个参数设定默认返回值 print(user_dict.get(&amp;#39;age&amp;#39;, &amp;#39;False&amp;#39;)) False 3.1 字典修改数据值，和列表的重新赋值类似 print(id(user_dict)) user_dict[&amp;#39;username&amp;#39;] = &amp;#39;wesley&amp;#39; print(id(user_dict), user_dict) 4337316352 # 从内存ID上看，字典是一个可变参数 4337316352 {&amp;#39;username&amp;#39;: &amp;#39;wesley&amp;#39;, &amp;#39;password&amp;#39;: 123, &amp;#39;hobby&amp;#39;: [&amp;#39;read&amp;#39;, &amp;#39;music&amp;#39;, &amp;#39;run&amp;#39;]} 3.2 如果修改的key并不存在，则会新建 user_dict[&amp;#39;age&amp;#39;] = 18 print(user_dict) {&amp;#39;username&amp;#39;: &amp;#39;jason&amp;#39;, &amp;#39;password&amp;#39;: 123, &amp;#39;hobby&amp;#39;: [&amp;#39;read&amp;#39;, &amp;#39;music&amp;#39;, &amp;#39;run&amp;#39;], &amp;#39;age&amp;#39;: 18} 3.</description>
    </item>
    
    <item>
      <title>Python数据类型内置方法理论</title>
      <link>https://jinkes-li.github.io/python/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E7%90%86%E8%AE%BA/</link>
      <pubDate>Thu, 29 Sep 2022 20:51:22 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E7%90%86%E8%AE%BA/</guid>
      <description>Python数据类型内置方法和理论 引言： Python自身对数字的敏感度比较低（精确度低） 如果是用在数据分析和金融量化方向，可以使用第三方包模块numpy
本文内容
数据类型内置方法理论 进制数转换 整型相关操作 浮点型相关操作 字符串相关操作 列表相关操作 数据类型内置方法理论 前面文章所提到的每一种数据类型本身都包含有一系列的操作方法，内置方法，是自身带的功能 Python中的数据类型调用内置方法的统一句式为: &amp;ldquo;.&amp;quot;:句点符 &amp;lsquo;wesley&amp;rsquo;.字符串的内置方法 str. 字符串内置方法 数据类型的内置方法比较的多，其中有一些经常使用的以及部分不经常使用的，需要在工作中使用，并且熟悉 进制数转化 开头前两位代表的是转换后表示的进制数 0b代表的是二进制 0o代表的是八进制 0x代表的是十六进制 # 代码实例 # 十进制转换其他进制 # 十转二 print(bin(100)) 0b1100100 # 十转八 print(oct(100)) 0o144 # 十转十六 print(hex(100))i 0x64 # 如果需要八进制转换成其他进制直接反打就可以了 # 二转十 print(int(0b1100100), 2) 100 2 # 八转十 print(int(0o144), 8) 100 8 # 十六转十 print(int(0x64), 16) 100 16 整型的相关操作 类型转换（可以将其他类型转换为整型） int(其他数据类型)，原始数据为浮点型可以直接转换，如果是字符串必须满足内部是纯数字才可以 # 代码实例 # str转int，注意字符串是不可变类型，这里需要重新赋值 a = &amp;#39;1111&amp;#39; a = int(a) print(type(a)) &amp;lt;class &amp;#39;int&amp;#39;&amp;gt; # float转int, 注意在float转int的时候int方法会将小数点后面的数据全部切除，而不是四舍五入，并且如果字符串中存在多个小数点，int无法识别并转换 a = 11.</description>
    </item>
    
    <item>
      <title>For循环和数据类型方法</title>
      <link>https://jinkes-li.github.io/python/for%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 28 Sep 2022 18:58:47 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/for%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95/</guid>
      <description>while 循环补充说明 流程控制之for循环 while循环之死循环
真正的死循环一旦执行，cpu功耗会急剧上升 # 死循环 while True: i = 99 ** 99 print(i) while嵌套及全局标志位
注意： 一个break只能结束它所在的那一乘循环 注意：有几个while的嵌套，如果想一次性结束就应该写几个break 注意：如果不想反复的写break，可以使用全局标志位，就是在循环开始之初，定义一个变量为True，如果需要跳出while循环把这个变量赋值为False即可 is_flag = True # 这里定义一个全局标志位 while is_flag: # while的条件是如果is_flag = True就运行False就不运行 username = input(&amp;#39;username&amp;gt;&amp;gt;&amp;gt;:&amp;#39;) password = input(&amp;#39;password&amp;gt;&amp;gt;&amp;gt;:&amp;#39;) if username == &amp;#39;jason&amp;#39; and password == &amp;#39;123&amp;#39;: while is_flag: # 判断is_flag cmd = input(&amp;#39;请输入您的指令&amp;gt;&amp;gt;&amp;gt;:&amp;#39;) if cmd == &amp;#39;q&amp;#39;: # 这里判断我们输入的命令是什么，如果为q 直接将is_flag 从新赋值为False is_flag = False print(&amp;#39;正在执行您的指令:%s&amp;#39; % cmd) else: print(&amp;#39;用户名或密码错误&amp;#39;) 流程控制之for循环</description>
    </item>
    
    <item>
      <title>垃圾回收以及流程控制</title>
      <link>https://jinkes-li.github.io/python/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Tue, 27 Sep 2022 22:10:23 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>Python垃圾回收以及流程控制 垃圾回收 流程控制理论 流程控制之分支结构 流程控制之循环结构 垃圾回收机制 在不分语言中，内存空间的申请和释放都需要程序员自己写代码才可以完成，但是Python这里不需要，有自身的垃圾回收机制自动管理
引用计数 引用计数，每一个变量值都有对应的计数值，每增加一个变量的引用，计数值则会加一，每减少一个引用计数值则会减一， 当引用值等于0时，就会触发垃圾回收机制 引用计数-原理图 标记清除 标记清除主要针对循环引用的问题 # 代码实例 l1 = [11, 22] # 引用计数1 l2 = [33, 44] # 引用计数1 # 循环引用 l1.append(l2) # l1 = [11, 22, [33, 44]] # 引用值为2 l2.append(l1) # l2 = [33, 44, [11, 22]] # 引用值为2 del l1 # 断开变量名l1与列表的绑定关系，引用值变更为1 del l2 # 断开变量名l2与列表的绑定关系，引用值变更为1 # 当内存占用到达临界值的时候，程序会自动停止，然后扫描程序中所有的数据，并给只产生循环引用的数据打上标记，之后一次性清除 标记清除-原理图
分代回收 用的越久的对象，被回收的可能性越小 请直接看原理图 分代原理图 流程控制理论 在编程的世界中下列三者会出现混合使用
Python代码中建议使用空格表示代码的从属关系，建议使用4个空格
从属关系：缩进的代码（子代码）是否执行取决于上层代码，并不是所有的代码都有子代码
如果多行子代码同属于一个父代码，那么这些子代码需要保持相同的缩进
当一行代码需要编写子代码时，必须以冒号结尾</description>
    </item>
    
    <item>
      <title>用户交互与格式化输出运算符</title>
      <link>https://jinkes-li.github.io/python/%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Mon, 26 Sep 2022 21:25:44 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>Python 本篇文章接着上一个文章继续介绍Python
Python基本的数据类型
与用户交互
格式化输出
基本运算符
多种赋值方式
逻辑运算符
成员运算符
身份运算符
1. Python基本数据类型 布尔值 （bool） 定义：用来判断事务的对错，是否可行，应用与流程控制中 布尔值只有两种状态 True 真的，可行的，对的 False 假的，不可行的，错的 Python中所有的数据都是自带布尔值的，自带布尔值的数据有下列两种 布尔值默认为False的数据有：0 None &amp;rsquo;&amp;rsquo; [] {} 布尔值默认为True的数据有：一般除了上面的都是True 布尔值的变量名一般推荐使用is开头 # 代码实例 is_boo1f = False is_boolt = True 小知识： 在企业中一般说的数据库数据伪删除使用的就是类似这种判断逻辑。
# 代码实例 # 一般企业提供的账号注销功能就是使用布尔值判断逻辑 # 比如下列表格中 is_delete 字段0代表着账户存在，字段1代表账户被删除，其实只是修改李程序取值的逻辑，并未删除实际数据 id	username	password phone is_delete 1 jason	123	110 1 2	kevin	321	120	0 # 一般这种方式大多应用于数据库中 元组（tuple） 定义： 小括号括起来 内部存放多个数据值 数据值与数据值之间逗号隔 开 数据值可以是任何数据类型 被称为不可变列表，是因为元组内存放的地址不能修改 # 代码实例 # 列表与元组的对比 # 列表使用[]进行定义 l1 = [11, 22, 33] # 定义一个列表并赋值给l1 l1[0] = 123 # 使用重复赋值将123替换到l1列表的0号索引 print(l1[0]) # 这里发现最终打印的123，而不是11，所以列表值是可变的 123 ​ 列表修改数据图表参考如下</description>
    </item>
    
    <item>
      <title>周末总结</title>
      <link>https://jinkes-li.github.io/python/%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 25 Sep 2022 17:05:19 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93/</guid>
      <description>周末总结 硬件总结 计算机基础知识 安装Pycharm 遇见Python Markdown文档编写 计算机基础硬件 CPU
控制器
调度计算机硬件之间的工作，相当于人类的大脑
运算器
在计算机中负责数学运算以及逻辑运算，同样相当于人类的大脑
存储
内存
基于电工作，内存将磁盘中的数据加载到自身于CPU交互，数据仅次于 CPU，但是断电未持久化的数据将会丢失
磁盘 将内存需要存储的数据，在磁盘中永久的存储下去
输入设备 计算机中的键盘鼠标，扫描仪等，都属于输入设备，是将外界信息录入计算机的一种设备
输出设备 将计算机中的数据输出的设备被称为输出设备，例如显示器，投影机等
计算机基础知识 路径 路径就是计算机中用来定位资源的路径，C:\user\admin\a.txt 这就是一个文件的路径
相对路径 相对路径就是具有参照物的路径，可以不用从根目录开始寻找 绝对路径 绝对路径就是需要从根路径开始寻找 环境变量 当系统需要寻找一个文件时会先寻找当前路径，如果当前路径寻找不到就	会寻找系统中的环境变量，环境变量相当于告诉计算机，如果这个文件找不	到就去环境变量的这个文件下寻找
进制
二进制 0 1 10 11 ，0和1 就是二进制用来表示高低电平，可以直接被计算机识别，二进制逢二进一 八进制 0 1 2 3 4 5 6 7 ，0到7就是八进制，逢八进一 十进制 0 1 2 3 4 5 6 7 8 9 ，0-9时十进制，逢十进一 十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f ，0 -f是十六进制，逢十六进一 单位换算</description>
    </item>
    
    <item>
      <title>遇见Python</title>
      <link>https://jinkes-li.github.io/python/%E9%81%87%E8%A7%81python/</link>
      <pubDate>Fri, 23 Sep 2022 19:12:39 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E9%81%87%E8%A7%81python/</guid>
      <description>遇见Python 引言：
接下来本文开始将在学习和工作中记录Python的使用
本文内容
Python语法-注释
关键字
变量与常量
​	变量与常量的基本使用
​	变量规范和命名规则
数据类型
​	整型（int）
​	浮点型（float）
​	字符串（str）
​	列表（list）
​	字典（dict）
PEP8规范
Python语法-注释
注释的意思就是被注释的代码不执行，参见下列示例
注释符号 # &amp;#39;&amp;#39;&amp;#39; &amp;#39;&amp;#39;&amp;#39; &amp;#34;&amp;#34;&amp;#34; &amp;#34;&amp;#34;&amp;#34; # 打印123 print(123) # 这一行是代码，代码后面也可以加注释 &amp;#39;&amp;#39;&amp;#39; 123 456 这是多行注释，被包含的内容都不执行 &amp;#39;&amp;#39;&amp;#39; &amp;#34;&amp;#34;&amp;#34; 666 这也是多行注释，被包含的内容都不执行 &amp;#34;&amp;#34;&amp;#34; 关键字 # 具有一定功能的特定单词，例如 print(&amp;#39;打印&amp;#39;) print(&amp;#39;123&amp;#39;) 123 # 查看数据类型 type() name = &amp;#39;wesley&amp;#39; print(type(name)) &amp;lt;class &amp;#39;str&amp;#39;&amp;gt; # 通过输出结果可以看出数据类型为str 也就是字符串 变量与常量
变量就是会变化的量，常量就是不会变化的量或者说长时间不会改变的量
​	变量：比如说我们的年龄会随着每年增涨，今年18，明年19，年龄在不断发生变化，这就是变量
​	常量：比如我们的身份证号码就属于常量，无论什么时间身份证号都不会发生变化，这就是常量
变量的命名规则和特性</description>
    </item>
    
    <item>
      <title>JetBrains IDE 产品使用</title>
      <link>https://jinkes-li.github.io/python/jetbrains-ide-%E4%BA%A7%E5%93%81%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 23 Sep 2022 19:03:58 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/jetbrains-ide-%E4%BA%A7%E5%93%81%E4%BD%BF%E7%94%A8/</guid>
      <description>JetBrains IDE 产品使用（Pycharm ） ​	引言：本文使用的系统为 MacOS 12.5 M1
接下来我们需要写Python相关的代码这里强烈推荐使用Pycharm，由于免费的社区版某些功能没有，这里我们使用Pycharm专业版（仅测试使用）
JetBrains官网 下载安装你需要的 IDE这里下载PyCharm，下载完成后直接双击安装 下载 Jetbrains.zip，下载后解压，得到 fineagent.jar，将该文件复制到 /Users/你的用户名/ 文件夹下
#使用cd进入到Users下面的你电脑的用户名下 wesley@wesleydeMacBook-Pro ⮀ ~ ⮀ cd /Users/wesley/ #将下载的fineagent.zip 复制到当前目录并解压，注意：我这里是吧fineagent.zip下载到了Downloads这个目录下，请以你的下载目录为准 wesley@wesleydeMacBook-Pro ⮀ ~ ⮀ cp /Users/wesley/Downloads/fineagent.zip ./ &amp;amp;&amp;amp; unzip fineagent.zip &amp;amp;&amp;amp; ll -rw-r--r--@ 1 wesley staff 35K Aug 15 10:21 fineagent.jar wesley@wesleydeMacBook-Pro ⮀ ~ ⮀ 打开访达，点击左侧的 应用程序 找到 PyCharm，在 PyCharm 图标上右键，点击 显示包内容
进入 Contents 目录，再进入 bin 目录，使用文本编辑器打开 pycharm.vmoptions文件
5.在最后面添加 -javaagent:/Users/你的用户名/fineagent.jar，记得修改一下你的用户名。
运行 PyCharm, 选择 Activate PyCharm，再点击 Activation Code</description>
    </item>
    
    <item>
      <title>基础和py解释器</title>
      <link>https://jinkes-li.github.io/python/%E5%9F%BA%E7%A1%80%E5%92%8Cpy%E8%A7%A3%E9%87%8A%E5%99%A8/</link>
      <pubDate>Thu, 22 Sep 2022 20:12:55 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%9F%BA%E7%A1%80%E5%92%8Cpy%E8%A7%A3%E9%87%8A%E5%99%A8/</guid>
      <description>引言：
​	继续接着上一个文章干活哈
本文内容： 计算机三大核心硬件部分详解 操作系统 编程与编程语言 编程语言的发展史 编程语言的分类 Python解释器 Python解释器多版本共存 计算机主要三核心硬件详解 CPU ​ 中央处理器（CPU），是电子计算机的主要设备之一，电脑中的核心配件。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU是计算机中负责读取指令，对指令译码并执行指令的核心部件。中央处理器主要包括两个部分，即控制器、运算器，其中还包括高速缓冲存储器及实现它们之间联系的数据、控制的总线。电子计算机三大核心部件就是CPU、内部存储器、输入/输出设备。中央处理器的功效主要为处理指令、执行操作、控制时间、处理数据。
存储器 ​	按信息的可保存性分类
​	非永久记忆的存储器：断电后信息即消失的存储器。
​	永久记忆性存储器：断电后仍能保存信息的存储器。
​	按在计算机系统中的作用分类
​	主存储器（内存）：用于存放活动的程序和数据，其速度高、容量较小、每位价位高。
​	辅助存储器（外存储器）：主要用于存放当前不活跃的程序和数据，其速度慢、容量大、每位价位低。
​	缓冲存储器：主要在两个不同工作速度的部件起缓冲作用。
输入设备 ​	输入设备是向计算机输入数据和信息的设备，是计算机与用户或其他设备通信的桥梁，是用户和计算机系统之间进行信息交换的主要装置之一。输入设备的任务是把数据、指令及某些标志信息等输送到计算机中去。键盘、鼠标、摄像头、扫描仪、光笔、手写输入板、游戏杆、语音输入装置等都属于输入设备（Input Device ），是人或外部与计算机进行交互的一种装置，用于把原始数据和处理这些数据的程序输入到计算机中。
输出设备 ​	输出设备（Output Device）是把计算或处理的结果或中间结果以人能识别的各种形式,如数字、符号、字母等表示出来,因此输入输出设备起了人与机器之间进行联系的作用。常见的有显示器、打印机、绘图仪、影像输出系统、语音输出系统、磁记录设备等。
操作系统 ​	计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出（文字、图片、音频、视频等）。计算机由硬件和软件组成：
硬件是计算机赖以工作的实体，包括显示器、键盘、鼠标、硬盘、CPU、主板等； 软件会按照用户的要求协调整台计算机的工作，比如 Windows、Linux、Mac OS、Android 等操作系统，以及 Office、QQ、迅雷、微信等应用程序。 操作系统是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁（或者说接口、中间人、中介等）。
编程与编程语言 编程 ​	指的是给计算机编定程序，使计算机能够完成我们需要的指令，得到相应的结果。这种人与计算机之间的交流过程就叫做编程。编程是一种逻辑的思维运算。
编程语言
编程语言（programming language）可以简单的理解为一种计算机和人都能识别的语言。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。
编程语言的3大类 机器语言： 定义 优点 缺点 计算机直接识别的二进制代码 直接执行，速度快，资源占用少 可读性、可移植性差，编程繁杂 机器语言是直接可以被计算机认识的语言，无需经过翻译，每一操作码在计算机内部都有相应的电	路来完成它。
汇编语言： 定义 优点 缺点 汇编无法直接被机器直接识别需要汇编 编译阅读（相对机器语言），速度块，资源占用少 可读性、可移植性差，可维护性差 汇编语言具有更高的机器相关性，更加便于记忆和书写，但又同时保留了机器语言高速度和高效率的特点。汇编语言仍是面向机器的语言，很难从其代码上理解程序设计意图，设计出来的程序不易被移植，故不像其他大多数的高级计算机语言一样被广泛应用</description>
    </item>
    
    <item>
      <title>关于博主</title>
      <link>https://jinkes-li.github.io/about/%E5%85%B3%E4%BA%8E%E5%8D%9A%E4%B8%BB/</link>
      <pubDate>Wed, 21 Sep 2022 19:37:41 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/about/%E5%85%B3%E4%BA%8E%E5%8D%9A%E4%B8%BB/</guid>
      <description>关于博主： ​	博主不是一个技术大牛，只是一个拥抱开源技术的爱好者，目前正在从事运维开发工作，希望在闲暇时间可以将好的项目和技术知识对大家进行分享，除此之外也是一名自我救赎者。
​	&amp;ndash;来自一名互联网的小透明</description>
    </item>
    
    <item>
      <title>计算机基础及Markdown基础</title>
      <link>https://jinkes-li.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%8F%8Amarkdown%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Wed, 21 Sep 2022 16:17:14 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%8F%8Amarkdown%E5%9F%BA%E7%A1%80/</guid>
      <description>引言： 干活干活～
整理一下Markdown一些常见的用法 再来一点计算机基础，ok ，现在开始。
计算机基础 想了想还是吧计算机基础写在前面吧，后续更新python慢慢深入哈～
​	世界上第一台通用计算机“ENIAC”于1946年2月14日在美国宾夕法尼亚大学诞生。发明人是美国人莫克利（JohnW.Mauchly）和艾克特（J.PresperEckert）。
​	对于我们来说计算机到底是什么，为什么说计算机是互联网世界的基石呢，首先我们需要理解计算机创造之初的设计理念。
由于在人类社会中存在大量重复性工作，以及随着文明的进步衍生出许许多多需要海量计算的数据，那这些数据依靠人脑需要计算几十上百年甚至是上万年才能被计算出来，由此计算机参照人类本身的行为逻辑应运而出。
我们需要先了解计算机的核心硬件：
控制器-CPU （相当于人类的大脑，用于协调身体的各个器官合作工作） 运算器-CPU （这个也相当于人类的大脑思考如何解决这个问题并给出解决方案） 存储器-RAM-DISK （相当于记忆，区分为短暂记忆(RAM)和永久记忆(DISK)） 输入设备-键盘 （比如耳朵，眼睛，嗅觉等，只用于接收信息由大脑处理） 输出设备-显示屏（比如嘴巴，教师向学生授课就想当于输出，学生们就相当于被灌输知识，这里也就是输入） 说完计算机的基本组成，我们再浅谈一下计算机是如何工作的。
​	人不吃饭不行，计算机主要依靠电信号，离开了电当然也是不可以的，是依靠着高低电频来组成不同的信息，这个电频不是高就是低，感觉能组成的信息太少了怎么办，这就不得不说一下进制的概念了
进制 二进制	0 1（逢二进一 0 1 10） 八进制 0 1 2 3 4 5 6 7 （逢八进一） 十进制 0 1 2 3 4 5 6 7 8 9 （逢十进一） 十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f （逢十六进一） ​	其中十进制和十六进制一半用于各种电子设备的IP地址，二进制一半是二进制文件，至于八进制 en&amp;hellip;好像没怎么遇到过，这里顺便加一下存储的单位转换。然后说一下计算机如何通过路径找文件，对于人来说哈。</description>
    </item>
    
    <item>
      <title>Mac设置不休眠</title>
      <link>https://jinkes-li.github.io/posts/mac%E8%AE%BE%E7%BD%AE%E4%B8%8D%E4%BC%91%E7%9C%A0/</link>
      <pubDate>Fri, 19 Aug 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/mac%E8%AE%BE%E7%BD%AE%E4%B8%8D%E4%BC%91%E7%9C%A0/</guid>
      <description>Mac默认情况下合上盖子就会进入休眠状态，正在进行的任务也会停止。我们在终端执行两条命令来将Mac设置为合盖不休眠。
打开Terminal，执行如下两条语句：
sudo pmset -b sleep 0 sudo pmset -b disablesleep 1 若需要恢复原有合盖自动休眠的设置，则执行如下两条语句：
sudo pmset -b sleep 5 sudo pmset -b disablesleep 0 关于pmset命令更多的用法可以在终端执行man pmset来查看。</description>
    </item>
    
    <item>
      <title>aliyun Centos7 如何安装python3.7.4和pip3</title>
      <link>https://jinkes-li.github.io/posts/%E9%98%BF%E9%87%8C%E4%BA%91centos7%E5%AE%89%E8%A3%85python3.7.4%E5%92%8Cpip3/</link>
      <pubDate>Tue, 19 Jul 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E9%98%BF%E9%87%8C%E4%BA%91centos7%E5%AE%89%E8%A3%85python3.7.4%E5%92%8Cpip3/</guid>
      <description>aliyun Centos7 如何安装python3.7.4和pip3
亲测有效，针对 阿里云 centos 7 轻量服务器
python ==&amp;gt; 3.7.4
pip ==&amp;gt; 3
一，打开python官网，找到下载Python的tgz文件，有两种方式下载 （版本可能更新，进官网核实为准）
1，直接在windows系统下了完了，通过xtfp上传文件到/usr/local/下 python官网下载地址：https://www.python.org/downloads/release/python-374/
2、通过wget命令，至于命令后半段下载链接，直接右键点击Gzi&amp;hellip;&amp;hellip;复制链接即可
wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz 二，解压文件，添加一些安装依赖 在/usr/local/目录下解压 (习惯将这里当做文件下载，解压的地方，根据个人情况而定)
tar zxvf Python-3.7.4.tgz 安装依赖
yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel gcc libffi-devel gcc make automake autoconf libtool libffi-devel 且需要安装一个包，libffi-devel为3.7版本需要的一个新的包，否则安装的时候报错 ModuleNotFoundError: No module named &amp;lsquo;_ctypes&amp;rsquo;
yum install libffi-devel -y 进入解压目录
cd Python-3.7.4 进行初始配置 注意：在这之前先将安装目录创建好，否则&amp;hellip;&amp;hellip;.，这里我安装到 /usr/local/python3 目录下
mkdir /usr/local/python3 ./configure --prefix=/usr/local/python3　执行安装</description>
    </item>
    
    <item>
      <title>Kubernetes Coredns 服务发现</title>
      <link>https://jinkes-li.github.io/posts/kubernetes-coredns-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Tue, 19 Jul 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/kubernetes-coredns-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B5%8B%E8%AF%95/</guid>
      <description>测试 1111服务发现是指服务之间的通讯联通，对于Kubernetes来说服务发现具有3个痛点
服务的动态性强 服务更新发布频繁 服务支持自动伸缩 Kubernetes中的PODIP是不断变化的，这里如何以不变应万变呢，以下两组概念就可以解决这个问题
Kubernetes中抽象出来Service资源，通过标签选择器来关联一组POD Kubernetes中抽象出来了集群网络，通过相对固定的集群IP，使服务的接入点固定 那么如何自动关联Service资源的“名称”和“集群网络IP”，从而达到服务被集群自动发现的目的？
我们可以考虑一下传统的NDS模型： baidu.com —&amp;gt; 111.213.123.1
Kubernetes这里通过Coredns也去建立类似于传统DNS的模型，实现域名和IP（也就是固定接入点）的绑定
部署Coredns
在hdss7-200.host.com上，配置一个NGINX，用以提供kubernetes统一的访问资源清单入口
[root@hdss7-200 ~]# vim /etc/nginx/conf.d/k8s-yaml.od.com.conf server { listen 80; server_name k8s-yaml.od.com; location / { autoindex on; default_type text/plain; root /data/k8s-yaml; } } [root@hdss7-200 html]# cd /data [root@hdss7-200 data]# mkdir k8s-yaml [root@hdss7-200 data]# cd k8s-yaml/ [root@hdss7-200 k8s-yaml]# mkdir coredns [root@hdss7-200 k8s-yaml]# nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful [root@hdss7-200 k8s-yaml]# nginx -s reload [root@hdss7-200 k8s-yaml]# nginx配置中使用了新的域名，需要在内网DNS服务器上配置解析</description>
    </item>
    
    <item>
      <title>项目环境</title>
      <link>https://jinkes-li.github.io/posts/%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Wed, 26 May 2021 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/</guid>
      <description>BI 项目启动环境 此项目使用的是Centos7.9 内核版本5.19，升级历史操作如下 [可参考]
17 rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 18 rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 19 yum --disablerepo=&amp;#34;*&amp;#34; --enablerepo=&amp;#34;elrepo-kernel&amp;#34; list available 20 $ yum --enablerepo=elrepo-kernel install kernel-ml 21 yum --enablerepo=elrepo-kernel install kernel-ml 22 awk -F\&amp;#39; &amp;#39;$1==&amp;#34;menuentry &amp;#34; {print i++ &amp;#34; : &amp;#34; $2}&amp;#39; /etc/grub2.cfg 23 grub2-set-default 0 24 reboot 25 uname -a 26 history 基本环境安装 install git
[root@web ~]# yum install git -y install docker
安装教程
[root@web ~]# yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine [root@web ~]# yum install -y yum-utils [root@web ~]# yum-config-manager \ --add-repo \ https://download.</description>
    </item>
    
    <item>
      <title>服务状态</title>
      <link>https://jinkes-li.github.io/posts/%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</link>
      <pubDate>Tue, 21 Jan 2020 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</guid>
      <description>服务状体
常常听到的服务状态是什么意思？ 什么是无服务状态和什么是有服务状态
无状态服务
无状态服务不会在本地存储持久化数据.多个服务实例对于同一个用户请求的响应结果是完全一致的.这种多服务实例之间是没有依赖关系,比如web应用,在k8s控制器 中动态启停无状态服务的pod并不会对其它的pod产生影响.
有状态服务
有状态服务需要在本地存储持久化数据,典型的是分布式数据库的应用,分布式节点实例之间有依赖的拓扑关系.比如,主从关系. 如果K8S停止分布式集群中任 一实例pod,就可能会导致数据丢失或者集群的crash.
了解这个之后我们提出一个问题， Deployment部署的问题?
Deployment被设计用来管理无状态服务的pod,每个pod完全一致.什么意思呢?
无状态服务内的多个Pod创建的顺序是没有顺序的. 无状态服务内的多个Pod的名称是随机的.pod被重新启动调度后,它的名称与IP都会发生变化. 无状态服务内的多个Pod背后是共享存储的.
现在看一个新的问题？
对于数据库有状态的服务容器编排,Deployment解决方案就变得无能为力了. 比如,Redis是主从的架构,只能允许集群中出现一个主节点提供写,其它节点提供读能力.如果同时出现二个主节点后,必须会出现并发写的 操作,进一步导致集群写数据的不一致. 所以问题来了,针对Redis这种有状态的服务,它管理的多个Pod(代表master/slave角色)必须有自己独立的持久化存储组件. 有状态的服务Pod是用来运行有状态应用的,其在数据卷上存储的数据非常重要,因为Stateful就是要依赖存储数据卷上对每个Pod的状态进行建模与存储. 所以K8S提供了一个新的工具——StatefulSet来统一解决问题.
Deployment组件是为无状态服务而设计的,其中的Pod名称,主机名,存储都是随机,不稳定的,并且Pod的创建与销毁也是无序的.这个设计决定了无状态服务并 不适合数据库领域的应用.
而Stateful管理有状态的应用,它的Pod有如下特征:
唯一性: 每个Pod会被分配一个唯一序号. 顺序性: Pod启动,更新,销毁是按顺序进行. 稳定的网络标识: Pod主机名,DNS地址不会随着Pod被重新调度而发生变化. 稳定的持久化存储: Pod被重新调度后,仍然能挂载原有的PV,从而保证了数据的完整性和一致性.
等待更新···</description>
    </item>
    
  </channel>
</rss>
