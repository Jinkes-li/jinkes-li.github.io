<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>self-salvation</title>
    <link>https://jinkes-li.github.io/</link>
    <description>Recent content on self-salvation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 23 Sep 2022 19:12:39 +0800</lastBuildDate><atom:link href="https://jinkes-li.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>遇见Python</title>
      <link>https://jinkes-li.github.io/python/%E9%81%87%E8%A7%81python/</link>
      <pubDate>Fri, 23 Sep 2022 19:12:39 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E9%81%87%E8%A7%81python/</guid>
      <description>遇见Python 引言：
接下来本文开始将在学习和工作中记录Python的使用
本文内容
Python语法-注释
关键字
变量与常量
​	变量与常量的基本使用
​	变量规范和命名规则
数据类型
​	整型（int）
​	浮点型（float）
​	字符串（str）
​	列表（list）
​	字典（dict）
PEP8规范
Python语法-注释
注释的意思就是被注释的代码不执行，参见下列示例
注释符号 # &amp;#39;&amp;#39;&amp;#39; &amp;#39;&amp;#39;&amp;#39; &amp;#34;&amp;#34;&amp;#34; &amp;#34;&amp;#34;&amp;#34; # 打印123 print(123) # 这一行是代码，代码后面也可以加注释 &amp;#39;&amp;#39;&amp;#39; 123 456 这是多行注释，被包含的内容都不执行 &amp;#39;&amp;#39;&amp;#39; &amp;#34;&amp;#34;&amp;#34; 666 这也是多行注释，被包含的内容都不执行 &amp;#34;&amp;#34;&amp;#34; 关键字 # 具有一定功能的特定单词，例如 print(&amp;#39;打印&amp;#39;) print(&amp;#39;123&amp;#39;) 123 # 查看数据类型 type() name = &amp;#39;wesley&amp;#39; print(type(name)) &amp;lt;class &amp;#39;str&amp;#39;&amp;gt; # 通过输出结果可以看出数据类型为str 也就是字符串 变量与常量
变量就是会变化的量，常量就是不会变化的量或者说长时间不会改变的量
​	变量：比如说我们的年龄会随着每年增涨，今年18，明年19，年龄在不断发生变化，这就是变量
​	常量：比如我们的身份证号码就属于常量，无论什么时间身份证号都不会发生变化，这就是常量
变量的命名规则和特性</description>
    </item>
    
    <item>
      <title>JetBrains IDE 产品使用</title>
      <link>https://jinkes-li.github.io/python/jetbrains-ide-%E4%BA%A7%E5%93%81%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 23 Sep 2022 19:03:58 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/jetbrains-ide-%E4%BA%A7%E5%93%81%E4%BD%BF%E7%94%A8/</guid>
      <description>JetBrains IDE 产品使用（Pycharm ） ​	引言：本文使用的系统为 MacOS 12.5 M1
接下来我们需要写Python相关的代码这里强烈推荐使用Pycharm，由于免费的社区版某些功能没有，这里我们使用Pycharm专业版（仅测试使用）
JetBrains官网 下载安装你需要的 IDE这里下载PyCharm，下载完成后直接双击安装 下载 Jetbrains.zip，下载后解压，得到 fineagent.jar，将该文件复制到 /Users/你的用户名/ 文件夹下
#使用cd进入到Users下面的你电脑的用户名下 wesley@wesleydeMacBook-Pro ⮀ ~ ⮀ cd /Users/wesley/ #将下载的fineagent.zip 复制到当前目录并解压，注意：我这里是吧fineagent.zip下载到了Downloads这个目录下，请以你的下载目录为准 wesley@wesleydeMacBook-Pro ⮀ ~ ⮀ cp /Users/wesley/Downloads/fineagent.zip ./ &amp;amp;&amp;amp; unzip fineagent.zip &amp;amp;&amp;amp; ll -rw-r--r--@ 1 wesley staff 35K Aug 15 10:21 fineagent.jar wesley@wesleydeMacBook-Pro ⮀ ~ ⮀ 打开访达，点击左侧的 应用程序 找到 PyCharm，在 PyCharm 图标上右键，点击 显示包内容
进入 Contents 目录，再进入 bin 目录，使用文本编辑器打开 pycharm.vmoptions 文件
5.在最后面添加 -javaagent:/Users/你的用户名/fineagent.jar，记得修改一下你的用户名。
运行 PyCharm, 选择 Activate PyCharm，再点击 Activation Code</description>
    </item>
    
    <item>
      <title>基础和py解释器</title>
      <link>https://jinkes-li.github.io/python/%E5%9F%BA%E7%A1%80%E5%92%8Cpy%E8%A7%A3%E9%87%8A%E5%99%A8/</link>
      <pubDate>Thu, 22 Sep 2022 20:12:55 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/python/%E5%9F%BA%E7%A1%80%E5%92%8Cpy%E8%A7%A3%E9%87%8A%E5%99%A8/</guid>
      <description>引言：
​	继续接着上一个文章干活哈
本文内容： 计算机三大核心硬件部分详解 操作系统 编程与编程语言 编程语言的发展史 编程语言的分类 Python解释器 Python解释器多版本共存 计算机主要三核心硬件详解 CPU ​ 中央处理器（CPU），是电子计算机的主要设备之一，电脑中的核心配件。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU是计算机中负责读取指令，对指令译码并执行指令的核心部件。中央处理器主要包括两个部分，即控制器、运算器，其中还包括高速缓冲存储器及实现它们之间联系的数据、控制的总线。电子计算机三大核心部件就是CPU、内部存储器、输入/输出设备。中央处理器的功效主要为处理指令、执行操作、控制时间、处理数据。
存储器 ​	按信息的可保存性分类
​	非永久记忆的存储器：断电后信息即消失的存储器。
​	永久记忆性存储器：断电后仍能保存信息的存储器。
​	按在计算机系统中的作用分类
​	主存储器（内存）：用于存放活动的程序和数据，其速度高、容量较小、每位价位高。
​	辅助存储器（外存储器）：主要用于存放当前不活跃的程序和数据，其速度慢、容量大、每位价位低。
​	缓冲存储器：主要在两个不同工作速度的部件起缓冲作用。
输入设备 ​	输入设备是向计算机输入数据和信息的设备，是计算机与用户或其他设备通信的桥梁，是用户和计算机系统之间进行信息交换的主要装置之一。输入设备的任务是把数据、指令及某些标志信息等输送到计算机中去。键盘、鼠标、摄像头、扫描仪、光笔、手写输入板、游戏杆、语音输入装置等都属于输入设备（Input Device ），是人或外部与计算机进行交互的一种装置，用于把原始数据和处理这些数据的程序输入到计算机中。
输出设备 ​	输出设备（Output Device）是把计算或处理的结果或中间结果以人能识别的各种形式,如数字、符号、字母等表示出来,因此输入输出设备起了人与机器之间进行联系的作用。常见的有显示器、打印机、绘图仪、影像输出系统、语音输出系统、磁记录设备等。
操作系统 ​	计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出（文字、图片、音频、视频等）。计算机由硬件和软件组成：
硬件是计算机赖以工作的实体，包括显示器、键盘、鼠标、硬盘、CPU、主板等； 软件会按照用户的要求协调整台计算机的工作，比如 Windows、Linux、Mac OS、Android 等操作系统，以及 Office、QQ、迅雷、微信等应用程序。 操作系统是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁（或者说接口、中间人、中介等）。
编程与编程语言 编程 ​	指的是给计算机编定程序，使计算机能够完成我们需要的指令，得到相应的结果。这种人与计算机之间的交流过程就叫做编程。编程是一种逻辑的思维运算。
编程语言
编程语言（programming language）可以简单的理解为一种计算机和人都能识别的语言。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。
编程语言的3大类 机器语言： 定义 优点 缺点 计算机直接识别的二进制代码 直接执行，速度快，资源占用少 可读性、可移植性差，编程繁杂 机器语言是直接可以被计算机认识的语言，无需经过翻译，每一操作码在计算机内部都有相应的电	路来完成它。
汇编语言： 定义 优点 缺点 汇编无法直接被机器直接识别需要汇编 编译阅读（相对机器语言），速度块，资源占用少 可读性、可移植性差，可维护性差 汇编语言具有更高的机器相关性，更加便于记忆和书写，但又同时保留了机器语言高速度和高效率的特点。汇编语言仍是面向机器的语言，很难从其代码上理解程序设计意图，设计出来的程序不易被移植，故不像其他大多数的高级计算机语言一样被广泛应用</description>
    </item>
    
    <item>
      <title>关于博主</title>
      <link>https://jinkes-li.github.io/about/%E5%85%B3%E4%BA%8E%E5%8D%9A%E4%B8%BB/</link>
      <pubDate>Wed, 21 Sep 2022 19:37:41 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/about/%E5%85%B3%E4%BA%8E%E5%8D%9A%E4%B8%BB/</guid>
      <description>关于博主： ​	博主不是一个技术大牛，只是一个拥抱开源技术的爱好者，目前正在从事运维开发工作，希望在闲暇时间可以将好的项目和技术知识对大家进行分享，除此之外也是一名自我救赎者。
​	&amp;ndash;来自一名互联网的小透明</description>
    </item>
    
    <item>
      <title>计算机基础及Markdown基础</title>
      <link>https://jinkes-li.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%8F%8Amarkdown%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Wed, 21 Sep 2022 16:17:14 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%8F%8Amarkdown%E5%9F%BA%E7%A1%80/</guid>
      <description>引言： 干活干活～
整理一下Markdown一些常见的用法 再来一点计算机基础，ok ，现在开始。
计算机基础 想了想还是吧计算机基础写在前面吧，后续更新python慢慢深入哈～
​	世界上第一台通用计算机“ENIAC”于1946年2月14日在美国宾夕法尼亚大学诞生。发明人是美国人莫克利（JohnW.Mauchly）和艾克特（J.PresperEckert）。
​	对于我们来说计算机到底是什么，为什么说计算机是互联网世界的基石呢，首先我们需要理解计算机创造之初的设计理念。
由于在人类社会中存在大量重复性工作，以及随着文明的进步衍生出许许多多需要海量计算的数据，那这些数据依靠人脑需要计算几十上百年甚至是上万年才能被计算出来，由此计算机参照人类本身的行为逻辑应运而出。
我们需要先了解计算机的核心硬件：
控制器-CPU （相当于人类的大脑，用于协调身体的各个器官合作工作） 运算器-CPU （这个也相当于人类的大脑思考如何解决这个问题并给出解决方案） 存储器-RAM-DISK （相当于记忆，区分为短暂记忆(RAM)和永久记忆(DISK)） 输入设备-键盘 （比如耳朵，眼睛，嗅觉等，只用于接收信息由大脑处理） 输出设备-显示屏（比如嘴巴，教师向学生授课就想当于输出，学生们就相当于被灌输知识，这里也就是输入） 说完计算机的基本组成，我们再浅谈一下计算机是如何工作的。
​	人不吃饭不行，计算机主要依靠电信号，离开了电当然也是不可以的，是依靠着高低电频来组成不同的信息，这个电频不是高就是低，感觉能组成的信息太少了怎么办，这就不得不说一下进制的概念了
进制 二进制	0 1（逢二进一 0 1 10） 八进制 0 1 2 3 4 5 6 7 （逢八进一） 十进制 0 1 2 3 4 5 6 7 8 9 （逢十进一） 十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f （逢十六进一） ​	其中十进制和十六进制一半用于各种电子设备的IP地址，二进制一半是二进制文件，至于八进制 en&amp;hellip;好像没怎么遇到过，这里顺便加一下存储的单位转换。然后说一下计算机如何通过路径找文件，对于人来说哈。</description>
    </item>
    
    <item>
      <title>Mac设置不休眠</title>
      <link>https://jinkes-li.github.io/posts/mac%E8%AE%BE%E7%BD%AE%E4%B8%8D%E4%BC%91%E7%9C%A0/</link>
      <pubDate>Fri, 19 Aug 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/mac%E8%AE%BE%E7%BD%AE%E4%B8%8D%E4%BC%91%E7%9C%A0/</guid>
      <description>Mac默认情况下合上盖子就会进入休眠状态，正在进行的任务也会停止。我们在终端执行两条命令来将Mac设置为合盖不休眠。
打开Terminal，执行如下两条语句：
sudo pmset -b sleep 0 sudo pmset -b disablesleep 1 若需要恢复原有合盖自动休眠的设置，则执行如下两条语句：
sudo pmset -b sleep 5 sudo pmset -b disablesleep 0 关于pmset命令更多的用法可以在终端执行man pmset来查看。</description>
    </item>
    
    <item>
      <title>aliyun Centos7 如何安装python3.7.4和pip3</title>
      <link>https://jinkes-li.github.io/posts/%E9%98%BF%E9%87%8C%E4%BA%91centos7%E5%AE%89%E8%A3%85python3.7.4%E5%92%8Cpip3/</link>
      <pubDate>Tue, 19 Jul 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E9%98%BF%E9%87%8C%E4%BA%91centos7%E5%AE%89%E8%A3%85python3.7.4%E5%92%8Cpip3/</guid>
      <description>aliyun Centos7 如何安装python3.7.4和pip3
亲测有效，针对 阿里云 centos 7 轻量服务器
python ==&amp;gt; 3.7.4
pip ==&amp;gt; 3
一，打开python官网，找到下载Python的tgz文件，有两种方式下载 （版本可能更新，进官网核实为准）
1，直接在windows系统下了完了，通过xtfp上传文件到/usr/local/下 python官网下载地址：https://www.python.org/downloads/release/python-374/
2、通过wget命令，至于命令后半段下载链接，直接右键点击Gzi&amp;hellip;&amp;hellip;复制链接即可
wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz 二，解压文件，添加一些安装依赖 在/usr/local/目录下解压 (习惯将这里当做文件下载，解压的地方，根据个人情况而定)
tar zxvf Python-3.7.4.tgz 安装依赖
yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel gcc libffi-devel gcc make automake autoconf libtool libffi-devel 且需要安装一个包，libffi-devel为3.7版本需要的一个新的包，否则安装的时候报错 ModuleNotFoundError: No module named &amp;lsquo;_ctypes&amp;rsquo;
yum install libffi-devel -y 进入解压目录
cd Python-3.7.4 进行初始配置 注意：在这之前先将安装目录创建好，否则&amp;hellip;&amp;hellip;.，这里我安装到 /usr/local/python3 目录下
mkdir /usr/local/python3 ./configure --prefix=/usr/local/python3　执行安装</description>
    </item>
    
    <item>
      <title>Kubernetes Coredns 服务发现</title>
      <link>https://jinkes-li.github.io/posts/kubernetes-coredns-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Tue, 19 Jul 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/kubernetes-coredns-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B5%8B%E8%AF%95/</guid>
      <description>测试 1111服务发现是指服务之间的通讯联通，对于Kubernetes来说服务发现具有3个痛点
服务的动态性强 服务更新发布频繁 服务支持自动伸缩 Kubernetes中的PODIP是不断变化的，这里如何以不变应万变呢，以下两组概念就可以解决这个问题
Kubernetes中抽象出来Service资源，通过标签选择器来关联一组POD Kubernetes中抽象出来了集群网络，通过相对固定的集群IP，使服务的接入点固定 那么如何自动关联Service资源的“名称”和“集群网络IP”，从而达到服务被集群自动发现的目的？
我们可以考虑一下传统的NDS模型： baidu.com —&amp;gt; 111.213.123.1
Kubernetes这里通过Coredns也去建立类似于传统DNS的模型，实现域名和IP（也就是固定接入点）的绑定
部署Coredns
在hdss7-200.host.com上，配置一个NGINX，用以提供kubernetes统一的访问资源清单入口
[root@hdss7-200 ~]# vim /etc/nginx/conf.d/k8s-yaml.od.com.conf server { listen 80; server_name k8s-yaml.od.com; location / { autoindex on; default_type text/plain; root /data/k8s-yaml; } } [root@hdss7-200 html]# cd /data [root@hdss7-200 data]# mkdir k8s-yaml [root@hdss7-200 data]# cd k8s-yaml/ [root@hdss7-200 k8s-yaml]# mkdir coredns [root@hdss7-200 k8s-yaml]# nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful [root@hdss7-200 k8s-yaml]# nginx -s reload [root@hdss7-200 k8s-yaml]# nginx配置中使用了新的域名，需要在内网DNS服务器上配置解析</description>
    </item>
    
    <item>
      <title>项目环境</title>
      <link>https://jinkes-li.github.io/posts/%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Wed, 26 May 2021 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/</guid>
      <description>BI 项目启动环境 此项目使用的是Centos7.9 内核版本5.19，升级历史操作如下 [可参考]
17 rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 18 rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 19 yum --disablerepo=&amp;#34;*&amp;#34; --enablerepo=&amp;#34;elrepo-kernel&amp;#34; list available 20 $ yum --enablerepo=elrepo-kernel install kernel-ml 21 yum --enablerepo=elrepo-kernel install kernel-ml 22 awk -F\&amp;#39; &amp;#39;$1==&amp;#34;menuentry &amp;#34; {print i++ &amp;#34; : &amp;#34; $2}&amp;#39; /etc/grub2.cfg 23 grub2-set-default 0 24 reboot 25 uname -a 26 history 基本环境安装 install git
[root@web ~]# yum install git -y install docker
安装教程
[root@web ~]# yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine [root@web ~]# yum install -y yum-utils [root@web ~]# yum-config-manager \ --add-repo \ https://download.</description>
    </item>
    
    <item>
      <title>服务状态</title>
      <link>https://jinkes-li.github.io/posts/%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</link>
      <pubDate>Tue, 21 Jan 2020 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</guid>
      <description>服务状体
常常听到的服务状态是什么意思？ 什么是无服务状态和什么是有服务状态
无状态服务
无状态服务不会在本地存储持久化数据.多个服务实例对于同一个用户请求的响应结果是完全一致的.这种多服务实例之间是没有依赖关系,比如web应用,在k8s控制器 中动态启停无状态服务的pod并不会对其它的pod产生影响.
有状态服务
有状态服务需要在本地存储持久化数据,典型的是分布式数据库的应用,分布式节点实例之间有依赖的拓扑关系.比如,主从关系. 如果K8S停止分布式集群中任 一实例pod,就可能会导致数据丢失或者集群的crash.
了解这个之后我们提出一个问题， Deployment部署的问题?
Deployment被设计用来管理无状态服务的pod,每个pod完全一致.什么意思呢?
无状态服务内的多个Pod创建的顺序是没有顺序的. 无状态服务内的多个Pod的名称是随机的.pod被重新启动调度后,它的名称与IP都会发生变化. 无状态服务内的多个Pod背后是共享存储的.
现在看一个新的问题？
对于数据库有状态的服务容器编排,Deployment解决方案就变得无能为力了. 比如,Redis是主从的架构,只能允许集群中出现一个主节点提供写,其它节点提供读能力.如果同时出现二个主节点后,必须会出现并发写的 操作,进一步导致集群写数据的不一致. 所以问题来了,针对Redis这种有状态的服务,它管理的多个Pod(代表master/slave角色)必须有自己独立的持久化存储组件. 有状态的服务Pod是用来运行有状态应用的,其在数据卷上存储的数据非常重要,因为Stateful就是要依赖存储数据卷上对每个Pod的状态进行建模与存储. 所以K8S提供了一个新的工具——StatefulSet来统一解决问题.
Deployment组件是为无状态服务而设计的,其中的Pod名称,主机名,存储都是随机,不稳定的,并且Pod的创建与销毁也是无序的.这个设计决定了无状态服务并 不适合数据库领域的应用.
而Stateful管理有状态的应用,它的Pod有如下特征:
唯一性: 每个Pod会被分配一个唯一序号. 顺序性: Pod启动,更新,销毁是按顺序进行. 稳定的网络标识: Pod主机名,DNS地址不会随着Pod被重新调度而发生变化. 稳定的持久化存储: Pod被重新调度后,仍然能挂载原有的PV,从而保证了数据的完整性和一致性.
等待更新···</description>
    </item>
    
  </channel>
</rss>
