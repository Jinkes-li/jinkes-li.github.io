<!DOCTYPE html>
<html lang="en-us">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <script type="text/javascript" src="https://latest.cactus.chat/cactus.js"></script>
  <link rel="stylesheet" href="https://latest.cactus.chat/style.css" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> 并发编程(下) | self-salvation</title>
  <link rel = 'canonical' href = 'https://jinkes-li.github.io/python/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8B/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="并发编程(下)" />
<meta property="og:description" content="多进程实现TCP服务端并发 # 导入socket import socket from multiprocessing import Process # 用于创建进程的模块 # 创建一个进程对象，由于需要实现并发，需要使用函数包起来供调用 def get_server(): # 创建一个进程对象 server = socket.socket() # 绑定服务端对外的地址和接口 server.bind((&#39;127.0.0.1&#39;, 8080)) # 设置半连接池 server.listen(5) # 返回创建的对象供调用 return server # 定义一个用于接收客户端连接的函数 def get_talk(sock): # 需要循环接收信息 while True: # 定义接收的信息以及需要处理的操作 data = sock.recv(1024) print(data.decode(&#39;utf8&#39;)) # 将接收到的信息转为大写 sock.send(data.upper()) # 判断是否为执行文件，主要作为兼容win if __name__ == &#39;__main__&#39;: # 获取服务端信息 server = get_server() # 循环开设进程 while True: # 用于接收客户端请求 sock, addr = server.accept() # 开设进程聊天 p = Process(target=get_talk, args=(sock,)) # 启动进程 p." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jinkes-li.github.io/python/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8B/" /><meta property="article:section" content="python" />
<meta property="article:published_time" content="2022-11-21T22:42:59+08:00" />
<meta property="article:modified_time" content="2022-11-21T22:42:59+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="并发编程(下)"/>
<meta name="twitter:description" content="多进程实现TCP服务端并发 # 导入socket import socket from multiprocessing import Process # 用于创建进程的模块 # 创建一个进程对象，由于需要实现并发，需要使用函数包起来供调用 def get_server(): # 创建一个进程对象 server = socket.socket() # 绑定服务端对外的地址和接口 server.bind((&#39;127.0.0.1&#39;, 8080)) # 设置半连接池 server.listen(5) # 返回创建的对象供调用 return server # 定义一个用于接收客户端连接的函数 def get_talk(sock): # 需要循环接收信息 while True: # 定义接收的信息以及需要处理的操作 data = sock.recv(1024) print(data.decode(&#39;utf8&#39;)) # 将接收到的信息转为大写 sock.send(data.upper()) # 判断是否为执行文件，主要作为兼容win if __name__ == &#39;__main__&#39;: # 获取服务端信息 server = get_server() # 循环开设进程 while True: # 用于接收客户端请求 sock, addr = server.accept() # 开设进程聊天 p = Process(target=get_talk, args=(sock,)) # 启动进程 p."/>

  
  
    
  
  
  <link rel="stylesheet" href="https://jinkes-li.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="https://jinkes-li.github.io/images/favicon.ico" />

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://jinkes-li.github.io/">
  
    <div id="logo" style="background-image: url(https://jinkes-li.github.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>self-salvation</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/posts/">All posts</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
        <li><a href="/python">Python</a></li>
      
        <li><a href="/databases">databases</a></li>
      
        <li><a href="/web">web</a></li>
      
        <li><a href="/about">About</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <ul>
<li>多进程实现TCP服务端并发</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 导入socket</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> socket
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Process  <span style="color:#75715e"># 用于创建进程的模块</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 创建一个进程对象，由于需要实现并发，需要使用函数包起来供调用</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_server</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 创建一个进程对象</span>
</span></span><span style="display:flex;"><span>    server <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>socket()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 绑定服务端对外的地址和接口</span>
</span></span><span style="display:flex;"><span>    server<span style="color:#f92672">.</span>bind((<span style="color:#e6db74">&#39;127.0.0.1&#39;</span>, <span style="color:#ae81ff">8080</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 设置半连接池</span>
</span></span><span style="display:flex;"><span>    server<span style="color:#f92672">.</span>listen(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 返回创建的对象供调用</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> server
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 定义一个用于接收客户端连接的函数</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_talk</span>(sock):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 需要循环接收信息</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 定义接收的信息以及需要处理的操作</span>
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> sock<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>        print(data<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf8&#39;</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 将接收到的信息转为大写</span>
</span></span><span style="display:flex;"><span>        sock<span style="color:#f92672">.</span>send(data<span style="color:#f92672">.</span>upper())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 判断是否为执行文件，主要作为兼容win</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 获取服务端信息</span>
</span></span><span style="display:flex;"><span>    server <span style="color:#f92672">=</span> get_server()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 循环开设进程</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 用于接收客户端请求</span>
</span></span><span style="display:flex;"><span>        sock, addr <span style="color:#f92672">=</span> server<span style="color:#f92672">.</span>accept()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 开设进程聊天</span>
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>get_talk, args<span style="color:#f92672">=</span>(sock,))
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 启动进程</span>
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">.</span>start()
</span></span></code></pre></div><ul>
<li>互斥锁代码实操</li>
</ul>
<blockquote>
<p>互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作
互斥锁是多个线程一起去抢，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。所以互斥锁也是独占锁
互斥锁🔐：建议只对操作数据的部分加锁，否则整个程序效率会极低，并且使用不当较为造成死锁，相关死锁在接下来也会介绍</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 互斥锁代码实际操作</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Process, set_start_method, Lock  <span style="color:#75715e"># 可以在multiprocessing这个模块中直接引用Lock</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> json
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> random
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 用户查看票</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">search</span>(name):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;/Users/wesley/PycharmProjects/pythonProject5/data.json&#39;</span>, <span style="color:#e6db74">&#39;r&#39;</span>, encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;utf8&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>load(f)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">查看票，目前剩余：</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> (name, data<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#39;ticket_num&#39;</span>)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 用户购买票</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">buy</span>(name):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 先对票数再次查询</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;/Users/wesley/PycharmProjects/pythonProject5/data.json&#39;</span>, <span style="color:#e6db74">&#39;r&#39;</span>, encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;utf8&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>load(f)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 模拟网络延迟</span>
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 开始买票逻辑</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> data<span style="color:#f92672">.</span>get(<span style="color:#e6db74">&#39;ticket_num&#39;</span>) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;/Users/wesley/PycharmProjects/pythonProject5/data.json&#39;</span>, <span style="color:#e6db74">&#39;w&#39;</span>, encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;utf8&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>            data[<span style="color:#e6db74">&#39;ticket_num&#39;</span>] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            json<span style="color:#f92672">.</span>dump(data, f)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> 买票成功&#39;</span> <span style="color:#f92672">%</span> name)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> 买票失败，已经没有票了&#39;</span> <span style="color:#f92672">%</span> name)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 创建函数执行查票买票逻辑</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(name, mutex):
</span></span><span style="display:flex;"><span>    search(name)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 接下来需要运行购买车票的函数，所以这里需要进行加锁，保证一个线程执行</span>
</span></span><span style="display:flex;"><span>    mutex<span style="color:#f92672">.</span>acquire()  <span style="color:#75715e"># 添加锁</span>
</span></span><span style="display:flex;"><span>    buy(name)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 在上面的函数运行结束后，不能影响其他进程的执行，需要立刻释放锁</span>
</span></span><span style="display:flex;"><span>    mutex<span style="color:#f92672">.</span>release()  <span style="color:#75715e"># 释放锁</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>set_start_method(<span style="color:#e6db74">&#39;fork&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 需要在这里产生一把锁</span>
</span></span><span style="display:flex;"><span>    mutex <span style="color:#f92672">=</span> Lock()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>):
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>run, args<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;用户</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">号&#39;</span> <span style="color:#f92672">%</span> i, mutex))
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">.</span>start()
</span></span></code></pre></div><ul>
<li>线程理论</li>
</ul>
<blockquote>
<p>线程是程序中最小执行单位，每一个进程中至少有一个线程
进程时资源单位，一般代表一块内存空间
线程才是执行单位，是真正的代码指令</p>
</blockquote>
<ol>
<li>一个进程内可以开设多个线程</li>
<li>同一个进程下的多个线程的数据是共享的</li>
<li>创建进程的消耗要远远大于创建线程
// 待补充</li>
</ol>
<ul>
<li>创建线程的多种方式</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>第一种方式
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 创建线程需要使用threading模块</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> threading <span style="color:#f92672">import</span> Thread
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">task</span>(name):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74"> is running&#39;</span>)
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">0.1</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74"> is over&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1000</span>):
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">=</span> Thread(target<span style="color:#f92672">=</span>task, args<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;用户</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span>i,))
</span></span><span style="display:flex;"><span>        t<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>第二种方式
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> threading <span style="color:#f92672">import</span> Thread
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread</span>(Thread):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(self) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;run is runing&#39;</span>)
</span></span><span style="display:flex;"><span>        time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;run is over&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>obj <span style="color:#f92672">=</span> MyThread()
</span></span><span style="display:flex;"><span>obj<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;主进程&#39;</span>)
</span></span></code></pre></div><ul>
<li>线程的诸多特性</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ae81ff">1.</span>join方法
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2.</span>同进程内多个线程数据共享
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3.</span>current_thread()
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4.</span>active_count()
</span></span><span style="display:flex;"><span>待补充
</span></span></code></pre></div><ul>
<li>
<p>守护线程
同进程</p>
</li>
<li>
<p>线程诸多方法
同进程</p>
</li>
<li>
<p>GIL全局解释器锁</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 官方文档对GIL的解释</span>
</span></span><span style="display:flex;"><span>In CPython, the <span style="color:#66d9ef">global</span> interpreter lock, <span style="color:#f92672">or</span> GIL, <span style="color:#f92672">is</span> a mutex that prevents multiple native threads <span style="color:#f92672">from</span> executing Python bytecodes at once<span style="color:#f92672">.</span> This lock <span style="color:#f92672">is</span> necessary mainly because CPython<span style="color:#960050;background-color:#1e0010">’</span>s memory management <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> thread<span style="color:#f92672">-</span>safe<span style="color:#f92672">.</span> (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces<span style="color:#f92672">.</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1.</span>在CPython解释器中存在全局解释器锁简称GIL
</span></span><span style="display:flex;"><span>	python解释器有很多类型
</span></span><span style="display:flex;"><span>		CPython JPython PyPython (常用的是CPython解释器)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2.</span>GIL本质也是一把互斥锁 用来阻止同一个进程内多个线程同时执行(重要)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3.</span>GIL的存在是因为CPython解释器中内存管理不是线程安全的(垃圾回收机制)
</span></span></code></pre></div><ul>
<li>验证GIL的存在</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 验证GIL存在</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> threading <span style="color:#f92672">import</span> Thread
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>num <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">task</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> num
</span></span><span style="display:flex;"><span>    num <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>t_list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">100</span>):
</span></span><span style="display:flex;"><span>    t <span style="color:#f92672">=</span> Thread(target<span style="color:#f92672">=</span>task)
</span></span><span style="display:flex;"><span>    t<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>    t_list<span style="color:#f92672">.</span>append(t)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> t_list:
</span></span><span style="display:flex;"><span>    t<span style="color:#f92672">.</span>join()
</span></span><span style="display:flex;"><span>print(num)
</span></span></code></pre></div><ul>
<li>GIL与普通互斥锁</li>
</ul>
<blockquote>
<p>GIL中使用的互斥锁是为了防止垃圾回收机制在线程处理数据时回收正在建立的数据，比如变量
普通的互斥锁是为了防止在处理代码逻辑时多个线程基于初始数据对数据进行处理</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> threading <span style="color:#f92672">import</span> Thread,Lock
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>num <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">task</span>(mutex):  <span style="color:#75715e"># 这里需要将创建的锁传入</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> num
</span></span><span style="display:flex;"><span>    mutex<span style="color:#f92672">.</span>acquire()  <span style="color:#75715e"># 抢锁</span>
</span></span><span style="display:flex;"><span>    count <span style="color:#f92672">=</span> num
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">0.1</span>)
</span></span><span style="display:flex;"><span>    num <span style="color:#f92672">=</span> count <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    mutex<span style="color:#f92672">.</span>release()  <span style="color:#75715e"># 释放锁</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mutex <span style="color:#f92672">=</span> Lock()  <span style="color:#75715e"># 保证数据的安全性</span>
</span></span><span style="display:flex;"><span>t_list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">100</span>):
</span></span><span style="display:flex;"><span>    t <span style="color:#f92672">=</span> Thread(target<span style="color:#f92672">=</span>task,args<span style="color:#f92672">=</span>(mutex,)) <span style="color:#75715e"># 传入创建的锁</span>
</span></span><span style="display:flex;"><span>    t<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>    t_list<span style="color:#f92672">.</span>append(t)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> t_list:
</span></span><span style="display:flex;"><span>    t<span style="color:#f92672">.</span>join()
</span></span><span style="display:flex;"><span>print(num)
</span></span></code></pre></div><ul>
<li>python多线程是否有用</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>需要分情况
</span></span><span style="display:flex;"><span>	情况1
</span></span><span style="display:flex;"><span>    	单个CPU
</span></span><span style="display:flex;"><span>    	多个CPU
</span></span><span style="display:flex;"><span>	情况2
</span></span><span style="display:flex;"><span>    	IO密集型(代码有IO操作)
</span></span><span style="display:flex;"><span>       计算密集型(代码没有IO)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1.</span>单个CPU
</span></span><span style="display:flex;"><span>	IO密集型
</span></span><span style="display:flex;"><span>    	多进程
</span></span><span style="display:flex;"><span>        申请额外的空间 消耗更多的资源
</span></span><span style="display:flex;"><span>		多线程
</span></span><span style="display:flex;"><span>        消耗资源相对较少 通过多道技术
</span></span><span style="display:flex;"><span>      ps:多线程有优势<span style="color:#960050;background-color:#1e0010">!!!</span>
</span></span><span style="display:flex;"><span> 	计算密集型
</span></span><span style="display:flex;"><span>    	多进程
</span></span><span style="display:flex;"><span>        申请额外的空间 消耗更多的资源(总耗时<span style="color:#f92672">+</span>申请空间<span style="color:#f92672">+</span>拷贝代码<span style="color:#f92672">+</span>切换)
</span></span><span style="display:flex;"><span> 		多线程
</span></span><span style="display:flex;"><span>        消耗资源相对较少 通过多道技术(总耗时<span style="color:#f92672">+</span>切换)
</span></span><span style="display:flex;"><span>      ps:多线程有优势<span style="color:#960050;background-color:#1e0010">!!!</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2.</span>多个CPU
</span></span><span style="display:flex;"><span>	IO密集型
</span></span><span style="display:flex;"><span>   		多进程
</span></span><span style="display:flex;"><span>         总耗时(单个进程的耗时<span style="color:#f92672">+</span>IO<span style="color:#f92672">+</span>申请空间<span style="color:#f92672">+</span>拷贝代码)
</span></span><span style="display:flex;"><span>       多线程
</span></span><span style="display:flex;"><span>    	  总耗时(单个进程的耗时<span style="color:#f92672">+</span>IO)
</span></span><span style="display:flex;"><span>       ps:多线程有优势<span style="color:#960050;background-color:#1e0010">!!!</span>
</span></span><span style="display:flex;"><span>	计算密集型
</span></span><span style="display:flex;"><span>    	多进程
</span></span><span style="display:flex;"><span>       	  总耗时(单个进程的耗时)
</span></span><span style="display:flex;"><span>    	多线程
</span></span><span style="display:flex;"><span>          总耗时(多个进程的综合)
</span></span><span style="display:flex;"><span>       ps:多进程完胜<span style="color:#960050;background-color:#1e0010">!!!</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> threading <span style="color:#f92672">import</span> Thread
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Process
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">work</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 计算密集型</span>
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">100000</span>):
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">*=</span> i
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># print(os.cpu_count())  # 12  查看当前计算机CPU个数</span>
</span></span><span style="display:flex;"><span>    start_time <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># p_list = []</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># for i in range(12):  # 一次性创建12个进程</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#     p = Process(target=work)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#     p.start()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#     p_list.append(p)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># for p in p_list:  # 确保所有的进程全部运行完毕</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#     p.join()</span>
</span></span><span style="display:flex;"><span>    t_list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">12</span>):
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">=</span> Thread(target<span style="color:#f92672">=</span>work)
</span></span><span style="display:flex;"><span>        t<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>        t_list<span style="color:#f92672">.</span>append(t)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> t_list:
</span></span><span style="display:flex;"><span>        t<span style="color:#f92672">.</span>join()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;总耗时:</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> (time<span style="color:#f92672">.</span>time() <span style="color:#f92672">-</span> start_time))  <span style="color:#75715e"># 获取总的耗时</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">计算密集型
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    多进程:5.665567398071289
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    多线程:30.233906745910645
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">work</span>():
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">2</span>)   <span style="color:#75715e"># 模拟纯IO操作</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    start_time <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># t_list = []</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># for i in range(100):</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#     t = Thread(target=work)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#     t.start()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># for t in t_list:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#     t.join()</span>
</span></span><span style="display:flex;"><span>    p_list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">100</span>):
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>work)
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> p_list:
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">.</span>join()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;总耗时:</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> (time<span style="color:#f92672">.</span>time() <span style="color:#f92672">-</span> start_time))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">IO密集型
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    多线程:0.0149583816528320
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    多进程:0.6402878761291504
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span></code></pre></div><ul>
<li>死锁现象</li>
</ul>
<blockquote>
<p>死锁现象非常的有意思，比如说我们面试的时候面试官需要让我们解释死锁
面试官：请你解释一下什么是死锁
候选人：让我进公司就告诉你
面试官：那你先解释什么是死锁
候选人：那你先让我进公司我告诉你啊
以上依次往复，这就是死锁</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 代码实现死锁现象</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> threading <span style="color:#f92672">import</span> Thread,Lock
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mutexA <span style="color:#f92672">=</span> Lock()  <span style="color:#75715e"># 产生一把锁</span>
</span></span><span style="display:flex;"><span>mutexB <span style="color:#f92672">=</span> Lock()  <span style="color:#75715e"># 产生一把锁</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread</span>(Thread):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(self):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>func1()
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>func2()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func1</span>(self):
</span></span><span style="display:flex;"><span>        mutexA<span style="color:#f92672">.</span>acquire()
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">抢到了A锁&#39;</span>)
</span></span><span style="display:flex;"><span>        mutexB<span style="color:#f92672">.</span>acquire()
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">抢到了B锁&#39;</span>)
</span></span><span style="display:flex;"><span>        mutexB<span style="color:#f92672">.</span>release()
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">释放了B锁&#39;</span>)
</span></span><span style="display:flex;"><span>        mutexA<span style="color:#f92672">.</span>release()
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">释放了A锁&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func2</span>(self):
</span></span><span style="display:flex;"><span>        mutexB<span style="color:#f92672">.</span>acquire()
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">抢到了B锁&#39;</span>)
</span></span><span style="display:flex;"><span>        time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        mutexA<span style="color:#f92672">.</span>acquire()
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">抢到了A锁&#39;</span>)
</span></span><span style="display:flex;"><span>        mutexA<span style="color:#f92672">.</span>release()
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">释放了A锁&#39;</span>)
</span></span><span style="display:flex;"><span>        mutexB<span style="color:#f92672">.</span>release()
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">释放了B锁&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>):
</span></span><span style="display:flex;"><span>    obj <span style="color:#f92672">=</span> MyThread()
</span></span><span style="display:flex;"><span>    obj<span style="color:#f92672">.</span>start()
</span></span></code></pre></div><ul>
<li>信号量</li>
</ul>
<blockquote>
<p>信号量需要使用Semaphore，同样在threading模块下</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> threading <span style="color:#f92672">import</span> Thread, Lock, Semaphore
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> randon
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sp <span style="color:#f92672">=</span> Semaphore(<span style="color:#ae81ff">5</span>)  <span style="color:#75715e"># 一次性产生5把锁</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread</span>(Thread):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(self):
</span></span><span style="display:flex;"><span>		sp<span style="color:#f92672">.</span>acquire()
</span></span><span style="display:flex;"><span>		print(self<span style="color:#f92672">.</span>name)
</span></span><span style="display:flex;"><span>		time<span style="color:#f92672">.</span>sleep(random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span>		sp<span style="color:#f92672">.</span>release()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">20</span>):
</span></span><span style="display:flex;"><span>	t <span style="color:#f92672">=</span> MyThread()
</span></span><span style="display:flex;"><span>	t<span style="color:#f92672">.</span>start()
</span></span></code></pre></div><ul>
<li>event事件</li>
</ul>
<blockquote>
<p>相当于依赖，A线程必须等待B线程执行到 event.set()位置后并且自己有event.wait()后才能继续向下执行
使用的是threading下的Event</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> threading <span style="color:#f92672">import</span> Thread, Event
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>event <span style="color:#f92672">=</span> Event()  <span style="color:#75715e"># 类似于造了一个红绿灯</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">light</span>():
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;红灯亮着的 所有人都不能动&#39;</span>)
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;绿灯亮了 油门踩到底 给我冲!!!&#39;</span>)
</span></span><span style="display:flex;"><span>    event<span style="color:#f92672">.</span>set()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">car</span>(name):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">正在等红灯&#39;</span> <span style="color:#f92672">%</span> name)
</span></span><span style="display:flex;"><span>    event<span style="color:#f92672">.</span>wait()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">加油门 飙车了&#39;</span> <span style="color:#f92672">%</span> name)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>t <span style="color:#f92672">=</span> Thread(target<span style="color:#f92672">=</span>light)
</span></span><span style="display:flex;"><span>t<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">20</span>):
</span></span><span style="display:flex;"><span>    t <span style="color:#f92672">=</span> Thread(target<span style="color:#f92672">=</span>car, args<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;熊猫PRO</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> i,))
</span></span><span style="display:flex;"><span>    t<span style="color:#f92672">.</span>start()
</span></span></code></pre></div><ul>
<li>进程池与线程池</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>进程和线程能否无限制的创建 不可以
</span></span><span style="display:flex;"><span>因为硬件的发展赶不上软件 有物理极限 如果我们在编写代码的过程中无限制的创建进程或者线程可能会导致计算机奔溃
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>池
</span></span><span style="display:flex;"><span>	降低程序的执行效率 但是保证了计算机硬件的安全
</span></span><span style="display:flex;"><span>进程池
</span></span><span style="display:flex;"><span>	提前创建好固定数量的进程供后续程序的调用 超出则等待
</span></span><span style="display:flex;"><span>线程池
</span></span><span style="display:flex;"><span>	提前创建好固定数量的线程供后续程序的调用 超出则等待
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> concurrent.futures <span style="color:#f92672">import</span> ProcessPoolExecutor, ThreadPoolExecutor
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> random
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> threading <span style="color:#f92672">import</span> current_thread
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1.产生含有固定数量线程的线程池</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># pool = ThreadPoolExecutor(10)</span>
</span></span><span style="display:flex;"><span>pool <span style="color:#f92672">=</span> ProcessPoolExecutor(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">task</span>(n):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;task is running&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># time.sleep(random.randint(1, 3))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># print(&#39;task is over&#39;, n, current_thread().name)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># print(&#39;task is over&#39;, os.getpid())</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;我是task函数的返回值&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;from func&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 2.将任务提交给线程池即可</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">20</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># res = pool.submit(task, 123)  # 朝线程池提交任务</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># print(res.result())  # 不能直接获取</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># pool.submit(task, 123).add_done_callback(func)</span>
</span></span></code></pre></div><ul>
<li>协程</li>
</ul>
<blockquote>
<p>协程需要使用猴子模块
threading模块通过应用线程实现并发，multiprocessing使用进程实现并发。在python中，还有另外一种实现并发的方式，那就是协程一种单线程单进程的方法来实现并发</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">进程:资源单位
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">线程:执行单位
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">协程:单线程下实现并发(效率极高)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	在代码层面欺骗CPU 让CPU觉得我们的代码里面没有IO操作
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	实际上IO操作被我们自己写的代码检测 一旦有 立刻让代码执行别的
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	(该技术完全是程序员自己弄出来的 名字也是程序员自己起的)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		核心:自己写代码完成切换+保存状态
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> gevent <span style="color:#f92672">import</span> monkey;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>monkey<span style="color:#f92672">.</span>patch_all()  <span style="color:#75715e"># 固定编写 用于检测所有的IO操作(猴子补丁)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> gevent <span style="color:#f92672">import</span> spawn
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func1</span>():
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;func1 running&#39;</span>)
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;func1 over&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func2</span>():
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;func2 running&#39;</span>)
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;func2 over&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    start_time <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># func1()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># func2()</span>
</span></span><span style="display:flex;"><span>    s1 <span style="color:#f92672">=</span> spawn(func1)  <span style="color:#75715e"># 检测代码 一旦有IO自动切换(执行没有io的操作 变向的等待io结束)</span>
</span></span><span style="display:flex;"><span>    s2 <span style="color:#f92672">=</span> spawn(func2)
</span></span><span style="display:flex;"><span>    s1<span style="color:#f92672">.</span>join()
</span></span><span style="display:flex;"><span>    s2<span style="color:#f92672">.</span>join()
</span></span><span style="display:flex;"><span>    print(time<span style="color:#f92672">.</span>time() <span style="color:#f92672">-</span> start_time)  <span style="color:#75715e"># 8.01237154006958   协程 5.015487432479858</span>
</span></span></code></pre></div><ul>
<li>协程实现并发</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> socket
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> gevent <span style="color:#f92672">import</span> monkey;monkey<span style="color:#f92672">.</span>patch_all()  <span style="color:#75715e"># 固定编写 用于检测所有的IO操作(猴子补丁)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> gevent <span style="color:#f92672">import</span> spawn
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">communication</span>(sock):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> sock<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>        print(data<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf8&#39;</span>))
</span></span><span style="display:flex;"><span>        sock<span style="color:#f92672">.</span>send(data<span style="color:#f92672">.</span>upper())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_server</span>():
</span></span><span style="display:flex;"><span>    server <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>socket()
</span></span><span style="display:flex;"><span>    server<span style="color:#f92672">.</span>bind((<span style="color:#e6db74">&#39;127.0.0.1&#39;</span>, <span style="color:#ae81ff">8080</span>))
</span></span><span style="display:flex;"><span>    server<span style="color:#f92672">.</span>listen(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        sock, addr <span style="color:#f92672">=</span> server<span style="color:#f92672">.</span>accept()  <span style="color:#75715e"># IO操作</span>
</span></span><span style="display:flex;"><span>        spawn(communication, sock)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>s1 <span style="color:#f92672">=</span> spawn(get_server)
</span></span><span style="display:flex;"><span>s1<span style="color:#f92672">.</span>join()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>如何不断的提升程序的运行效率
</span></span><span style="display:flex;"><span>	多进程下开多线程 多线程下开协程
</span></span></code></pre></div>
  
  </div>
</article>


    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2022  self-salvation 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
         
        <li><a href="/posts/">All posts</a></li>
         
        <li><a href="/tags">Tags</a></li>
         
        <li><a href="/python">Python</a></li>
         
        <li><a href="/databases">databases</a></li>
         
        <li><a href="/web">web</a></li>
         
        <li><a href="/about">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
