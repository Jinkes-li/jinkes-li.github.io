<!DOCTYPE html>
<html lang="en-us">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <script type="text/javascript" src="https://latest.cactus.chat/cactus.js"></script>
  <link rel="stylesheet" href="https://latest.cactus.chat/style.css" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> 第三周总结 | self-salvation</title>
  <link rel = 'canonical' href = 'https://jinkes-li.github.io/python/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="第三周总结" />
<meta property="og:description" content="第三周总结 文件操作
函数
装饰器
基础算法及表达式
可迭代对象
文件操作
使用python炒作文本文件
创建或打开文件 python中的两种文件操作方式 1. open() # 直接使用open打开文件需要使用close方法关闭文件不推荐使用，仅仅演示 file1 = open(r&#39;a.txt&#39;, &#39;r&#39;, encoding=&#39;utf8&#39;) print(file1.read()) file1.close() 2. with open() # with会自动帮助我们关闭文件，推荐使用 with open(r&#39;a.txt&#39;, &#39;r&#39;, encoding=&#39;utf8&#39;) as f print(f.read()) - 注意在写路径时最好带上r参数，防止win系统下的文件路径被解析为其他含义 编辑文件 文件的读写模式
r - read 只读模式：只能读不能写 w - write 只写模式：只能写不能读，如果不对光标进行操作，w操作会将原文件全部覆盖 a - append 只追加模式，只能在文件的末行追加 r r (读模式，只读不写) # 如果文件不存在直接报错 with open(r&#39;a.txt&#39;, &#39;r&#39;, &#39;encoding&#39;=&#39;utf8&#39;) as f: print(f.read()) -w
w (只写不读) # 文件不存在则会新建 whth open(r&#39;a.txt&#39;, &#39;w&#39;, encoding=&#39;utf8&#39;) as f: f." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jinkes-li.github.io/python/%E7%AC%AC%E4%B8%89%E5%91%A8%E6%80%BB%E7%BB%93/" /><meta property="article:section" content="python" />
<meta property="article:published_time" content="2022-10-16T21:31:48+08:00" />
<meta property="article:modified_time" content="2022-10-16T21:31:48+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="第三周总结"/>
<meta name="twitter:description" content="第三周总结 文件操作
函数
装饰器
基础算法及表达式
可迭代对象
文件操作
使用python炒作文本文件
创建或打开文件 python中的两种文件操作方式 1. open() # 直接使用open打开文件需要使用close方法关闭文件不推荐使用，仅仅演示 file1 = open(r&#39;a.txt&#39;, &#39;r&#39;, encoding=&#39;utf8&#39;) print(file1.read()) file1.close() 2. with open() # with会自动帮助我们关闭文件，推荐使用 with open(r&#39;a.txt&#39;, &#39;r&#39;, encoding=&#39;utf8&#39;) as f print(f.read()) - 注意在写路径时最好带上r参数，防止win系统下的文件路径被解析为其他含义 编辑文件 文件的读写模式
r - read 只读模式：只能读不能写 w - write 只写模式：只能写不能读，如果不对光标进行操作，w操作会将原文件全部覆盖 a - append 只追加模式，只能在文件的末行追加 r r (读模式，只读不写) # 如果文件不存在直接报错 with open(r&#39;a.txt&#39;, &#39;r&#39;, &#39;encoding&#39;=&#39;utf8&#39;) as f: print(f.read()) -w
w (只写不读) # 文件不存在则会新建 whth open(r&#39;a.txt&#39;, &#39;w&#39;, encoding=&#39;utf8&#39;) as f: f."/>

  
  
    
  
  
  <link rel="stylesheet" href="https://jinkes-li.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="https://jinkes-li.github.io/images/favicon.ico" />

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://jinkes-li.github.io/">
  
    <div id="logo" style="background-image: url(https://jinkes-li.github.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>self-salvation</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/posts/">All posts</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
        <li><a href="/python">Python</a></li>
      
        <li><a href="/databases">databases</a></li>
      
        <li><a href="/web">web</a></li>
      
        <li><a href="/about">About</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <h3 id="第三周总结">第三周总结</h3>
<ul>
<li>
<p>文件操作</p>
</li>
<li>
<p>函数</p>
</li>
<li>
<p>装饰器</p>
</li>
<li>
<p>基础算法及表达式</p>
</li>
<li>
<p>可迭代对象</p>
</li>
<li>
<p>文件操作</p>
</li>
</ul>
<blockquote>
<p>使用python炒作文本文件</p>
</blockquote>
<ul>
<li>创建或打开文件
python中的两种文件操作方式</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ae81ff">1.</span> open()  <span style="color:#75715e"># 直接使用open打开文件需要使用close方法关闭文件不推荐使用，仅仅演示</span>
</span></span><span style="display:flex;"><span>file1 <span style="color:#f92672">=</span> open(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;a.txt&#39;</span>, <span style="color:#e6db74">&#39;r&#39;</span>, encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;utf8&#39;</span>)
</span></span><span style="display:flex;"><span>print(file1<span style="color:#f92672">.</span>read())
</span></span><span style="display:flex;"><span>file1<span style="color:#f92672">.</span>close()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2.</span> <span style="color:#66d9ef">with</span> open()  <span style="color:#75715e"># with会自动帮助我们关闭文件，推荐使用</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;a.txt&#39;</span>, <span style="color:#e6db74">&#39;r&#39;</span>, encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;utf8&#39;</span>) <span style="color:#66d9ef">as</span> f
</span></span><span style="display:flex;"><span>    print(f<span style="color:#f92672">.</span>read())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span> 注意在写路径时最好带上r参数<span style="color:#960050;background-color:#1e0010">，</span>防止win系统下的文件路径被解析为其他含义
</span></span></code></pre></div><ul>
<li>编辑文件</li>
</ul>
<blockquote>
<p>文件的读写模式</p>
<ol>
<li>r  - read 只读模式：只能读不能写</li>
<li>w - write 只写模式：只能写不能读，如果不对光标进行操作，w操作会将原文件全部覆盖</li>
<li>a - append 只追加模式，只能在文件的末行追加</li>
</ol>
</blockquote>
<ul>
<li>r</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>r (读模式<span style="color:#960050;background-color:#1e0010">，</span>只读不写)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 如果文件不存在直接报错</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;a.txt&#39;</span>, <span style="color:#e6db74">&#39;r&#39;</span>, <span style="color:#e6db74">&#39;encoding&#39;</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#39;utf8&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    print(f<span style="color:#f92672">.</span>read())
</span></span></code></pre></div><p>-w</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>w (只写不读)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 文件不存在则会新建</span>
</span></span><span style="display:flex;"><span>whth open(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;a.txt&#39;</span>, <span style="color:#e6db74">&#39;w&#39;</span>, encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;utf8&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#39;aaa&#39;</span>)
</span></span></code></pre></div><ul>
<li>a</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 文件不存在则新建，</span>
</span></span><span style="display:flex;"><span>a (追加写模式)
</span></span><span style="display:flex;"><span>whth open(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;a.txt&#39;</span>, <span style="color:#e6db74">&#39;a&#39;</span>, encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;utf8&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(<span style="color:#e6db74">&#39;aaa&#39;</span>)
</span></span></code></pre></div><ul>
<li>保存文件</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#  如果在写一些比较重要的数据时，可以在写完数据后使用flush将修改的内容刷入磁盘</span>
</span></span><span style="display:flex;"><span>f<span style="color:#f92672">.</span>flush()
</span></span></code></pre></div><ul>
<li>关闭文件</li>
</ul>
<ol>
<li>如果直接使用open打开文件在写完数据后需要使用close来关闭文件</li>
<li>如果使用with的方式来操作文件后，with的好处说不需要写close也会帮我们关闭文件这也就是为什么推荐使用with的理由</li>
</ol>
<ul>
<li>文件的操作模式</li>
</ul>
<ol>
<li>文件的操作模式分为两种一种是默认存在的&rsquo;t&rsquo;,另外一种是&rsquo;b&rsquo;模式</li>
<li>&rsquo;t&rsquo;, 只能对文本文件进行操作需要添加encoding参数
2.1 这个t默认是可以被省略的，对文本操作时最小单位是文本的最小单位字符</li>
<li>&lsquo;b&rsquo;，可以对任何文件进行操作，不需要添加encoding参数
3.1 b模式也叫二进制模式，是用改模式时不可被省略，并且使用该模式对文件进行操作时最小单位是字节</li>
</ol>
<ul>
<li>文件的内置方法</li>
</ul>
<ol>
<li>read() 一次性读取文件中的内容，如果文件很大不建议使用，可能会造成内存溢出</li>
<li>readline() 读取出来时是列表，文件中的每一行就是列表中的元素</li>
<li>readable() 判断当前文件是否可读，返回值是bool</li>
<li>write() 写入文件是字符串或者是bytes类型</li>
<li>writeanle() 判断当前文件是否可写，返回值是bool</li>
<li>flush() 保存的意思，执行时会将写入文件中的数据强制写到硬盘上去</li>
</ol>
<ul>
<li>文件光标移动</li>
</ul>
<ol>
<li>tell()  显示当前光标所在位置</li>
<li>seek
2.1 seek(参数，模式)
2.2种模式 分别是 0 代表行首，1 代表当前光标位置， 2代表行尾</li>
</ol>
<ul>
<li>函数</li>
</ul>
<blockquote>
<p>函数就相当于提前准备好的工具，需要使用的时候可以直接调用</p>
</blockquote>
<ul>
<li>函数的语法结构</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">函数名</span>():
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;&#34;&#34;函数说明&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>		函数体代码
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> 返回值
</span></span><span style="display:flex;"><span><span style="color:#75715e">#  默认返回在为空</span>
</span></span></code></pre></div><ul>
<li>函数的定义与调用</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 使用def定义函数</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func</span>():
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;&#34;&#34;xxx&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pass</span>
</span></span></code></pre></div><ul>
<li>函数的分类</li>
<li>空函数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func</span>():
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 空函数一般都是用户在做项目时做功能占位使用</span>
</span></span></code></pre></div><ul>
<li>无参函数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func</span>():
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;我是一个空函数&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 不需要传任何参数都可以调用</span>
</span></span></code></pre></div><ul>
<li>有参函数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func</span>(name, age):
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;名字：</span><span style="color:#e6db74">{</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74"> 年龄：</span><span style="color:#e6db74">{</span>age<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 有参函数需要传对应的位参</span>
</span></span></code></pre></div><ul>
<li>函数的返回值</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 函数的返回值</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1.</span> 在函数中如果不写return<span style="color:#960050;background-color:#1e0010">，</span>返回值默认为Noen
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2.</span> 在函数中如果写了return 没有指定返回值默认为Noen
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3.</span> 写了return 并指定了返回值 返回值就是什么
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4.</span> 若return 指定多个返回值需要用逗号隔开并以元组的形式返回
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5.</span> 函数体如果遇到return则会结束
</span></span></code></pre></div><ul>
<li>函数的参数</li>
</ul>
<blockquote>
<p>函数的参数类型很多，主要分为形参和实参</p>
</blockquote>
<ol>
<li>形参：就是在函数定义阶段定义的参数，需要传参使用，本质没有意义
形参主要分为：
1.1 位置形参：从左往右依次传参
1.2 默认参数：提前定好参数，不是必须要传
1.3 可变长行参：一个※号代表可以接受多余的位置参数 2个※号可以接收多余的关键字参数，需要注意多余的位置参数会以元组的形式返回，多余的关键字参数会以字典的形式返回</li>
<li>实参：在函数调用阶段需要传参给函数的形参接收，具有意义
2.1 位置实参： 在含义调用阶段从左往右传入的参数
2.2 关键字实参： 可以指定吧值传给那个形参
2.3 命名关键字： 不经常使用，相当于关键字参数，只是位置放在可边长参数的中间
2.3 可边长参数： 一个※可变长参数，将数据for循环的方式传入，※※需要传入字典或关键字参数</li>
</ol>
<ul>
<li>名称空与作用域</li>
<li>名称空间：</li>
</ul>
<blockquote>
<p>名称空间是存储变量名和函数名类名以及它们与数据值的绑定关系的地方
作用域是这个名称空间的作用范围</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 名称空间</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1.</span> 内置名称空间<span style="color:#960050;background-color:#1e0010">：</span>在哪都可以调用
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2.</span> 全局名称空间<span style="color:#960050;background-color:#1e0010">：</span>全局和局部中调用
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3.</span> 局部名称空间<span style="color:#960050;background-color:#1e0010">：</span>局部中调用
</span></span><span style="display:flex;"><span>优先级<span style="color:#960050;background-color:#1e0010">，</span>局部名称空间<span style="color:#f92672">-&gt;</span>全局名称空间<span style="color:#f92672">-&gt;</span>内置名称空间
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 作用域</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1.</span> 内置名称空间的作用域说任何地方都可以调用
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2.</span> 全局名称空间是在全局和局部中可以调用
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3.</span> 局部名称空间是在局部中可以调用
</span></span></code></pre></div><ul>
<li>golbal与nonlocal</li>
</ul>
<ol>
<li>golbal： 如果在局部中向修改全局名称空间的变量，需要使用golbal关键字指定这个全局中的变量名，例如golbal = name</li>
<li>nonlocal：用于在闭包中修改上层闭包中的变量</li>
</ol>
<ul>
<li>函数名的多种用法</li>
</ul>
<ol>
<li>函数名可以作为变量名来调用</li>
<li>函数名可以作为参数使用</li>
<li>函数名可以作为返回值</li>
<li>函数名可以作为容器中的值</li>
</ol>
<ul>
<li>闭包函数</li>
</ul>
<blockquote>
<p>闭包函数需要满足2个条件</p>
<ol>
<li>被上层函数包裹起来</li>
<li>调用了上层函数的值或者变量</li>
<li>闭包函数实际上是另一种给函数传值的方式</li>
</ol>
</blockquote>
<ul>
<li>递归函数</li>
</ul>
<blockquote>
<ol>
<li>递归：根据条件一层一层寻找，每一次都比上一次简单，直到得到结果值</li>
<li>回溯：从结果值返回 每一层都会附加条件带回递归之初
递归函数，被嵌套的函数，用到了上层的数据值，并调用自身，有明确的结束条件
需要注意的是递归函数时有最大的递归次数，官方规定最大值在1000次左右</li>
</ol>
</blockquote>
<ul>
<li>装饰器（新手难点）</li>
<li>装饰器简介</li>
</ul>
<blockquote>
<p>装饰器概念，在不改变源代码和调用方式的情况下添加新的功能
装饰器是由，闭包函数，函数参数，函数名的多种用法，名称空间组成的
理解概念就是对修改封闭，对扩展开放</p>
</blockquote>
<ul>
<li>无参装饰器</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">outer</span>(func_name):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inner</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>    	<span style="color:#e6db74">&#34;&#34;&#34;函数执行前的操作&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> func_name(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#34;&#34;&#34;函数执行后的操作&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> inner
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 前后操作的中间两行就是源函数本身</span>
</span></span></code></pre></div><ul>
<li>有参装饰器</li>
</ul>
<blockquote>
<p>如果我们在使用装饰器时需要使用额外的参数时就需要使用有参装饰器</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 有参装饰器模版</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">xxx</span>(id):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">outer</span>(func_name):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inner</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> func_name(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> res
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> inner
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> outer
</span></span></code></pre></div><ul>
<li>装饰器语法糖及修复技术</li>
</ul>
<blockquote>
<p>语法糖就是代替了原本使用装饰器时需要再调用函数时写的func = outer(func)
修复技术可以将被装饰的函数伪装的更彻底</p>
</blockquote>
<ul>
<li>语法糖的使用</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># outers是装饰器的名字，</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@outer</span>  <span style="color:#75715e"># 无参装饰器使用</span>
</span></span><span style="display:flex;"><span>func()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@outer</span>(<span style="color:#e6db74">&#39;1&#39;</span>)  <span style="color:#75715e"># 有参装饰器使用</span>
</span></span><span style="display:flex;"><span>func()
</span></span></code></pre></div><ul>
<li>修复技术</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 没有修复前</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">outer</span>(func_name):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inner</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;我是inner&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> func_name(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> inner
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@outer</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func1</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;我是func1&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;123&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>help(func1)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 结果</span>
</span></span><span style="display:flex;"><span>inner(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>    我是inner
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 修复后</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> functools <span style="color:#f92672">import</span> wraps
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">outer</span>(func_name):
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@wraps</span>(func_name)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inner</span>(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;我是inner&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> func_name(<span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> inner
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@outer</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">func1</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;我是func1&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;123&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>help(func1)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 结果</span>
</span></span><span style="display:flex;"><span>func1()
</span></span><span style="display:flex;"><span>    我是func1
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 这样就算是使用了装饰器，但是看起来和源函数一模一样</span>
</span></span></code></pre></div><ul>
<li>多层装饰器</li>
</ul>
<blockquote>
<p>如果语法糖由多层，执行顺序是由下向上执行
会讲第一次语法糖拿到的返回值交由上面的语法糖使用，直到上面没有语法糖</p>
</blockquote>
<ul>
<li>基础算法及表达式</li>
</ul>
<blockquote>
<p>算法就是为了解决某种场景的解决方案，算法和我们的生活息息相关</p>
<ol>
<li>比如淘宝的推荐购物算法</li>
<li>抖音的视频推荐算法</li>
<li>短信营销的人群算法</li>
</ol>
</blockquote>
<ul>
<li>二分法</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 二分法的原理就是利用取中间值的方式比对需要寻找的值，根据判断左右切割反复如此找到数据</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 二分法查找的数据必须是由小到大的，或者是从大到小的</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 代码实现</span>
</span></span><span style="display:flex;"><span>l1 <span style="color:#f92672">=</span> [<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">21</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">43</span>, <span style="color:#ae81ff">56</span>, <span style="color:#ae81ff">76</span>, <span style="color:#ae81ff">87</span>, <span style="color:#ae81ff">98</span>, <span style="color:#ae81ff">123</span>, <span style="color:#ae81ff">321</span>, <span style="color:#ae81ff">453</span>, <span style="color:#ae81ff">565</span>, <span style="color:#ae81ff">678</span>, <span style="color:#ae81ff">754</span>, <span style="color:#ae81ff">812</span>, <span style="color:#ae81ff">987</span>, <span style="color:#ae81ff">1001</span>, <span style="color:#ae81ff">1232</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 定以函数并传入需要寻找的值</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">look</span>(l1, res_num):
</span></span><span style="display:flex;"><span>    median <span style="color:#f92672">=</span> len(l1) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 判断，列表中的索引的值是否大于传入的值</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> res_num <span style="color:#f92672">&gt;</span> l1[median]:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 如果大于，将原列表中的后面的值取出赋值为new_list</span>
</span></span><span style="display:flex;"><span>        new_list <span style="color:#f92672">=</span> l1[median:]
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 返回函数重新调用</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> look(new_list, res_num)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> res_num <span style="color:#f92672">&lt;</span> l1[median]:
</span></span><span style="display:flex;"><span>        new_list <span style="color:#f92672">=</span> l1[:median]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> look(new_list, res_num)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;找到了&#39;</span>)
</span></span><span style="display:flex;"><span>look(l1,<span style="color:#ae81ff">1</span>)
</span></span></code></pre></div><ul>
<li>三元表达式</li>
</ul>
<blockquote>
<p>简化代码</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>语法为<span style="color:#960050;background-color:#1e0010">：</span>数据值1 <span style="color:#66d9ef">if</span> 条件 <span style="color:#66d9ef">else</span> 数据值2
</span></span><span style="display:flex;"><span>条件成立执行数据值1
</span></span><span style="display:flex;"><span>条件不成立执行数据值二
</span></span><span style="display:flex;"><span>name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;wesley&#39;</span>
</span></span><span style="display:flex;"><span>res <span style="color:#f92672">=</span> name <span style="color:#f92672">+</span><span style="color:#e6db74">&#39;nb&#39;</span> <span style="color:#66d9ef">if</span> name <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;wesley&#39;</span> <span style="color:#66d9ef">else</span> print(<span style="color:#e6db74">&#39;666&#39;</span>)
</span></span><span style="display:flex;"><span>print(res)
</span></span></code></pre></div><ul>
<li>各种生成式</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>列表生成式
</span></span><span style="display:flex;"><span>name_list <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;jason&#39;</span>, <span style="color:#e6db74">&#39;kevin&#39;</span>, <span style="color:#e6db74">&#39;oscar&#39;</span>, <span style="color:#e6db74">&#39;tony&#39;</span>, <span style="color:#e6db74">&#39;jerry&#39;</span>]
</span></span><span style="display:flex;"><span>res <span style="color:#f92672">=</span> [i <span style="color:#f92672">+</span><span style="color:#e6db74">&#39;123&#39;</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> name_list <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;jason&#39;</span> ]
</span></span><span style="display:flex;"><span>print(res)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>字典生成式
</span></span><span style="display:flex;"><span>enumerater()可以给数据打上对应的编号
</span></span><span style="display:flex;"><span>s1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;hello&#39;</span>
</span></span><span style="display:flex;"><span>res <span style="color:#f92672">=</span> {i:j <span style="color:#66d9ef">for</span> i,j <span style="color:#f92672">in</span> enumerate(s1)}
</span></span><span style="display:flex;"><span>print(res)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>集合生成式
</span></span><span style="display:flex;"><span>s1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;hello&#39;</span>
</span></span><span style="display:flex;"><span>res <span style="color:#f92672">=</span> {i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> s1}
</span></span><span style="display:flex;"><span>print(res)
</span></span></code></pre></div><ul>
<li>匿名函数</li>
</ul>
<blockquote>
<p>匿名函数：没有名字的函数需要和lambda一起配合使用</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>l1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> a,b:a<span style="color:#f92672">+</span>b
</span></span><span style="display:flex;"><span>print(l1(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>))
</span></span></code></pre></div><ul>
<li>重要内置函数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># map 映射</span>
</span></span><span style="display:flex;"><span>l1 <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>res <span style="color:#f92672">=</span> map(<span style="color:#66d9ef">lambda</span> a: a <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, l1)
</span></span><span style="display:flex;"><span>print(list(res))
</span></span><span style="display:flex;"><span>[<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># max min 取最小值</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># reduce 传入多个值，返回一个值</span>
</span></span></code></pre></div><ul>
<li>
<p>常见内置函数</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>内置函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>abs()</td>
<td>求绝对值</td>
</tr>
<tr>
<td>2</td>
<td>all() ， any()</td>
<td>判断容器类型中所有的数据值对应的布尔值是否为Ture</td>
</tr>
<tr>
<td>3</td>
<td>bin()，oct(), hex,</td>
<td>进制转换</td>
</tr>
<tr>
<td>4</td>
<td>int()</td>
<td>进制转换，其他进制转十进制</td>
</tr>
<tr>
<td>5</td>
<td>bytes()</td>
<td>类型转换</td>
</tr>
<tr>
<td>6</td>
<td>Callable()</td>
<td>call在IT专业名词中翻译成调用</td>
</tr>
<tr>
<td>7</td>
<td>chr(),ord()</td>
<td>依据ASCII码表实现字符与字符的转换</td>
</tr>
<tr>
<td>8</td>
<td>dir()</td>
<td>获取对象内部可以通过句点符获取的数据</td>
</tr>
<tr>
<td>9</td>
<td>divmod()</td>
<td>获取除法之后的整数和与数</td>
</tr>
<tr>
<td>10</td>
<td>enumerate()</td>
<td>枚举</td>
</tr>
<tr>
<td>11</td>
<td>eval(),exec()</td>
<td>能够识别字符串中python代码并执行</td>
</tr>
<tr>
<td>12</td>
<td>hash()</td>
<td>对数据进行hash加密，返回一串哈希值</td>
</tr>
<tr>
<td>13</td>
<td>help()</td>
<td>查看帮助信息</td>
</tr>
<tr>
<td>14</td>
<td>Isinstance(123,int)</td>
<td>True</td>
</tr>
<tr>
<td>15</td>
<td>isinstance(123, str)</td>
<td>False</td>
</tr>
<tr>
<td>16</td>
<td>pow()</td>
<td>幂指数</td>
</tr>
<tr>
<td>17</td>
<td>round()</td>
<td>四舍五入</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>可迭代对象</p>
</li>
</ul>
<blockquote>
<p>可迭代对象就是根据上一次的内容进行迭代
如何判断可迭代对象，可以使用句点符调用__iter__方法的都是可迭代对象
可以被for循环的都是可迭代对象</p>
</blockquote>
<ul>
<li>迭代器对象</li>
</ul>
<blockquote>
<p>迭代器对象是具有__iter__和__next__两种方法的都是迭代器对象
可迭代对象使用iter转换后可转换成具有next的迭代器对象</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>可迭代对象取值
</span></span><span style="display:flex;"><span>d1 <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;name&#39;</span>: <span style="color:#e6db74">&#39;wesley&#39;</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#e6db74">&#39;pwd&#39;</span>: <span style="color:#ae81ff">123</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>res <span style="color:#f92672">=</span> d1<span style="color:#f92672">.</span>__iter__()
</span></span><span style="display:flex;"><span>print(res<span style="color:#f92672">.</span>__next__())
</span></span></code></pre></div><ul>
<li>for 循环本质</li>
</ul>
<blockquote>
<p>for循环本质就是将数据使用iter方法转为迭代器对象，然后使用next取值
取完值后处理异常
可迭代对象。迭代对象，通过答应无法直接看出来 相当于工厂，需要数据直接要就可以了，这个机制及比较节省内存</p>
</blockquote>
<ul>
<li>异常</li>
</ul>
<blockquote>
<p>异常就是常说的bug</p>
</blockquote>
<p>分为两种:
语法异常：
语法异常是不允许被出现的，一般都是语法错误
逻辑异常
逻辑异常允许出现，一般是因为逻辑出错导致程序出现bug</p>

  
  </div>
</article>


    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2022  self-salvation 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
         
        <li><a href="/posts/">All posts</a></li>
         
        <li><a href="/tags">Tags</a></li>
         
        <li><a href="/python">Python</a></li>
         
        <li><a href="/databases">databases</a></li>
         
        <li><a href="/web">web</a></li>
         
        <li><a href="/about">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
