<!DOCTYPE html>
<html lang="en-us">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <script type="text/javascript" src="https://latest.cactus.chat/cactus.js"></script>
  <link rel="stylesheet" href="https://latest.cactus.chat/style.css" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> 网络技术(下) | self-salvation</title>
  <link rel = 'canonical' href = 'https://jinkes-li.github.io/python/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8B/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="网络技术(下)" />
<meta property="og:description" content="网络编程 传输层之TCP与UDP 应用层 socket模块简介 socket模块基本使用 代码优化处理 socket黏包问题 黏包问题的解决问题 TCP/IP协议簇 由多个协议组成，其中以TCP于IP为代表，本文详细介绍TCP和UDP
UDP协议 UDP协议定义了端口，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息，当数据包到达主机以后，就可以根据端口号找到对应的应用程序了。UDP协议比较简单，实现容易，但它没有确认机制，数据包一旦发出，无法知道对方是否收到，因此可靠性较差，为了解决这个问题，提高网络可靠性，TCP协议就诞生了。 TCP协议 TCP即传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议。简单来说TCP就是有确认机制的UDP协议，每发出一个数据包都要求确认，如果有一个数据包丢失，就收不到确认，发送方就必须重发这个数据包。为了保证传输的可靠性，TCP协议在UDP基础之上建立了三次对话的确认机制，即在正式收发数据前，必须和对方建立可靠的连接。TCP数据包和UDP一样，都是由首部和数据两部分组成，唯一不同的是，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 TCP和UDP主要区别 简单来说一个TCP需要建立通道确认应答，UDP则直接发送 这里借鉴鸡哥博客中的原理图
TCP重要原理图，三次握手四次挥手 应用层 应用层相当于是相当于程序员自己写的程序，本层具有相当多的协议 这里常需要使用的是httpshttp FTP
socket模块 Socket 是应用层于TCP/IP协议簇通信的之间软件抽象层，是一组接口，在设计模式中，Socket其实就是一个门面模式 把复杂的TCP/IP协议簇隐藏在Socket接口后面，对于用户来说直接调用接口，已符合指定的协议
套接字（socket）的发展史 套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。
基于文件类型的套接字家族 套接字家族的名字：AF_UNIX unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信
基于网络类型的套接字家族 套接字家族的名字：AF_INET (还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)
Socket-TCP在python中的应用 本质上来说python中的Socket是一个类，也是一个内置模块，需要导入使用
1. Server import socket &#34;&#34;&#34; 在写代码时建议查看源码写代码的思路 &#34;&#34;&#34; # 1. 产生一个Socket对象并指定采用的通信版本和协议（TCP） server = socket.socket() # 括号内不写参数，默认使用TCP协议，查看源码得知family=AF_INET基于网络的套接字， type=SOCK_STREAM流式协议即TCP # 2. 绑定一个固定的地址，需要设定对外提供服务的端口和IP server.bind((&#39;127.0.0.1&#39;, 8080)) # 3. 设立半连接池 server." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jinkes-li.github.io/python/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%8B/" /><meta property="article:section" content="python" />
<meta property="article:published_time" content="2022-11-16T19:12:45+08:00" />
<meta property="article:modified_time" content="2022-11-16T19:12:45+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="网络技术(下)"/>
<meta name="twitter:description" content="网络编程 传输层之TCP与UDP 应用层 socket模块简介 socket模块基本使用 代码优化处理 socket黏包问题 黏包问题的解决问题 TCP/IP协议簇 由多个协议组成，其中以TCP于IP为代表，本文详细介绍TCP和UDP
UDP协议 UDP协议定义了端口，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息，当数据包到达主机以后，就可以根据端口号找到对应的应用程序了。UDP协议比较简单，实现容易，但它没有确认机制，数据包一旦发出，无法知道对方是否收到，因此可靠性较差，为了解决这个问题，提高网络可靠性，TCP协议就诞生了。 TCP协议 TCP即传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议。简单来说TCP就是有确认机制的UDP协议，每发出一个数据包都要求确认，如果有一个数据包丢失，就收不到确认，发送方就必须重发这个数据包。为了保证传输的可靠性，TCP协议在UDP基础之上建立了三次对话的确认机制，即在正式收发数据前，必须和对方建立可靠的连接。TCP数据包和UDP一样，都是由首部和数据两部分组成，唯一不同的是，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 TCP和UDP主要区别 简单来说一个TCP需要建立通道确认应答，UDP则直接发送 这里借鉴鸡哥博客中的原理图
TCP重要原理图，三次握手四次挥手 应用层 应用层相当于是相当于程序员自己写的程序，本层具有相当多的协议 这里常需要使用的是httpshttp FTP
socket模块 Socket 是应用层于TCP/IP协议簇通信的之间软件抽象层，是一组接口，在设计模式中，Socket其实就是一个门面模式 把复杂的TCP/IP协议簇隐藏在Socket接口后面，对于用户来说直接调用接口，已符合指定的协议
套接字（socket）的发展史 套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。
基于文件类型的套接字家族 套接字家族的名字：AF_UNIX unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信
基于网络类型的套接字家族 套接字家族的名字：AF_INET (还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)
Socket-TCP在python中的应用 本质上来说python中的Socket是一个类，也是一个内置模块，需要导入使用
1. Server import socket &#34;&#34;&#34; 在写代码时建议查看源码写代码的思路 &#34;&#34;&#34; # 1. 产生一个Socket对象并指定采用的通信版本和协议（TCP） server = socket.socket() # 括号内不写参数，默认使用TCP协议，查看源码得知family=AF_INET基于网络的套接字， type=SOCK_STREAM流式协议即TCP # 2. 绑定一个固定的地址，需要设定对外提供服务的端口和IP server.bind((&#39;127.0.0.1&#39;, 8080)) # 3. 设立半连接池 server."/>

  
  
    
  
  
  <link rel="stylesheet" href="https://jinkes-li.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="https://jinkes-li.github.io/images/favicon.ico" />

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://jinkes-li.github.io/">
  
    <div id="logo" style="background-image: url(https://jinkes-li.github.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>self-salvation</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/posts/">All posts</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
        <li><a href="/python">Python</a></li>
      
        <li><a href="/about">About</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <h3 id="网络编程">网络编程</h3>
<ul>
<li>传输层之TCP与UDP</li>
<li>应用层</li>
<li>socket模块简介</li>
<li>socket模块基本使用</li>
<li>代码优化处理</li>
<li>socket黏包问题</li>
<li>黏包问题的解决问题</li>
</ul>
<ol>
<li>TCP/IP协议簇</li>
</ol>
<blockquote>
<p>由多个协议组成，其中以TCP于IP为代表，本文详细介绍TCP和UDP</p>
</blockquote>
<ol>
<li>UDP协议
UDP协议定义了端口，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息，当数据包到达主机以后，就可以根据端口号找到对应的应用程序了。UDP协议比较简单，实现容易，但它没有确认机制，数据包一旦发出，无法知道对方是否收到，因此可靠性较差，为了解决这个问题，提高网络可靠性，TCP协议就诞生了。</li>
<li>TCP协议
TCP即传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议。简单来说TCP就是有确认机制的UDP协议，每发出一个数据包都要求确认，如果有一个数据包丢失，就收不到确认，发送方就必须重发这个数据包。为了保证传输的可靠性，TCP协议在UDP基础之上建立了三次对话的确认机制，即在正式收发数据前，必须和对方建立可靠的连接。TCP数据包和UDP一样，都是由首部和数据两部分组成，唯一不同的是，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</li>
</ol>
<ul>
<li>TCP和UDP主要区别</li>
</ul>
<blockquote>
<p>简单来说一个TCP需要建立通道确认应答，UDP则直接发送
这里借鉴鸡哥博客中的原理图</p>
</blockquote>
<p><img src="https://images2017.cnblogs.com/blog/827651/201710/827651-20171027102242789-2142796570.jpg" alt=""></p>
<h4 id="tcp重要原理图三次握手四次挥手">TCP重要原理图，三次握手四次挥手</h4>
<ul>
<li>应用层</li>
</ul>
<blockquote>
<p>应用层相当于是相当于程序员自己写的程序，本层具有相当多的协议
这里常需要使用的是httpshttp FTP</p>
</blockquote>
<ul>
<li>socket模块</li>
</ul>
<blockquote>
<p>Socket 是应用层于TCP/IP协议簇通信的之间软件抽象层，是一组接口，在设计模式中，Socket其实就是一个门面模式 把复杂的TCP/IP协议簇隐藏在Socket接口后面，对于用户来说直接调用接口，已符合指定的协议</p>
</blockquote>
<ul>
<li>套接字（socket）的发展史</li>
</ul>
<blockquote>
<p>套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。</p>
</blockquote>
<p>基于文件类型的套接字家族
套接字家族的名字：AF_UNIX
unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信</p>
<p>基于网络类型的套接字家族
套接字家族的名字：AF_INET
(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)</p>
<ul>
<li>Socket-TCP在python中的应用</li>
</ul>
<blockquote>
<p>本质上来说python中的Socket是一个类，也是一个内置模块，需要导入使用</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ae81ff">1.</span> Server
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> socket
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">在写代码时建议查看源码写代码的思路
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1. 产生一个Socket对象并指定采用的通信版本和协议（TCP）</span>
</span></span><span style="display:flex;"><span>server <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>socket()  <span style="color:#75715e"># 括号内不写参数，默认使用TCP协议，查看源码得知family=AF_INET基于网络的套接字， type=SOCK_STREAM流式协议即TCP</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. 绑定一个固定的地址，需要设定对外提供服务的端口和IP</span>
</span></span><span style="display:flex;"><span>server<span style="color:#f92672">.</span>bind((<span style="color:#e6db74">&#39;127.0.0.1&#39;</span>, <span style="color:#ae81ff">8080</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. 设立半连接池</span>
</span></span><span style="display:flex;"><span>server<span style="color:#f92672">.</span>listen(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. 等待客户端访问</span>
</span></span><span style="display:flex;"><span>sock, addr <span style="color:#f92672">=</span> server<span style="color:#f92672">.</span>accept()  <span style="color:#75715e"># sock为建立的双向通道，addr为客户端地址</span>
</span></span><span style="display:flex;"><span>print(sock, addr)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 5. 响应客户端</span>
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> sock<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)  <span style="color:#75715e"># 消息现在为1024字节</span>
</span></span><span style="display:flex;"><span>print(data<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf8&#39;</span>))
</span></span><span style="display:flex;"><span>sock<span style="color:#f92672">.</span>send(<span style="color:#e6db74">&#39;我是服务端&#39;</span><span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf8&#39;</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 6. 关闭双向通道</span>
</span></span><span style="display:flex;"><span>sock<span style="color:#f92672">.</span>close()  <span style="color:#75715e"># 四次挥手</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 7. 关闭服务端</span>
</span></span><span style="display:flex;"><span>server<span style="color:#f92672">.</span>close()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2.</span> Client
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> socket
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1. 生成socket对象指定的类型和协议</span>
</span></span><span style="display:flex;"><span>client <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>socket()
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. 通过服务端的地址链接服务端</span>
</span></span><span style="display:flex;"><span>client<span style="color:#f92672">.</span>connect((<span style="color:#e6db74">&#39;127.0.0.1&#39;</span>, <span style="color:#ae81ff">8080</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. 直接给服务端发送消息</span>
</span></span><span style="display:flex;"><span>client<span style="color:#f92672">.</span>send(<span style="color:#e6db74">&#39;我是客户端&#39;</span><span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf8&#39;</span>))  <span style="color:#75715e"># 使用send是一次性发送消息</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. 接受服务端返回的消息</span>
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> client<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>print(data<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf8&#39;</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 5. 断开于服务端的链接</span>
</span></span><span style="display:flex;"><span>client<span style="color:#f92672">.</span>close()
</span></span></code></pre></div><ul>
<li>基于基础代码优化</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ae81ff">1.</span> server
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> socket
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> socket <span style="color:#f92672">import</span> SOL_SOCKET, SO_REUSEADDR
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>server <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>socket()
</span></span><span style="display:flex;"><span>server<span style="color:#f92672">.</span>setsockopt(SOL_SOCKET, SO_REUSEADDR, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>server<span style="color:#f92672">.</span>bind((<span style="color:#e6db74">&#39;127.0.0.1&#39;</span>, <span style="color:#ae81ff">8080</span>))
</span></span><span style="display:flex;"><span>server<span style="color:#f92672">.</span>listen(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>    sock, addr <span style="color:#f92672">=</span> server<span style="color:#f92672">.</span>accept()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>            date <span style="color:#f92672">=</span> sock<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> len(date)  <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;来自客户端</span><span style="color:#e6db74">{</span>addr<span style="color:#e6db74">}</span><span style="color:#e6db74">的消息&gt;&gt;&gt;:&#39;</span>, date<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf8&#39;</span>))
</span></span><span style="display:flex;"><span>            msg <span style="color:#f92672">=</span> input(<span style="color:#e6db74">&#39;请输入发送给客户端的消息&gt;&gt;&gt;&gt;: &#39;</span>)
</span></span><span style="display:flex;"><span>            sock<span style="color:#f92672">.</span>send(msg<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf8&#39;</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">BaseException</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2.</span> client
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> socket
</span></span><span style="display:flex;"><span>client <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>socket()
</span></span><span style="display:flex;"><span>client<span style="color:#f92672">.</span>connect((<span style="color:#e6db74">&#39;127.0.0.1&#39;</span>, <span style="color:#ae81ff">8080</span>))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>    msg <span style="color:#f92672">=</span> input(<span style="color:#e6db74">&#39;请输入你想发送给服务端的消息&gt;&gt;&gt;&gt;: &#39;</span>)<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;UTF-8&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(msg) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;不能为空&#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>    client<span style="color:#f92672">.</span>send(msg)
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> client<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;来自服务器发送的消息&gt;&gt;&gt;:&#39;</span>, data<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;UTF-8&#39;</span>))
</span></span></code></pre></div>
  
  </div>
</article>


    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2022  self-salvation 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
         
        <li><a href="/posts/">All posts</a></li>
         
        <li><a href="/tags">Tags</a></li>
         
        <li><a href="/python">Python</a></li>
         
        <li><a href="/about">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
