<!DOCTYPE html>
<html lang="en-us">
<head>
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/font-awesome/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" href="/lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <script type="text/javascript" src="https://latest.cactus.chat/cactus.js"></script>
  <link rel="stylesheet" href="https://latest.cactus.chat/style.css" type="text/css">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> 第七周总结 | self-salvation</title>
  <link rel = 'canonical' href = 'https://jinkes-li.github.io/python/%E7%AC%AC%E4%B8%83%E5%91%A8%E6%80%BB%E7%BB%93/'>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta property="og:title" content="第七周总结" />
<meta property="og:description" content="网络编程 网络名词 单机： 单台计算机无法与其他计算机通讯 联机：一般指两台计算机可以进行相互通讯 局域网： 一个独立的网络环境内使用统一网段和子网掩码的计算机使用交换机相互通信 广域网： 涉及现代社会中的一个区或更大范围的地址，每个独立的局域网使用上层交换机和路由器进行信息交互 省网： 以省级单位为区域的计算机信息交互 国网： 同省级相同理念 以上数据交互可统称为以太网或者互联网
广播 主机之间“一对所有”的通讯模式，网络对其中每一台主机发出的信号都进行无条件复制并转发，所有主机都可以接收到所有信息（不管你是否需要），由于其不用路径选择，所以其网络成本可以很低廉。有线电视网就是典型的广播型网络，我们的电视机实际上是接受到所有频道的信号，但只将一个频道的信号还原成画面。在数据网络中也允许广播的存在，但其被限制在二层交换机的局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机
ip地址与ip协议 规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4 它规定网络地址由32位2进制表示 范围0.0.0.0-255.255.255.255 一个ip地址通常写成四段十进制数，例：172.16.10.1
mac地址
head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址。 mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）
arp协议 ——查询IP地址和MAC地址的对应关系 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。 主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址。 收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。 地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。
路由器 路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。 路由器是互联网络的枢纽，&ldquo;交通警察&rdquo;。目前路由器已经广泛应用于各行各业，各种不同档次的产品已成为实现各种骨干网内部连接、骨干网间互联和骨干网与互联网互联互通业务的主力军。路由和交换机之间的主要区别就是交换机发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换机在移动信息的过程中需使用不同的控制信息，所以说两者实现各自功能的方式是不同的。
局域网 局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。　子网掩码　所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。
比如，已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算， 172.16.10.1：10101100.00010000.00001010.000000001 255255.255.255.0:11111111.11111111.11111111.00000000 AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0 172.16.10.2：10101100.00010000.00001010.00000010 255255.255.255.0:11111111.11111111.11111111.00000000 AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0 结果都是172.16.10.0，因此它们在同一个子网络。 总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。
tcp协议和udp协议 用于应用程序之间的通信。如果说ip地址和mac地址帮我们确定唯一的一台机器，那么我们怎么找到一台机器上的一个软件呢？
端口 我们知道，一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址&#43;端口号”来区分不同的服务的。
TCP协议 当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。
这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。
TCP 三次握手和四次挥手 TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN&#43;ACK[1]，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接。[1]" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jinkes-li.github.io/python/%E7%AC%AC%E4%B8%83%E5%91%A8%E6%80%BB%E7%BB%93/" /><meta property="article:section" content="python" />
<meta property="article:published_time" content="2022-11-20T21:28:31+08:00" />
<meta property="article:modified_time" content="2022-11-20T21:28:31+08:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="第七周总结"/>
<meta name="twitter:description" content="网络编程 网络名词 单机： 单台计算机无法与其他计算机通讯 联机：一般指两台计算机可以进行相互通讯 局域网： 一个独立的网络环境内使用统一网段和子网掩码的计算机使用交换机相互通信 广域网： 涉及现代社会中的一个区或更大范围的地址，每个独立的局域网使用上层交换机和路由器进行信息交互 省网： 以省级单位为区域的计算机信息交互 国网： 同省级相同理念 以上数据交互可统称为以太网或者互联网
广播 主机之间“一对所有”的通讯模式，网络对其中每一台主机发出的信号都进行无条件复制并转发，所有主机都可以接收到所有信息（不管你是否需要），由于其不用路径选择，所以其网络成本可以很低廉。有线电视网就是典型的广播型网络，我们的电视机实际上是接受到所有频道的信号，但只将一个频道的信号还原成画面。在数据网络中也允许广播的存在，但其被限制在二层交换机的局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机
ip地址与ip协议 规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4 它规定网络地址由32位2进制表示 范围0.0.0.0-255.255.255.255 一个ip地址通常写成四段十进制数，例：172.16.10.1
mac地址
head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址。 mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）
arp协议 ——查询IP地址和MAC地址的对应关系 地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。 主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址。 收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。 地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。
路由器 路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。 路由器是互联网络的枢纽，&ldquo;交通警察&rdquo;。目前路由器已经广泛应用于各行各业，各种不同档次的产品已成为实现各种骨干网内部连接、骨干网间互联和骨干网与互联网互联互通业务的主力军。路由和交换机之间的主要区别就是交换机发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换机在移动信息的过程中需使用不同的控制信息，所以说两者实现各自功能的方式是不同的。
局域网 局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。　子网掩码　所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。
比如，已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算， 172.16.10.1：10101100.00010000.00001010.000000001 255255.255.255.0:11111111.11111111.11111111.00000000 AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0 172.16.10.2：10101100.00010000.00001010.00000010 255255.255.255.0:11111111.11111111.11111111.00000000 AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0 结果都是172.16.10.0，因此它们在同一个子网络。 总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。
tcp协议和udp协议 用于应用程序之间的通信。如果说ip地址和mac地址帮我们确定唯一的一台机器，那么我们怎么找到一台机器上的一个软件呢？
端口 我们知道，一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址&#43;端口号”来区分不同的服务的。
TCP协议 当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。
这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。
TCP 三次握手和四次挥手 TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN&#43;ACK[1]，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接。[1]"/>

  
  
    
  
  
  <link rel="stylesheet" href="https://jinkes-li.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css" integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="> 

  
  
  
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
<link rel="icon" type="image/png" href="https://jinkes-li.github.io/images/favicon.ico" />

  
  
</head>

<body class="max-width mx-auto px3 ltr">
  <div class="content index py4">

    <header id="header">
  <a href="https://jinkes-li.github.io/">
  
    <div id="logo" style="background-image: url(https://jinkes-li.github.io/images/logo.png)"></div>
  
  <div id="title">
    <h1>self-salvation</h1>
  </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="Menu"><i class="fas fa-bars fa-2x" aria-hidden="true"></i></a>
      </li>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/posts/">All posts</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
        <li><a href="/python">Python</a></li>
      
        <li><a href="/databases">databases</a></li>
      
        <li><a href="/about">About</a></li>
      
    </ul>
  </div>
</header>



    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="content" itemprop="articleBody">
  
    <h3 id="网络编程">网络编程</h3>
<ul>
<li>网络名词
单机： 单台计算机无法与其他计算机通讯
联机：一般指两台计算机可以进行相互通讯
局域网： 一个独立的网络环境内使用统一网段和子网掩码的计算机使用交换机相互通信
广域网： 涉及现代社会中的一个区或更大范围的地址，每个独立的局域网使用上层交换机和路由器进行信息交互
省网： 以省级单位为区域的计算机信息交互
国网： 同省级相同理念</li>
</ul>
<p>以上数据交互可统称为以太网或者互联网</p>
<ul>
<li>
<p>广播
主机之间“一对所有”的通讯模式，网络对其中每一台主机发出的信号都进行无条件复制并转发，所有主机都可以接收到所有信息（不管你是否需要），由于其不用路径选择，所以其网络成本可以很低廉。有线电视网就是典型的广播型网络，我们的电视机实际上是接受到所有频道的信号，但只将一个频道的信号还原成画面。在数据网络中也允许广播的存在，但其被限制在二层交换机的局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机</p>
</li>
<li>
<p>ip地址与ip协议
规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4
它规定网络地址由32位2进制表示
范围0.0.0.0-255.255.255.255
一个ip地址通常写成四段十进制数，例：172.16.10.1</p>
</li>
<li>
<p>mac地址</p>
</li>
</ul>
<p>head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址。
　　mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）</p>
<ul>
<li>
<p>arp协议 ——查询IP地址和MAC地址的对应关系
地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。
　　主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址。
　　收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。
　　地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。</p>
</li>
<li>
<p>路由器
路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。 路由器是互联网络的枢纽，&ldquo;交通警察&rdquo;。目前路由器已经广泛应用于各行各业，各种不同档次的产品已成为实现各种骨干网内部连接、骨干网间互联和骨干网与互联网互联互通业务的主力军。路由和交换机之间的主要区别就是交换机发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换机在移动信息的过程中需使用不同的控制信息，所以说两者实现各自功能的方式是不同的。</p>
</li>
<li>
<p>局域网
　　局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。　　</p>
</li>
<li>
<p>子网掩码　
　　所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。
　　　　　　　　　　　　知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>比如<span style="color:#960050;background-color:#1e0010">，</span>已知IP地址172<span style="color:#ae81ff">.16.10.1</span>和172<span style="color:#ae81ff">.16.10.2</span>的子网掩码都是255<span style="color:#ae81ff">.255.255.0</span><span style="color:#960050;background-color:#1e0010">，</span>请问它们是否在同一个子网络<span style="color:#960050;background-color:#1e0010">？</span>两者与子网掩码分别进行AND运算<span style="color:#960050;background-color:#1e0010">，</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">172.16.10.1</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#ae81ff">10101100.00010000.00001010.000000001</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">255255.255.255.0</span>:<span style="color:#ae81ff">11111111.11111111.11111111.00000000</span>
</span></span><span style="display:flex;"><span>AND运算得网络地址结果<span style="color:#960050;background-color:#1e0010">：</span><span style="color:#ae81ff">10101100.00010000.00001010.000000001</span><span style="color:#f92672">-&gt;</span><span style="color:#ae81ff">172.16.10.0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">172.16.10.2</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#ae81ff">10101100.00010000.00001010.00000010</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">255255.255.255.0</span>:<span style="color:#ae81ff">11111111.11111111.11111111.00000000</span>
</span></span><span style="display:flex;"><span>AND运算得网络地址结果<span style="color:#960050;background-color:#1e0010">：</span><span style="color:#ae81ff">10101100.00010000.00001010.000000001</span><span style="color:#f92672">-&gt;</span><span style="color:#ae81ff">172.16.10.0</span>
</span></span><span style="display:flex;"><span>结果都是172<span style="color:#ae81ff">.16.10.0</span><span style="color:#960050;background-color:#1e0010">，</span>因此它们在同一个子网络<span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p>
<p>tcp协议和udp协议
用于应用程序之间的通信。如果说ip地址和mac地址帮我们确定唯一的一台机器，那么我们怎么找到一台机器上的一个软件呢？</p>
<p>端口
　　我们知道，一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。</p>
<p>TCP协议
　　当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。</p>
<p>　　这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。</p>
<p><img src="https://images2017.cnblogs.com/blog/827651/201801/827651-20180124205000006-1596874324.png" alt=""></p>
<ul>
<li>TCP 三次握手和四次挥手</li>
</ul>
<blockquote>
<p>TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK[1]，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接。[1]</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>TCP三次握手的过程如下<span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>客户端发送SYN<span style="color:#960050;background-color:#1e0010">（</span>SEQ<span style="color:#f92672">=</span>x<span style="color:#960050;background-color:#1e0010">）</span>报文给服务器端<span style="color:#960050;background-color:#1e0010">，</span>进入SYN_SEND状态<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>服务器端收到SYN报文<span style="color:#960050;background-color:#1e0010">，</span>回应一个SYN <span style="color:#960050;background-color:#1e0010">（</span>SEQ<span style="color:#f92672">=</span>y<span style="color:#960050;background-color:#1e0010">）</span>ACK(ACK<span style="color:#f92672">=</span>x<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">）</span>报文<span style="color:#960050;background-color:#1e0010">，</span>进入SYN_RECV状态<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>客户端收到服务器端的SYN报文<span style="color:#960050;background-color:#1e0010">，</span>回应一个ACK(ACK<span style="color:#f92672">=</span>y<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">）</span>报文<span style="color:#960050;background-color:#1e0010">，</span>进入Established状态<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>三次握手完成<span style="color:#960050;background-color:#1e0010">，</span>TCP客户端和服务器端成功地建立连接<span style="color:#960050;background-color:#1e0010">，</span>可以开始传输数据了<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tcp的四次挥手
</span></span><span style="display:flex;"><span>建立一个连接需要三次握手<span style="color:#960050;background-color:#1e0010">，</span>而终止一个连接要经过四次握手<span style="color:#960050;background-color:#1e0010">，</span>这是由TCP的半关闭<span style="color:#960050;background-color:#1e0010">（</span>half<span style="color:#f92672">-</span>close<span style="color:#960050;background-color:#1e0010">）</span>造成的<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span>) 某个应用进程首先调用close<span style="color:#960050;background-color:#1e0010">，</span>称该端执行<span style="color:#960050;background-color:#1e0010">“</span>主动关闭<span style="color:#960050;background-color:#1e0010">”（</span>active close<span style="color:#960050;background-color:#1e0010">）。</span>该端的TCP于是发送一个FIN分节<span style="color:#960050;background-color:#1e0010">，</span>表示数据发送完毕<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">2</span>) 接收到这个FIN的对端执行 <span style="color:#960050;background-color:#1e0010">“</span>被动关闭<span style="color:#960050;background-color:#1e0010">”（</span>passive close<span style="color:#960050;background-color:#1e0010">），</span>这个FIN由TCP确认<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>注意<span style="color:#960050;background-color:#1e0010">：</span>FIN的接收也作为一个文件结束符<span style="color:#960050;background-color:#1e0010">（</span>end<span style="color:#f92672">-</span>of<span style="color:#f92672">-</span>file<span style="color:#960050;background-color:#1e0010">）</span>传递给接收端应用进程<span style="color:#960050;background-color:#1e0010">，</span>放在已排队等候该应用进程接收的任何其他数据之后<span style="color:#960050;background-color:#1e0010">，</span>因为<span style="color:#960050;background-color:#1e0010">，</span>FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">3</span>) 一段时间后<span style="color:#960050;background-color:#1e0010">，</span>接收到这个文件结束符的应用进程将调用close关闭它的套接字<span style="color:#960050;background-color:#1e0010">。</span>这导致它的TCP也发送一个FIN<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">4</span>) 接收这个最终FIN的原发送端TCP<span style="color:#960050;background-color:#1e0010">（</span>即执行主动关闭的那一端<span style="color:#960050;background-color:#1e0010">）</span>确认这个FIN<span style="color:#960050;background-color:#1e0010">。</span>[<span style="color:#ae81ff">1</span>] 
</span></span><span style="display:flex;"><span>既然每个方向都需要一个FIN和一个ACK<span style="color:#960050;background-color:#1e0010">，</span>因此通常需要4个分节<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>注意<span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span>) <span style="color:#960050;background-color:#1e0010">“</span>通常<span style="color:#960050;background-color:#1e0010">”</span>是指<span style="color:#960050;background-color:#1e0010">，</span>某些情况下<span style="color:#960050;background-color:#1e0010">，</span>步骤1的FIN随数据一起发送<span style="color:#960050;background-color:#1e0010">，</span>另外<span style="color:#960050;background-color:#1e0010">，</span>步骤2和步骤3发送的分节都出自执行被动关闭那一端<span style="color:#960050;background-color:#1e0010">，</span>有可能被合并成一个分节<span style="color:#960050;background-color:#1e0010">。</span>[<span style="color:#ae81ff">2</span>] 
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">2</span>) 在步骤2与步骤3之间<span style="color:#960050;background-color:#1e0010">，</span>从执行被动关闭一端到执行主动关闭一端流动数据是可能的<span style="color:#960050;background-color:#1e0010">，</span>这称为<span style="color:#960050;background-color:#1e0010">“</span>半关闭<span style="color:#960050;background-color:#1e0010">”（</span>half<span style="color:#f92672">-</span>close<span style="color:#960050;background-color:#1e0010">）。</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">3</span>) 当一个Unix进程无论自愿地<span style="color:#960050;background-color:#1e0010">（</span>调用exit或从main函数返回<span style="color:#960050;background-color:#1e0010">）</span>还是非自愿地<span style="color:#960050;background-color:#1e0010">（</span>收到一个终止本进程的信号<span style="color:#960050;background-color:#1e0010">）</span>终止时<span style="color:#960050;background-color:#1e0010">，</span>所有打开的描述符都被关闭<span style="color:#960050;background-color:#1e0010">，</span>这也导致仍然打开的任何TCP连接上也发出一个FIN<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>无论是客户还是服务器<span style="color:#960050;background-color:#1e0010">，</span>任何一端都可以执行主动关闭<span style="color:#960050;background-color:#1e0010">。</span>通常情况是<span style="color:#960050;background-color:#1e0010">，</span>客户执行主动关闭<span style="color:#960050;background-color:#1e0010">，</span>但是某些协议<span style="color:#960050;background-color:#1e0010">，</span>例如<span style="color:#960050;background-color:#1e0010">，</span>HTTP<span style="color:#f92672">/</span><span style="color:#ae81ff">1.0</span>却由服务器执行主动关闭<span style="color:#960050;background-color:#1e0010">。</span>[<span style="color:#ae81ff">2</span>] 
</span></span></code></pre></div><ul>
<li>UDP协议
　　当应用程序希望通过UDP与一个应用程序通信时，传输数据之前源端和终端不建立连接。
　　　　　　　　　　　　当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。</li>
</ul>
<p>tcp和udp的对比
TCP&mdash;传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。
UDP&mdash;用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>现在Internet上流行的协议是TCP<span style="color:#f92672">/</span>IP协议<span style="color:#960050;background-color:#1e0010">，</span>该协议中对低于1024的端口都有确切的定义<span style="color:#960050;background-color:#1e0010">，</span>他们对应着Internet上一些常见的服务<span style="color:#960050;background-color:#1e0010">。</span>这些常见的服务可以分为使用TCP端口<span style="color:#960050;background-color:#1e0010">（</span>面向连接<span style="color:#960050;background-color:#1e0010">）</span>和使用UDP端口<span style="color:#960050;background-color:#1e0010">（</span>面向无连接<span style="color:#960050;background-color:#1e0010">）</span>两种<span style="color:#960050;background-color:#1e0010">。</span> 
</span></span><span style="display:flex;"><span>说到TCP和UDP,首先要明白<span style="color:#960050;background-color:#1e0010">“</span>连接<span style="color:#960050;background-color:#1e0010">”</span>和<span style="color:#960050;background-color:#1e0010">“</span>无连接<span style="color:#960050;background-color:#1e0010">”</span>的含义<span style="color:#960050;background-color:#1e0010">，</span>他们的关系可以用一个形象地比喻来说明<span style="color:#960050;background-color:#1e0010">，</span>就是打电话和写信<span style="color:#960050;background-color:#1e0010">。</span>两个人如果要通话<span style="color:#960050;background-color:#1e0010">，</span>首先要建立连接<span style="color:#960050;background-color:#1e0010">——</span>即打电话时的拨号<span style="color:#960050;background-color:#1e0010">，</span>等待响应后<span style="color:#960050;background-color:#1e0010">——</span>即接听电话后<span style="color:#960050;background-color:#1e0010">，</span>才能相互传递信息<span style="color:#960050;background-color:#1e0010">，</span>最后还要断开连接<span style="color:#960050;background-color:#1e0010">——</span>即挂电话<span style="color:#960050;background-color:#1e0010">。</span>写信就比较简单了<span style="color:#960050;background-color:#1e0010">，</span>填写好收信人的地址后将信投入邮筒<span style="color:#960050;background-color:#1e0010">，</span>收信人就可以收到了<span style="color:#960050;background-color:#1e0010">。</span>从这个分析可以看出<span style="color:#960050;background-color:#1e0010">，</span>建立连接可以在需要痛心地双方建立一个传递信息的通道<span style="color:#960050;background-color:#1e0010">，</span>在发送方发送请求连接信息接收方响应后<span style="color:#960050;background-color:#1e0010">，</span>由于是在接受方响应后才开始传递信息<span style="color:#960050;background-color:#1e0010">，</span>而且是在一个通道中传送<span style="color:#960050;background-color:#1e0010">，</span>因此接受方能比较完整地收到发送方发出的信息<span style="color:#960050;background-color:#1e0010">，</span>即信息传递的可靠性比较高<span style="color:#960050;background-color:#1e0010">。</span>但也正因为需要建立连接<span style="color:#960050;background-color:#1e0010">，</span>使资源开销加大<span style="color:#960050;background-color:#1e0010">（</span>在建立连接前必须等待接受方响应<span style="color:#960050;background-color:#1e0010">，</span>传输信息过程中必须确认信息是否传到及断开连接时发出相应的信号等<span style="color:#960050;background-color:#1e0010">），</span>独占一个通道<span style="color:#960050;background-color:#1e0010">，</span>在断开连接钱不能建立另一个连接<span style="color:#960050;background-color:#1e0010">，</span>即两人在通话过程中第三方不能打入电话<span style="color:#960050;background-color:#1e0010">。</span>而无连接是一开始就发送信息<span style="color:#960050;background-color:#1e0010">（</span>严格说来<span style="color:#960050;background-color:#1e0010">，</span>这是没有开始<span style="color:#960050;background-color:#1e0010">、</span>结束的<span style="color:#960050;background-color:#1e0010">），</span>只是一次性的传递<span style="color:#960050;background-color:#1e0010">，</span>是先不需要接受方的响应<span style="color:#960050;background-color:#1e0010">，</span>因而在一定程度上也无法保证信息传递的可靠性了<span style="color:#960050;background-color:#1e0010">，</span>就像写信一样<span style="color:#960050;background-color:#1e0010">，</span>我们只是将信寄出去<span style="color:#960050;background-color:#1e0010">，</span>却不能保证收信人一定可以收到<span style="color:#960050;background-color:#1e0010">。</span> 
</span></span><span style="display:flex;"><span>TCP是面向连接的<span style="color:#960050;background-color:#1e0010">，</span>有比较高的可靠性<span style="color:#960050;background-color:#1e0010">，</span> 一些要求比较高的服务一般使用这个协议<span style="color:#960050;background-color:#1e0010">，</span>如FTP<span style="color:#960050;background-color:#1e0010">、</span>Telnet<span style="color:#960050;background-color:#1e0010">、</span>SMTP<span style="color:#960050;background-color:#1e0010">、</span>HTTP<span style="color:#960050;background-color:#1e0010">、</span>POP3等<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>而UDP是面向无连接的<span style="color:#960050;background-color:#1e0010">，</span>使用这个协议的常见服务有DNS<span style="color:#960050;background-color:#1e0010">、</span>SNMP<span style="color:#960050;background-color:#1e0010">、</span>QQ等<span style="color:#960050;background-color:#1e0010">。</span>对于QQ必须另外说明一下<span style="color:#960050;background-color:#1e0010">，</span>QQ2003以前是只使用UDP协议的<span style="color:#960050;background-color:#1e0010">，</span>其服务器使用8000端口<span style="color:#960050;background-color:#1e0010">，</span>侦听是否有信息传来<span style="color:#960050;background-color:#1e0010">，</span>客户端使用4000端口<span style="color:#960050;background-color:#1e0010">，</span>向外发送信息<span style="color:#960050;background-color:#1e0010">（</span>这也就不难理解在一般的显IP的QQ版本中显示好友的IP地址信息中端口常为4000或其后续端口的原因了<span style="color:#960050;background-color:#1e0010">），</span>即QQ程序既接受服务又提供服务<span style="color:#960050;background-color:#1e0010">，</span>在以后的QQ版本中也支持使用TCP协议了<span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><ul>
<li>
<p>OSI 模型</p>
</li>
<li>
<p>应用层（区分不同应用使用不同协议，转换通用协议）</p>
</li>
<li>
<p>表示层（处理数据的格式变化，加密与解密等）</p>
</li>
<li>
<p>会话层（建立连接，数据传输处理，连接释放）</p>
</li>
<li>
<p>传输层（数据交互各层协议TCP UDP）</p>
</li>
<li>
<p>网络层（添加ip报文头部，设备：三层路由交换）</p>
</li>
<li>
<p>数据链路层 （ARP 添加报文，设备：交换机，网卡）</p>
</li>
<li>
<p>物理层 （电信号传输，一般硬件设备为：中继器，集线器，双绞线）</p>
</li>
<li>
<p>C/S架构与B/S架构</p>
</li>
<li>
<p>套接字（socket）初使用</p>
</li>
<li>
<p>验证客户端链接的合法性</p>
</li>
<li>
<p>socketserver模块</p>
</li>
<li>
<p>CS架构
cs架构指的是客户端以及服务端架构
这里的客户端相当于是我们手机上使用的APP
服务端指的是在服务器上运行用来接收客户端请求的程序</p>
</li>
<li>
<p>BS架构
BS架构其实也是同样的一种的客户端服务端架构
只是这里的客户端架构被更改为浏览器</p>
</li>
<li>
<p>套接字(socket)的使用</p>
</li>
</ul>
<p><img src="https://images2017.cnblogs.com/blog/827651/201801/827651-20180107205809034-380661986.png" alt=""></p>
<p>理解socket
Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>其实站在你的角度上看<span style="color:#960050;background-color:#1e0010">，</span>socket就是一个模块<span style="color:#960050;background-color:#1e0010">。</span>我们通过调用模块中已经实现的方法建立两个进程之间的连接和通信<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>也有人将socket说成ip<span style="color:#f92672">+</span>port<span style="color:#960050;background-color:#1e0010">，</span>因为ip是用来标识互联网中的一台主机的位置<span style="color:#960050;background-color:#1e0010">，</span>而port是用来标识这台机器上的一个应用程序<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>所以我们只要确立了ip和port就能找到一个应用程序<span style="color:#960050;background-color:#1e0010">，</span>并且使用socket模块来与之通信<span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><p>基于文件类型的套接字家族
套接字家族的名字：AF_UNIX</p>
<p>unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信</p>
<p>基于网络类型的套接字家族
套接字家族的名字：AF_INET</p>
<p>(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)</p>
<p>tcp协议和udp协议
TCP（Transmission Control Protocol）可靠的、面向连接的协议（eg:打电话）、传输效率低全双工通信（发送缓存&amp;接收缓存）、面向字节流。使用TCP的应用：Web浏览器；电子邮件、文件传输程序。</p>
<p>UDP（User Datagram Protocol）不可靠的、无连接的服务，传输效率高（发送前时延小），一对一、一对多、多对一、多对多、面向报文，尽最大努力服务，无拥塞控制。使用UDP的应用：域名系统 (DNS)；视频流；IP语音(VoIP)。</p>
<p><img src="https://images2017.cnblogs.com/blog/827651/201710/827651-20171027102242789-2142796570.jpg" alt=""></p>
<ul>
<li>socket 使用
基于TCP协议的socket
tcp是基于连接的，必须先启动服务端 然后再启动客户端</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>Server端
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> socket
</span></span><span style="display:flex;"><span>sk <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>socket
</span></span><span style="display:flex;"><span>sk<span style="color:#f92672">.</span>bind((<span style="color:#e6db74">&#39;127.0.0.1&#39;</span>, <span style="color:#ae81ff">8080</span>))  <span style="color:#75715e"># 本地向外服务的地址 也就是本地IP</span>
</span></span><span style="display:flex;"><span>sk<span style="color:#f92672">.</span>listen() <span style="color:#75715e"># 监听客户端数量</span>
</span></span><span style="display:flex;"><span>sock, addr <span style="color:#f92672">=</span> sk<span style="color:#f92672">.</span>accept() <span style="color:#75715e"># 接受客户端连接，返回端口和IP</span>
</span></span><span style="display:flex;"><span>ret <span style="color:#f92672">=</span> conn<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)  <span style="color:#75715e"># 接收客户端传入的信息1024是接收的字节量</span>
</span></span><span style="display:flex;"><span>conn<span style="color:#f92672">.</span>send(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hi&#39;</span>)  <span style="color:#75715e"># 向客户端发送信息，必须是二进制</span>
</span></span><span style="display:flex;"><span>conn<span style="color:#f92672">.</span>close()  <span style="color:#75715e"># 关闭客户端套接字</span>
</span></span><span style="display:flex;"><span>sk<span style="color:#f92672">.</span>close()  <span style="color:#75715e"># 关闭服务器套接字</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Client端
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> oscket()
</span></span><span style="display:flex;"><span>sk <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>socket()  <span style="color:#75715e"># 创建客户端套接字</span>
</span></span><span style="display:flex;"><span>sk<span style="color:#f92672">.</span>send(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hello!&#39;</span>)
</span></span><span style="display:flex;"><span>ret <span style="color:#f92672">=</span> sk<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">1024</span>)  <span style="color:#75715e"># 对话（发送/接收）</span>
</span></span><span style="display:flex;"><span>sk<span style="color:#f92672">.</span>close()  <span style="color:#75715e"># 关闭客户端套接字</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">需要注意的是在mac系统使用中需要加上socket配置
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">from socket import SOL_SOCKET, SO_PERUSEADDR
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">如果不添加，可能会发生端口不可用
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span></code></pre></div><ul>
<li>基于UDP协议的socket
udp是无连接的，启动服务之后可以直接接收消息，不需要提前建立连接</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>Server端
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> socket
</span></span><span style="display:flex;"><span>udp_sk <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span>socket(type<span style="color:#f92672">=</span>socket<span style="color:#f92672">.</span>SOCK_DGRAM<span style="color:#e6db74">&#39;)  # 创造一个服务器的套接字</span>
</span></span><span style="display:flex;"><span>udp_sk<span style="color:#f92672">.</span>bind((<span style="color:#e6db74">&#39;127.0.0.1&#39;</span>, <span style="color:#ae81ff">8080</span>))  <span style="color:#75715e"># 绑定服务器的套接字</span>
</span></span><span style="display:flex;"><span>msg, addr <span style="color:#f92672">=</span> udp_sk<span style="color:#f92672">.</span>recvfrom(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>udp_sk<span style="color:#f92672">.</span>sendto(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hi&#39;</span>,addr)  <span style="color:#75715e"># 对话</span>
</span></span><span style="display:flex;"><span>udp_sk<span style="color:#f92672">.</span>close()  <span style="color:#75715e"># 关闭服务器套接字</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Client端
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> socket
</span></span><span style="display:flex;"><span>ip_port<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;127.0.0.1&#39;</span>, <span style="color:#ae81ff">8080</span>)
</span></span><span style="display:flex;"><span>udp_sk<span style="color:#f92672">=</span>socket<span style="color:#f92672">.</span>socket(type<span style="color:#f92672">=</span>socket<span style="color:#f92672">.</span>SOCK_DGRAM)
</span></span><span style="display:flex;"><span>udp_sk<span style="color:#f92672">.</span>sento(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;hello&#39;</span>, ip_port)
</span></span><span style="display:flex;"><span>back_msg, addr<span style="color:#f92672">=</span>udp_sk<span style="color:#f92672">.</span>recvfrom(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>print(back_msg<span style="color:#f92672">.</span>decode(<span style="color:#e6db74">&#39;utf-8&#39;</span>), addr)
</span></span></code></pre></div><ul>
<li>socket参数详解</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>socket<span style="color:#f92672">.</span>socket(family<span style="color:#f92672">=</span>AF_INET,type<span style="color:#f92672">=</span>SOCK_STREAM,proto<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,fileno<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>)
</span></span></code></pre></div><p>创建Socket对象的参数说明：</p>
<table>
<thead>
<tr>
<th>family</th>
<th>地址系列应为AF_INET(默认值)，AF_INET6,AF_UNIX,AF_CAN或AF_RDS（AF_UNIX 域实际上是使用本地 socket 文件来通信）</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>套接字类型应为SOCK_STREAM(默认值),SOCK_DGRAM,SOCK_RAW或其他SOCK_常量之一。<strong>SOCK_STREAM</strong> 是基于TCP的，有保障的（即能保证数据正确传送到对方）面向连接的SOCKET，多用于资料传送。<strong>SOCK_DGRAM</strong> 是基于UDP的，无保障的面向消息的socket，多用于在网络上发广播信息。</td>
</tr>
<tr>
<td>proto</td>
<td>协议号通常为零,可以省略,或者在地址族为AF_CAN的情况下,协议应为CAN_RAW或CAN_BCM之一。</td>
</tr>
<tr>
<td>fileno</td>
<td>如果指定了fileno,则其他参数将被忽略,导致带有指定文件描述符的套接字返回。与socket.fromfd()不同,fileno将返回相同的套接字,而不是重复的。这可能有助于使用socket.close()关闭一个独立的插座。</td>
</tr>
</tbody>
</table>
<ul>
<li>黏包</li>
</ul>
<blockquote>
<p>黏包问题的产生： 简单的原理就是，在数据进行通讯时，服务端不知道客户端发送过来的信息长度，导致tcp在接受消息时会将后面包的头部添加到前面包的尾部</p>
</blockquote>
<ul>
<li>
<p>黏包现象只发生在tcp协议中：
1.从表面上看，黏包问题主要是因为发送方和接收方的缓存机制、tcp协议面向流通信的特点。
2.实际上，主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的</p>
</li>
<li>
<p>解决黏包</p>
</li>
</ul>
<blockquote>
<p>问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据。</p>
<ol>
<li>确定第一条消息的长度</li>
<li>将真实数据的元数据使用json的方式压缩并传输,使用struct模块</li>
<li>当服务端获取到真实数据的相关信息后传输真实数据</li>
</ol>
</blockquote>
<ul>
<li>并发编程</li>
</ul>
<p>单道技术
所有的程序排队执行 过程中不能重合
多道技术
利用空闲时间提前准备其他数据 最大化提升CPU利用率</p>
<p>多道技术详细</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ae81ff">1.</span>切换
</span></span><span style="display:flex;"><span>  计算机的CPU在两种情况下会切换(不让你用 给别人用)
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">1.</span>程序有IO操作
</span></span><span style="display:flex;"><span>     输入\输出操作
</span></span><span style="display:flex;"><span>     input<span style="color:#960050;background-color:#1e0010">、</span>time<span style="color:#f92672">.</span>sleep<span style="color:#960050;background-color:#1e0010">、</span>read<span style="color:#960050;background-color:#1e0010">、</span>write
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">2.</span>程序长时间占用CPU	
</span></span><span style="display:flex;"><span>     我们得雨露均沾 让多个程序都能被CPU运行一下 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2.</span>保存状态
</span></span><span style="display:flex;"><span>  CPU每次切换走之前都需要保存当前操作的状态 下次切换回来基于上次的进度继续执行
</span></span></code></pre></div><ul>
<li>
<p>分时系统
由于CPU速度不断提高和采用分时技术，一台计算机可同时连接多个用户终端，而每个用户可在自己的终端上联机使用计算机，好象自己独占机器一样。
分时技术：把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。
　　若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮时再继续其运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的印象是，好象他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。
具有上述特征的计算机系统称为分时系统，它允许多个用户同时联机使用计算机。
　　特点：
　　（1）多路性。若干个用户同时使用一台计算机。微观上看是各用户轮流使用计算机；宏观上看是各用户并行工作。
　　（2）交互性。用户可根据系统对请求的响应结果，进一步向系统提出新的请求。这种能使用户与系统进行人机对话的工作方式，明显地有别于批处理系统，因而，分时系统又被称为交互式系统。
　　（3）独立性。用户之间可以相互独立操作，互不干扰。系统保证各用户程序运行的完整性，不会发生相互混淆或破坏现象。
　　（4）及时性。系统可对用户的输入及时作出响应。分时系统性能的主要指标之一是响应时间，它是指：从终端发出命令到系统予以应答所需的时间。
　　分时系统的主要目标：对用户响应的及时性，即不至于用户等待每一个命令的处理时间过长。
分时系统可以同时接纳数十个甚至上百个用户，由于内存空间有限，往往采用对换（又称交换）方式的存储方法。即将未“轮到”的作业放入磁盘，一旦“轮到”，再将其调入内存；而时间片用完后，又将作业存回磁盘（俗称“滚进”、“滚出“法），使同一存储区域轮流为多个用户服务。
多用户分时系统是当今计算机操作系统中最普遍使用的一类操作系统。</p>
</li>
<li>
<p>注意：分时系统的分时间片工作，在没有遇到IO操作的时候就用完了自己的时间片被切走了，这样的切换工作其实并没有提高cpu的效率，反而使得计算机的效率降低了。但是我们牺牲了一点效率，却实现了多个程序共同执行的效果，这样你就可以在计算机上一边听音乐一边聊qq了。</p>
</li>
<li>
<p>进程</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>一 操作系统的作用<span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">：</span>隐藏丑陋复杂的硬件接口<span style="color:#960050;background-color:#1e0010">，</span>提供良好的抽象接口
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">：</span>管理<span style="color:#960050;background-color:#1e0010">、</span>调度进程<span style="color:#960050;background-color:#1e0010">，</span>并且将多个进程对硬件的竞争变得有序
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>二 多道技术<span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1.</span>产生背景<span style="color:#960050;background-color:#1e0010">：</span>针对单核<span style="color:#960050;background-color:#1e0010">，</span>实现并发
</span></span><span style="display:flex;"><span>    ps<span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>    现在的主机一般是多核<span style="color:#960050;background-color:#1e0010">，</span>那么每个核都会利用多道技术
</span></span><span style="display:flex;"><span>    有4个cpu<span style="color:#960050;background-color:#1e0010">，</span>运行于cpu1的某个程序遇到io阻塞<span style="color:#960050;background-color:#1e0010">，</span>会等到io结束再重新调度<span style="color:#960050;background-color:#1e0010">，</span>会被调度到4个
</span></span><span style="display:flex;"><span>    cpu中的任意一个<span style="color:#960050;background-color:#1e0010">，</span>具体由操作系统调度算法决定<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2.</span>空间上的复用<span style="color:#960050;background-color:#1e0010">：</span>如内存中同时有多道程序
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">3.</span>时间上的复用<span style="color:#960050;background-color:#1e0010">：</span>复用一个cpu的时间片
</span></span><span style="display:flex;"><span>       强调<span style="color:#960050;background-color:#1e0010">：</span>遇到io切<span style="color:#960050;background-color:#1e0010">，</span>占用cpu时间过长也切<span style="color:#960050;background-color:#1e0010">，</span>核心在于切之前将进程的状态保存下来<span style="color:#960050;background-color:#1e0010">，</span>这样才能保证下次切换回来时<span style="color:#960050;background-color:#1e0010">，</span>能基于上次切走的位置继续运行
</span></span></code></pre></div><ul>
<li>什么是进程
进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</li>
</ul>
<p>狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。
广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>第一<span style="color:#960050;background-color:#1e0010">，</span>进程是一个实体<span style="color:#960050;background-color:#1e0010">。</span>每一个进程都有它自己的地址空间<span style="color:#960050;background-color:#1e0010">，</span>一般情况下<span style="color:#960050;background-color:#1e0010">，</span>包括文本区域<span style="color:#960050;background-color:#1e0010">（</span>text region<span style="color:#960050;background-color:#1e0010">）、</span>数据区域<span style="color:#960050;background-color:#1e0010">（</span>data region<span style="color:#960050;background-color:#1e0010">）</span>和堆栈<span style="color:#960050;background-color:#1e0010">（</span>stack region<span style="color:#960050;background-color:#1e0010">）。</span>文本区域存储处理器执行的代码<span style="color:#960050;background-color:#1e0010">；</span>数据区域存储变量和进程执行期间使用的动态分配的内存<span style="color:#960050;background-color:#1e0010">；</span>堆栈区域存储着活动过程调用的指令和本地变量<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>第二<span style="color:#960050;background-color:#1e0010">，</span>进程是一个<span style="color:#960050;background-color:#1e0010">“</span>执行中的程序<span style="color:#960050;background-color:#1e0010">”。</span>程序是一个没有生命的实体<span style="color:#960050;background-color:#1e0010">，</span>只有处理器赋予程序生命时<span style="color:#960050;background-color:#1e0010">（</span>操作系统执行之<span style="color:#960050;background-color:#1e0010">），</span>它才能成为一个活动的实体<span style="color:#960050;background-color:#1e0010">，</span>我们称其为进程<span style="color:#960050;background-color:#1e0010">。</span>[<span style="color:#ae81ff">3</span>] 
</span></span><span style="display:flex;"><span>进程是操作系统中最基本<span style="color:#960050;background-color:#1e0010">、</span>重要的概念<span style="color:#960050;background-color:#1e0010">。</span>是多道程序系统出现后<span style="color:#960050;background-color:#1e0010">，</span>为了刻画系统内部出现的动态情况<span style="color:#960050;background-color:#1e0010">，</span>描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>从理论角度看<span style="color:#960050;background-color:#1e0010">，</span>是对正在运行的程序过程的抽象<span style="color:#960050;background-color:#1e0010">；</span>
</span></span><span style="display:flex;"><span>从实现角度看<span style="color:#960050;background-color:#1e0010">，</span>是一种数据结构<span style="color:#960050;background-color:#1e0010">，</span>目的在于清晰地刻画动态系统的内在规律<span style="color:#960050;background-color:#1e0010">，</span>有效管理和调度进入计算机系统主存储器运行的程序<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>动态性<span style="color:#960050;background-color:#1e0010">：</span>进程的实质是程序在多道程序系统中的一次执行过程<span style="color:#960050;background-color:#1e0010">，</span>进程是动态产生<span style="color:#960050;background-color:#1e0010">，</span>动态消亡的<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>并发性<span style="color:#960050;background-color:#1e0010">：</span>任何进程都可以同其他进程一起并发执行
</span></span><span style="display:flex;"><span>独立性<span style="color:#960050;background-color:#1e0010">：</span>进程是一个能独立运行的基本单位<span style="color:#960050;background-color:#1e0010">，</span>同时也是系统分配资源和调度的独立单位<span style="color:#960050;background-color:#1e0010">；</span>
</span></span><span style="display:flex;"><span>异步性<span style="color:#960050;background-color:#1e0010">：</span>由于进程间的相互制约<span style="color:#960050;background-color:#1e0010">，</span>使进程具有执行的间断性<span style="color:#960050;background-color:#1e0010">，</span>即进程按各自独立的<span style="color:#960050;background-color:#1e0010">、</span>不可预知的速度向前推进
</span></span><span style="display:flex;"><span>结构特征<span style="color:#960050;background-color:#1e0010">：</span>进程由程序<span style="color:#960050;background-color:#1e0010">、</span>数据和进程控制块三部分组成<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>多个不同的进程可以包含相同的程序<span style="color:#960050;background-color:#1e0010">：</span>一个程序在不同的数据集里就构成不同的进程<span style="color:#960050;background-color:#1e0010">，</span>能得到不同的结果<span style="color:#960050;background-color:#1e0010">；</span>但是执行过程中<span style="color:#960050;background-color:#1e0010">，</span>程序不能发生改变<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>程序是指令和数据的有序集合<span style="color:#960050;background-color:#1e0010">，</span>其本身没有任何运行的含义<span style="color:#960050;background-color:#1e0010">，</span>是一个静态的概念<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>而进程是程序在处理机上的一次执行过程<span style="color:#960050;background-color:#1e0010">，</span>它是一个动态的概念<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>程序可以作为一种软件资料长期存在<span style="color:#960050;background-color:#1e0010">，</span>而进程是有一定生命期的<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>程序是永久的<span style="color:#960050;background-color:#1e0010">，</span>进程是暂时的<span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><ul>
<li>进程调度</li>
</ul>
<blockquote>
<p>要想多个进程交替运行，操作系统必须对这些进程进行调度，这个调度也不是随即进行的，而是需要遵循一定的法则，由此就有了进程的调度算法。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>先来先服务<span style="color:#960050;background-color:#1e0010">（</span>FCFS<span style="color:#960050;background-color:#1e0010">）</span>:
</span></span><span style="display:flex;"><span>调度算法是一种最简单的调度算法<span style="color:#960050;background-color:#1e0010">，</span>该算法既可用于作业调度<span style="color:#960050;background-color:#1e0010">，</span>也可用于进程调度<span style="color:#960050;background-color:#1e0010">。</span>FCFS算法比较有利于长作业<span style="color:#960050;background-color:#1e0010">（</span>进程<span style="color:#960050;background-color:#1e0010">），</span>而不利于短作业<span style="color:#960050;background-color:#1e0010">（</span>进程<span style="color:#960050;background-color:#1e0010">）。</span>由此可知<span style="color:#960050;background-color:#1e0010">，</span>本算法适合于CPU繁忙型作业<span style="color:#960050;background-color:#1e0010">，</span>而不利于I<span style="color:#f92672">/</span>O繁忙型的作业<span style="color:#960050;background-color:#1e0010">（</span>进程<span style="color:#960050;background-color:#1e0010">）</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>短作业<span style="color:#960050;background-color:#1e0010">（</span>进程<span style="color:#960050;background-color:#1e0010">）</span>:
</span></span><span style="display:flex;"><span>优先调度算法<span style="color:#960050;background-color:#1e0010">（</span>SJ<span style="color:#f92672">/</span>PF<span style="color:#960050;background-color:#1e0010">）</span>是指对短作业或短进程优先调度的算法<span style="color:#960050;background-color:#1e0010">，</span>该算法既可用于作业调度<span style="color:#960050;background-color:#1e0010">，</span>也可用于进程调度<span style="color:#960050;background-color:#1e0010">。</span>但其对长作业不利<span style="color:#960050;background-color:#1e0010">；</span>不能保证紧迫性作业<span style="color:#960050;background-color:#1e0010">（</span>进程<span style="color:#960050;background-color:#1e0010">）</span>被及时处理<span style="color:#960050;background-color:#1e0010">；</span>作业的长短只是被估算出来的<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>时间片轮转(Round Robin<span style="color:#960050;background-color:#1e0010">，</span>RR)法:
</span></span><span style="display:flex;"><span>基本思路是让每个进程在就绪队列中的等待时间与享受服务的时间成比例<span style="color:#960050;background-color:#1e0010">。</span>在时间片轮转法中<span style="color:#960050;background-color:#1e0010">，</span>需要将CPU的处理时间分成固定大小的时间片<span style="color:#960050;background-color:#1e0010">，</span>例如<span style="color:#960050;background-color:#1e0010">，</span>几十毫秒至几百毫秒<span style="color:#960050;background-color:#1e0010">。</span>如果一个进程在被调度选中之后用完了系统规定的时间片<span style="color:#960050;background-color:#1e0010">，</span>但又未完成要求的任务<span style="color:#960050;background-color:#1e0010">，</span>则它自行释放自己所占有的CPU而排到就绪队列的末尾<span style="color:#960050;background-color:#1e0010">，</span>等待下一次调度<span style="color:#960050;background-color:#1e0010">。</span>同时<span style="color:#960050;background-color:#1e0010">，</span>进程调度程序又去调度当前就绪队列中的第一个进程<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>      显然<span style="color:#960050;background-color:#1e0010">，</span>轮转法只能用来调度分配一些可以抢占的资源<span style="color:#960050;background-color:#1e0010">。</span>这些可以抢占的资源可以随时被剥夺<span style="color:#960050;background-color:#1e0010">，</span>而且可以将它们再分配给别的进程<span style="color:#960050;background-color:#1e0010">。</span>CPU是可抢占资源的一种<span style="color:#960050;background-color:#1e0010">。</span>但打印机等资源是不可抢占的<span style="color:#960050;background-color:#1e0010">。</span>由于作业调度是对除了CPU之外的所有系统硬件资源的分配<span style="color:#960050;background-color:#1e0010">，</span>其中包含有不可抢占资源<span style="color:#960050;background-color:#1e0010">，</span>所以作业调度不使用轮转法<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>在轮转法中<span style="color:#960050;background-color:#1e0010">，</span>时间片长度的选取非常重要<span style="color:#960050;background-color:#1e0010">。</span>首先<span style="color:#960050;background-color:#1e0010">，</span>时间片长度的选择会直接影响到系统的开销和响应时间<span style="color:#960050;background-color:#1e0010">。</span>如果时间片长度过短<span style="color:#960050;background-color:#1e0010">，</span>则调度程序抢占处理机的次数增多<span style="color:#960050;background-color:#1e0010">。</span>这将使进程上下文切换次数也大大增加<span style="color:#960050;background-color:#1e0010">，</span>从而加重系统开销<span style="color:#960050;background-color:#1e0010">。</span>反过来<span style="color:#960050;background-color:#1e0010">，</span>如果时间片长度选择过长<span style="color:#960050;background-color:#1e0010">，</span>例如<span style="color:#960050;background-color:#1e0010">，</span>一个时间片能保证就绪队列中所需执行时间最长的进程能执行完毕<span style="color:#960050;background-color:#1e0010">，</span>则轮转法变成了先来先服务法<span style="color:#960050;background-color:#1e0010">。</span>时间片长度的选择是根据系统对响应时间的要求和就绪队列中所允许最大的进程数来确定的<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>      在轮转法中<span style="color:#960050;background-color:#1e0010">，</span>加入到就绪队列的进程有3种情况<span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>      一种是分给它的时间片用完<span style="color:#960050;background-color:#1e0010">，</span>但进程还未完成<span style="color:#960050;background-color:#1e0010">，</span>回到就绪队列的末尾等待下次调度去继续执行<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>      另一种情况是分给该进程的时间片并未用完<span style="color:#960050;background-color:#1e0010">，</span>只是因为请求I<span style="color:#f92672">/</span>O或由于进程的互斥与同步关系而被阻塞<span style="color:#960050;background-color:#1e0010">。</span>当阻塞解除之后再回到就绪队列<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>      第三种情况就是新创建进程进入就绪队列<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>      如果对这些进程区别对待<span style="color:#960050;background-color:#1e0010">，</span>给予不同的优先级和时间片从直观上看<span style="color:#960050;background-color:#1e0010">，</span>可以进一步改善系统服务质量和效率<span style="color:#960050;background-color:#1e0010">。</span>例如<span style="color:#960050;background-color:#1e0010">，</span>我们可把就绪队列按照进程到达就绪队列的类型和进程被阻塞时的阻塞原因分成不同的就绪队列<span style="color:#960050;background-color:#1e0010">，</span>每个队列按FCFS原则排列<span style="color:#960050;background-color:#1e0010">，</span>各队列之间的进程享有不同的优先级<span style="color:#960050;background-color:#1e0010">，</span>但同一队列内优先级相同<span style="color:#960050;background-color:#1e0010">。</span>这样<span style="color:#960050;background-color:#1e0010">，</span>当一个进程在执行完它的时间片之后<span style="color:#960050;background-color:#1e0010">，</span>或从睡眠中被唤醒以及被创建之后<span style="color:#960050;background-color:#1e0010">，</span>将进入不同的就绪队列<span style="color:#960050;background-color:#1e0010">。</span>  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>前面介绍的各种用作进程调度的算法都有一定的局限性<span style="color:#960050;background-color:#1e0010">。</span>如短进程优先的调度算法<span style="color:#960050;background-color:#1e0010">，</span>仅照顾了短进程而忽略了长进程<span style="color:#960050;background-color:#1e0010">，</span>而且如果并未指明进程的长度<span style="color:#960050;background-color:#1e0010">，</span>则短进程优先和基于进程长度的抢占式调度算法都将无法使用<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间<span style="color:#960050;background-color:#1e0010">，</span>而且还可以满足各种类型进程的需要<span style="color:#960050;background-color:#1e0010">，</span>因而它是目前被公认的一种较好的进程调度算法<span style="color:#960050;background-color:#1e0010">。</span>在采用多级反馈队列调度算法的系统中<span style="color:#960050;background-color:#1e0010">，</span>调度算法的实施过程如下所述<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span>) 应设置多个就绪队列<span style="color:#960050;background-color:#1e0010">，</span>并为各个队列赋予不同的优先级<span style="color:#960050;background-color:#1e0010">。</span>第一个队列的优先级最高<span style="color:#960050;background-color:#1e0010">，</span>第二个队列次之<span style="color:#960050;background-color:#1e0010">，</span>其余各队列的优先权逐个降低<span style="color:#960050;background-color:#1e0010">。</span>该算法赋予各个队列中进程执行时间片的大小也各不相同<span style="color:#960050;background-color:#1e0010">，</span>在优先权愈高的队列中<span style="color:#960050;background-color:#1e0010">，</span>为每个进程所规定的执行时间片就愈小<span style="color:#960050;background-color:#1e0010">。</span>例如<span style="color:#960050;background-color:#1e0010">，</span>第二个队列的时间片要比第一个队列的时间片长一倍<span style="color:#960050;background-color:#1e0010">，……，</span>第i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>个队列的时间片要比第i个队列的时间片长一倍<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">2</span>) 当一个新进程进入内存后<span style="color:#960050;background-color:#1e0010">，</span>首先将它放入第一队列的末尾<span style="color:#960050;background-color:#1e0010">，</span>按FCFS原则排队等待调度<span style="color:#960050;background-color:#1e0010">。</span>当轮到该进程执行时<span style="color:#960050;background-color:#1e0010">，</span>如它能在该时间片内完成<span style="color:#960050;background-color:#1e0010">，</span>便可准备撤离系统<span style="color:#960050;background-color:#1e0010">；</span>如果它在一个时间片结束时尚未完成<span style="color:#960050;background-color:#1e0010">，</span>调度程序便将该进程转入第二队列的末尾<span style="color:#960050;background-color:#1e0010">，</span>再同样地按FCFS原则等待调度执行<span style="color:#960050;background-color:#1e0010">；</span>如果它在第二队列中运行一个时间片后仍未完成<span style="color:#960050;background-color:#1e0010">，</span>再依次将它放入第三队列<span style="color:#960050;background-color:#1e0010">，……，</span>如此下去<span style="color:#960050;background-color:#1e0010">，</span>当一个长作业(进程)从第一队列依次降到第n队列后<span style="color:#960050;background-color:#1e0010">，</span>在第n 队列便采取按时间片轮转的方式运行<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">3</span>) 仅当第一队列空闲时<span style="color:#960050;background-color:#1e0010">，</span>调度程序才调度第二队列中的进程运行<span style="color:#960050;background-color:#1e0010">；</span>仅当第1<span style="color:#960050;background-color:#1e0010">～</span>(i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)队列均空时<span style="color:#960050;background-color:#1e0010">，</span>才会调度第i队列中的进程运行<span style="color:#960050;background-color:#1e0010">。</span>如果处理机正在第i队列中为某进程服务时<span style="color:#960050;background-color:#1e0010">，</span>又有新进程进入优先权较高的队列(第1<span style="color:#960050;background-color:#1e0010">～</span>(i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)中的任何一个队列)<span style="color:#960050;background-color:#1e0010">，</span>则此时新进程将抢占正在运行进程的处理机<span style="color:#960050;background-color:#1e0010">，</span>即由调度程序把正在运行的进程放回到第i队列的末尾<span style="color:#960050;background-color:#1e0010">，</span>把处理机分配给新到的高优先权进程<span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><ul>
<li>进程的并行与并发
并行 : 并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；（资源够用，比如三个线程，四核的CPU ）</li>
</ul>
<p>并发 : 并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率。</p>
<p>区别:</p>
<p>并行是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。
并发是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个session。</p>
<ul>
<li>同步异步阻塞非阻塞
在了解其他概念之前，我们首先要了解进程的几个状态。在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪，运行和阻塞。</li>
</ul>
<p>　　（1）就绪(Ready)状态</p>
<p>　　当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。</p>
<p>　　（2）执行/运行（Running）状态当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。</p>
<p>　　（3）阻塞(Blocked)状态正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。</p>
<p>同步和异步
所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</p>
<p>　　所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列</p>
<p>阻塞与非阻塞
阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的</p>
<ul>
<li>同步/异步与阻塞/非阻塞
同步阻塞形式
　　效率最低。拿上面的例子来说，就是你专心排队，什么别的事都不做。</li>
</ul>
<p>异步阻塞形式
　　如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发（通知），也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面；</p>
<p>　　异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</p>
<p>同步非阻塞形式
　　实际上是效率低下的。</p>
<p>　　想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。</p>
<p>异步非阻塞形式
　　效率更高，</p>
<p>　　因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。</p>
<p>　　比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。</p>
<p>　　</p>
<p>很多人会把同步和阻塞混淆，是因为很多时候同步操作会以阻塞的形式表现出来，同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞。</p>
<p>进程的创建与结束
进程的创建
　　但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为一个应用程序设计，比如微波炉中的控制器，一旦启动微波炉，所有的进程都已经存在。</p>
<p>　　而对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4中形式创建新的进程：</p>
<p>　　1. 系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）</p>
<p>　　2. 一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等）</p>
<p>　　3. 用户的交互式请求，而创建一个新进程（如用户双击暴风影音）</p>
<p>　　4. 一个批处理作业的初始化（只在大型机的批处理系统中应用）</p>
<p>　　无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。　　</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ae81ff">1.</span> 在UNIX中该系统调用是<span style="color:#960050;background-color:#1e0010">：</span>fork<span style="color:#960050;background-color:#1e0010">，</span>fork会创建一个与父进程一模一样的副本<span style="color:#960050;background-color:#1e0010">，</span>二者有相同的存储映像<span style="color:#960050;background-color:#1e0010">、</span>同样的环境字符串和同样的打开文件<span style="color:#960050;background-color:#1e0010">（</span>在shell解释器进程中<span style="color:#960050;background-color:#1e0010">，</span>执行一个命令就会创建一个子进程<span style="color:#960050;background-color:#1e0010">）</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>　　<span style="color:#ae81ff">2.</span> 在windows中该系统调用是<span style="color:#960050;background-color:#1e0010">：</span>CreateProcess<span style="color:#960050;background-color:#1e0010">，</span>CreateProcess既处理进程的创建<span style="color:#960050;background-color:#1e0010">，</span>也负责把正确的程序装入新进程<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>　　关于创建子进程<span style="color:#960050;background-color:#1e0010">，</span>UNIX和windows
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>　　<span style="color:#ae81ff">1.</span>相同的是<span style="color:#960050;background-color:#1e0010">：</span>进程创建后<span style="color:#960050;background-color:#1e0010">，</span>父进程和子进程有各自不同的地址空间<span style="color:#960050;background-color:#1e0010">（</span>多道技术要求物理层面实现进程之间内存的隔离<span style="color:#960050;background-color:#1e0010">），</span>任何一个进程的在其地址空间中的修改都不会影响到另外一个进程<span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>　　<span style="color:#ae81ff">2.</span>不同的是<span style="color:#960050;background-color:#1e0010">：</span>在UNIX中<span style="color:#960050;background-color:#1e0010">，</span>子进程的初始地址空间是父进程的一个副本<span style="color:#960050;background-color:#1e0010">，</span>提示<span style="color:#960050;background-color:#1e0010">：</span>子进程和父进程是可以有只读的共享内存区的<span style="color:#960050;background-color:#1e0010">。</span>但是对于windows系统来说<span style="color:#960050;background-color:#1e0010">，</span>从一开始父进程与子进程的地址空间就是不同的<span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><p>进程的结束
　　1. 正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）</p>
<p>　　2. 出错退出（自愿，python a.py中a.py不存在）</p>
<p>　　3. 严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try&hellip;except&hellip;）</p>
<p>　　4. 被其他进程杀死（非自愿，如kill -9）</p>
<ul>
<li>python程序中的进程操作
multiprocess模块
仔细说来，multiprocess不是一个模块而是python中一个操作、管理进程的包。 之所以叫multi是取自multiple的多功能的意思,在这个包中几乎包含了和进程有关的所有子模块。由于提供的子模块非常多，为了方便大家归类记忆，我将这部分大致分为四个部分：创建进程部分，进程同步部分，进程池部分，进程之间数据共享。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>Process([group [, target [, name [, args [, kwargs]]]]])<span style="color:#960050;background-color:#1e0010">，</span>由该类实例化得到的对象<span style="color:#960050;background-color:#1e0010">，</span>表示一个子进程中的任务<span style="color:#960050;background-color:#1e0010">（</span>尚未启动<span style="color:#960050;background-color:#1e0010">）</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>强调<span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1.</span> 需要使用关键字的方式来指定参数
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2.</span> args指定的为传给target函数的位置参数<span style="color:#960050;background-color:#1e0010">，</span>是一个元组形式<span style="color:#960050;background-color:#1e0010">，</span>必须有逗号
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>参数介绍<span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> group参数未使用<span style="color:#960050;background-color:#1e0010">，</span>值始终为None
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span> target表示调用对象<span style="color:#960050;background-color:#1e0010">，</span>即子进程要执行的任务
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span> args表示调用对象的位置参数元组<span style="color:#960050;background-color:#1e0010">，</span>args<span style="color:#f92672">=</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#39;jason&#39;</span>,)
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span> kwargs表示调用对象的字典,kwargs<span style="color:#f92672">=</span>{<span style="color:#e6db74">&#39;name&#39;</span>:<span style="color:#e6db74">&#39;jason&#39;</span>,<span style="color:#e6db74">&#39;age&#39;</span>:<span style="color:#ae81ff">18</span>}
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">5</span> name为子进程的名称
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 创建进程的方式</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 需要使用multiprocessing 这个包下的Process</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Process
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">task</span>():
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;task is running&#39;</span>, <span style="color:#e6db74">&#39;wesley&#39;</span>)
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;task is over&#39;</span>, <span style="color:#e6db74">&#39;wesley&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    p1 <span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>task)  <span style="color:#75715e"># 使用Process生成进程对象</span>
</span></span><span style="display:flex;"><span>    p1<span style="color:#f92672">.</span>start()  <span style="color:#75715e"># 启动子进程，</span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;主&#39;</span>) 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">这里需要注意，在启动子进程时上面的函数就会被启动，并且是异步的方式执行
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span></code></pre></div><p>创建进程传值方式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 创建进程并传值</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Process
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">task</span>(name):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;task is running&#39;</span>, name)
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;task is over&#39;</span>, name)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    p1 <span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>task, args<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;wesley&#39;</span>,))
</span></span><span style="display:flex;"><span>    p1<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;主&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">第一种传值方式使用使用 args来定义变量的值，在函数中使用变量进行调用
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span></code></pre></div><p>创建进程并使用键值的方式传值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 在创建进程时使用对Process的继承方法进行重写</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Process
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyProcess</span>(Process):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, name, age):
</span></span><span style="display:flex;"><span>        super()<span style="color:#f92672">.</span>__init__()
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> age
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(self):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;run is running&#39;</span>, self<span style="color:#f92672">.</span>name, self<span style="color:#f92672">.</span>age)
</span></span><span style="display:flex;"><span>        time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;run is over&#39;</span>, self<span style="color:#f92672">.</span>name, self<span style="color:#f92672">.</span>age)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    obj <span style="color:#f92672">=</span> MyProcess(<span style="color:#e6db74">&#39;wesley&#39;</span>, <span style="color:#ae81ff">123</span>)
</span></span><span style="display:flex;"><span>    obj<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;主&#39;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">需要注意的是这种方法本质上来说是对类中定义的值的一个重新复复赋值的一个操作
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span></code></pre></div><ul>
<li>进程的join方法</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 进程的join方法</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Process
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">task</span>(name, n):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> is running&#39;</span> <span style="color:#f92672">%</span> name)
</span></span><span style="display:flex;"><span>    time<span style="color:#f92672">.</span>sleep(n)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> is over&#39;</span> <span style="color:#f92672">%</span> name)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    p1 <span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>task, args<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;wesley1&#39;</span>, <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>    p2 <span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>task, args<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;wesley2&#39;</span>, <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>    p3 <span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>task, args<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;wesley3&#39;</span>, <span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;主进程代码等待子进程代码运行结束再执行&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    start_time <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time()
</span></span><span style="display:flex;"><span>    p1<span style="color:#f92672">.</span>start()  <span style="color:#75715e"># 异步</span>
</span></span><span style="display:flex;"><span>    p2<span style="color:#f92672">.</span>start()  <span style="color:#75715e"># 异步</span>
</span></span><span style="display:flex;"><span>    p3<span style="color:#f92672">.</span>start()  <span style="color:#75715e"># 异步</span>
</span></span><span style="display:flex;"><span>    p1<span style="color:#f92672">.</span>join()
</span></span><span style="display:flex;"><span>    p2<span style="color:#f92672">.</span>join()
</span></span><span style="display:flex;"><span>    p3<span style="color:#f92672">.</span>join()
</span></span><span style="display:flex;"><span>    print(time<span style="color:#f92672">.</span>time() <span style="color:#f92672">-</span> start_time)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3.057915687561035</span>  <span style="color:#75715e"># 最总运行时间是3s，这和我们预期的6s不符，为什么</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">1. join 这个指令是等待上一个指令完成后向后执行
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">2. 但是当我执行p1 p2 p3 .start() 时，程序是异步执行，并不会等待，这也就是说，也就是说，这3个代码是同时执行的，最终我耗时最长的为3秒，所以这里也就是3秒，这种就叫做并发
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span></code></pre></div><ul>
<li>IPC进程间通讯-队列</li>
</ul>
<blockquote>
<p>创建队列，Queue是多进程安全队列，可以实现多进程间的数据交互 Queue([maxsize]) 创建共享的进程队列。 参数 ：maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。 底层队列使用管道和锁定实现。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Queue
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用消息队列需要再multiprocessing中的Queue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>q <span style="color:#f92672">=</span> Queue(<span style="color:#ae81ff">3</span>)  <span style="color:#75715e"># 在括号内可以指定存放消息的数据量，如果不写 默认没有限制</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>q<span style="color:#f92672">.</span>put(<span style="color:#ae81ff">111</span>)  <span style="color:#75715e"># 向消息队列中存放数据</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>q<span style="color:#f92672">.</span>full()  <span style="color:#75715e"># 判断队列是否已满，返回bool值</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>q<span style="color:#f92672">.</span>empty()  <span style="color:#75715e"># 判断队列是否为空，返回bool值</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>q<span style="color:#f92672">.</span>get()  <span style="color:#75715e"># 从消息队列中取出数据</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>q<span style="color:#f92672">.</span>get_nowait() <span style="color:#75715e"># 同get()方法一样</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">full()  和  empty()  方法在多进程中不可以使用，可能出现极限存储数据情况，这时方法的返回将不再准确
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;关于mac使用Queue队列产生的默认启动fork方式不一致带来的问题
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">spawn: 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">使用此方式启动进程, 只会执行和target参数或者run()方法相关的代码. Windows平台只能使用此方法. 此方式启动进程的效率最低.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">fork: 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">使用此方式启动的进程, 基本等同于主进程(复刻主进程, 主进程拥有的资源, 子进程都有). 所以, 该方式创建的子进程会从创建位置起, 和主进程一样执行程序中的代码. 此启动方式适用于Unix和Linux.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">forserver: 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">使用此方式, 程序将会启动一个服务器进程. 即当程序每次请求启动新进程时, 父进程都会连接到该服务器进程, 请求有服务器进程来创建新进程. 通过这种方式启动的进程不需要从父进程继承资源. 此方式使用与Unix,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Queue, set_start_method, get_context
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">product</span>(q):
</span></span><span style="display:flex;"><span>    q<span style="color:#f92672">.</span>put(<span style="color:#e6db74">&#39;子进程p添加的数据&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">consumer</span>(q):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;子进程获取队列中的数据&#39;</span>, q<span style="color:#f92672">.</span>get())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># set_start_method(&#39;fork&#39;) # 有mac 使用fork带来的问题 解决方式一</span>
</span></span><span style="display:flex;"><span>    q <span style="color:#f92672">=</span> Queue()
</span></span><span style="display:flex;"><span>    ctx <span style="color:#f92672">=</span> get_context(<span style="color:#e6db74">&#39;fork&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 主进程往队列中添加数据</span>
</span></span><span style="display:flex;"><span>    q<span style="color:#f92672">.</span>put(<span style="color:#e6db74">&#39;我是主进程添加的数据&#39;</span>)
</span></span><span style="display:flex;"><span>    p1 <span style="color:#f92672">=</span> ctx<span style="color:#f92672">.</span>Process(target<span style="color:#f92672">=</span>consumer, args<span style="color:#f92672">=</span>(q,))
</span></span><span style="display:flex;"><span>    p2 <span style="color:#f92672">=</span> ctx<span style="color:#f92672">.</span>Process(target<span style="color:#f92672">=</span>product, args<span style="color:#f92672">=</span>(q,))
</span></span><span style="display:flex;"><span>    p1<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>    p2<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;主&#39;</span>)
</span></span></code></pre></div><ul>
<li>守护进程
from multiprocessing import Process
import time</li>
</ul>
<p>def task(name):
print(&lsquo;德邦总管：%s&rsquo; % name)
time.sleep(3)
print(&lsquo;德邦总管: %s&rsquo; % name)</p>
<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:
p1 = Process(target=task, args=(&lsquo;大张红&rsquo;,))
p1.daemon = True
p1.start()
time.sleep(1)
print(&lsquo;恕瑞玛皇帝:小吴勇嗝屁了&rsquo;)</p>
<ul>
<li>僵尸进程和孤儿进程</li>
</ul>
<p>僵尸进程
进程执行完毕后并不会立刻销毁所有的数据 会有一些信息短暂保留下来
比如进程号、进程执行时间、进程消耗功率等给父进程查看
ps:所有的进程都会变成僵尸进程
孤儿进程
子进程正常运行 父进程意外死亡 操作系统针对孤儿进程会派遣福利院管理</p>

  
  </div>
</article>


    <footer id="footer">
  <div class="footer-left">
    Copyright  &copy; 2022  self-salvation 
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
        <li><a href="/">Home</a></li>
         
        <li><a href="/posts/">All posts</a></li>
         
        <li><a href="/tags">Tags</a></li>
         
        <li><a href="/python">Python</a></li>
         
        <li><a href="/databases">databases</a></li>
         
        <li><a href="/about">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>


  </div>
</body>

<link rel="stylesheet" href=/lib/font-awesome/css/all.min.css>
<script src=/lib/jquery/jquery.min.js></script>
<script src=/js/main.js></script>
</html>
