<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on self-salvation</title>
    <link>https://jinkes-li.github.io/posts/</link>
    <description>Recent content in Posts on self-salvation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 19 Aug 2022 16:19:53 +0800</lastBuildDate><atom:link href="https://jinkes-li.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mac设置不休眠</title>
      <link>https://jinkes-li.github.io/posts/mac%E8%AE%BE%E7%BD%AE%E4%B8%8D%E4%BC%91%E7%9C%A0/</link>
      <pubDate>Fri, 19 Aug 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/mac%E8%AE%BE%E7%BD%AE%E4%B8%8D%E4%BC%91%E7%9C%A0/</guid>
      <description>Mac默认情况下合上盖子就会进入休眠状态，正在进行的任务也会停止。我们在终端执行两条命令来将Mac设置为合盖不休眠。
打开Terminal，执行如下两条语句：
sudo pmset -b sleep 0 sudo pmset -b disablesleep 1 若需要恢复原有合盖自动休眠的设置，则执行如下两条语句：
sudo pmset -b sleep 5 sudo pmset -b disablesleep 0 关于pmset命令更多的用法可以在终端执行man pmset来查看。</description>
    </item>
    
    <item>
      <title>aliyun Centos7 如何安装python3.7.4和pip3</title>
      <link>https://jinkes-li.github.io/posts/%E9%98%BF%E9%87%8C%E4%BA%91centos7%E5%AE%89%E8%A3%85python3.7.4%E5%92%8Cpip3/</link>
      <pubDate>Tue, 19 Jul 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E9%98%BF%E9%87%8C%E4%BA%91centos7%E5%AE%89%E8%A3%85python3.7.4%E5%92%8Cpip3/</guid>
      <description>aliyun Centos7 如何安装python3.7.4和pip3
亲测有效，针对 阿里云 centos 7 轻量服务器
python ==&amp;gt; 3.7.4
pip ==&amp;gt; 3
一，打开python官网，找到下载Python的tgz文件，有两种方式下载 （版本可能更新，进官网核实为准）
1，直接在windows系统下了完了，通过xtfp上传文件到/usr/local/下 python官网下载地址：https://www.python.org/downloads/release/python-374/
2、通过wget命令，至于命令后半段下载链接，直接右键点击Gzi&amp;hellip;&amp;hellip;复制链接即可
wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz 二，解压文件，添加一些安装依赖 在/usr/local/目录下解压 (习惯将这里当做文件下载，解压的地方，根据个人情况而定)
tar zxvf Python-3.7.4.tgz 安装依赖
yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel gcc libffi-devel gcc make automake autoconf libtool libffi-devel 且需要安装一个包，libffi-devel为3.7版本需要的一个新的包，否则安装的时候报错 ModuleNotFoundError: No module named &amp;lsquo;_ctypes&amp;rsquo;
yum install libffi-devel -y 进入解压目录
cd Python-3.7.4 进行初始配置 注意：在这之前先将安装目录创建好，否则&amp;hellip;&amp;hellip;.，这里我安装到 /usr/local/python3 目录下
mkdir /usr/local/python3 ./configure --prefix=/usr/local/python3　执行安装</description>
    </item>
    
    <item>
      <title>Kubernetes Coredns 服务发现</title>
      <link>https://jinkes-li.github.io/posts/kubernetes-coredns-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Tue, 19 Jul 2022 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/kubernetes-coredns-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%B5%8B%E8%AF%95/</guid>
      <description>测试 1111服务发现是指服务之间的通讯联通，对于Kubernetes来说服务发现具有3个痛点
服务的动态性强 服务更新发布频繁 服务支持自动伸缩 Kubernetes中的PODIP是不断变化的，这里如何以不变应万变呢，以下两组概念就可以解决这个问题
Kubernetes中抽象出来Service资源，通过标签选择器来关联一组POD Kubernetes中抽象出来了集群网络，通过相对固定的集群IP，使服务的接入点固定 那么如何自动关联Service资源的“名称”和“集群网络IP”，从而达到服务被集群自动发现的目的？
我们可以考虑一下传统的NDS模型： baidu.com —&amp;gt; 111.213.123.1
Kubernetes这里通过Coredns也去建立类似于传统DNS的模型，实现域名和IP（也就是固定接入点）的绑定
部署Coredns
在hdss7-200.host.com上，配置一个NGINX，用以提供kubernetes统一的访问资源清单入口
[root@hdss7-200 ~]# vim /etc/nginx/conf.d/k8s-yaml.od.com.conf server { listen 80; server_name k8s-yaml.od.com; location / { autoindex on; default_type text/plain; root /data/k8s-yaml; } } [root@hdss7-200 html]# cd /data [root@hdss7-200 data]# mkdir k8s-yaml [root@hdss7-200 data]# cd k8s-yaml/ [root@hdss7-200 k8s-yaml]# mkdir coredns [root@hdss7-200 k8s-yaml]# nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful [root@hdss7-200 k8s-yaml]# nginx -s reload [root@hdss7-200 k8s-yaml]# nginx配置中使用了新的域名，需要在内网DNS服务器上配置解析</description>
    </item>
    
    <item>
      <title>项目环境</title>
      <link>https://jinkes-li.github.io/posts/%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Wed, 26 May 2021 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/</guid>
      <description>BI 项目启动环境 此项目使用的是Centos7.9 内核版本5.19，升级历史操作如下 [可参考]
17 rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 18 rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 19 yum --disablerepo=&amp;#34;*&amp;#34; --enablerepo=&amp;#34;elrepo-kernel&amp;#34; list available 20 $ yum --enablerepo=elrepo-kernel install kernel-ml 21 yum --enablerepo=elrepo-kernel install kernel-ml 22 awk -F\&amp;#39; &amp;#39;$1==&amp;#34;menuentry &amp;#34; {print i++ &amp;#34; : &amp;#34; $2}&amp;#39; /etc/grub2.cfg 23 grub2-set-default 0 24 reboot 25 uname -a 26 history ####基本环境安装
install git
[root@web ~]# yum install git -y install docker
安装教程
[root@web ~]# yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine [root@web ~]# yum install -y yum-utils [root@web ~]# yum-config-manager \ --add-repo \ https://download.</description>
    </item>
    
    <item>
      <title>服务状态</title>
      <link>https://jinkes-li.github.io/posts/%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</link>
      <pubDate>Tue, 21 Jan 2020 16:19:53 +0800</pubDate>
      
      <guid>https://jinkes-li.github.io/posts/%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81/</guid>
      <description>服务状体
常常听到的服务状态是什么意思？ 什么是无服务状态和什么是有服务状态
无状态服务
无状态服务不会在本地存储持久化数据.多个服务实例对于同一个用户请求的响应结果是完全一致的.这种多服务实例之间是没有依赖关系,比如web应用,在k8s控制器 中动态启停无状态服务的pod并不会对其它的pod产生影响.
有状态服务
有状态服务需要在本地存储持久化数据,典型的是分布式数据库的应用,分布式节点实例之间有依赖的拓扑关系.比如,主从关系. 如果K8S停止分布式集群中任 一实例pod,就可能会导致数据丢失或者集群的crash.
了解这个之后我们提出一个问题， Deployment部署的问题?
Deployment被设计用来管理无状态服务的pod,每个pod完全一致.什么意思呢?
无状态服务内的多个Pod创建的顺序是没有顺序的. 无状态服务内的多个Pod的名称是随机的.pod被重新启动调度后,它的名称与IP都会发生变化. 无状态服务内的多个Pod背后是共享存储的.
现在看一个新的问题？
对于数据库有状态的服务容器编排,Deployment解决方案就变得无能为力了. 比如,Redis是主从的架构,只能允许集群中出现一个主节点提供写,其它节点提供读能力.如果同时出现二个主节点后,必须会出现并发写的 操作,进一步导致集群写数据的不一致. 所以问题来了,针对Redis这种有状态的服务,它管理的多个Pod(代表master/slave角色)必须有自己独立的持久化存储组件. 有状态的服务Pod是用来运行有状态应用的,其在数据卷上存储的数据非常重要,因为Stateful就是要依赖存储数据卷上对每个Pod的状态进行建模与存储. 所以K8S提供了一个新的工具——StatefulSet来统一解决问题.
Deployment组件是为无状态服务而设计的,其中的Pod名称,主机名,存储都是随机,不稳定的,并且Pod的创建与销毁也是无序的.这个设计决定了无状态服务并 不适合数据库领域的应用.
而Stateful管理有状态的应用,它的Pod有如下特征:
唯一性: 每个Pod会被分配一个唯一序号. 顺序性: Pod启动,更新,销毁是按顺序进行. 稳定的网络标识: Pod主机名,DNS地址不会随着Pod被重新调度而发生变化. 稳定的持久化存储: Pod被重新调度后,仍然能挂载原有的PV,从而保证了数据的完整性和一致性.
等待更新···</description>
    </item>
    
  </channel>
</rss>
